<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NDepend.API</name>
    </assembly>
    <members>
        <member name="T:NDepend.Analysis.AnalysisConstants">
            <summary>
            Analysis Constants.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.AnalysisConstants.GITHUB_BUILD_NUMBER_PREFIX">
            <summary>
            The prefix used before the Github build number, in the analysis result Id.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.AnalysisConstants.GITHUB_BUILD_ID_PREFIX">
            <summary>
            The prefix used before the Github build Id, in the analysis result Id.
            </summary>
        </member>
        <member name="T:NDepend.Analysis.AnalysisException">
            <summary>
            The exception that is thrown when an analysis related operation fails.
            </summary>
            <remarks>
            Methods potentially throwing this exception are: <br />
            ExtensionMethodsProjectAnalysis.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject,System.String)" /><br />
            ExtensionMethodsProjectAnalysis.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.String)" /><br />
            IAnalysisResultRef.<see cref="M:NDepend.Analysis.IAnalysisResultRef.Load" />
            </remarks>
        </member>
        <member name="M:NDepend.Analysis.AnalysisException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Analysis.AnalysisException" /> class with a specified error message.
            </summary>
            <param name="message">A message that describes the error.</param>
        </member>
        <member name="M:NDepend.Analysis.AnalysisException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Analysis.AnalysisException" /> class with a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        </member>
        <member name="M:NDepend.Analysis.AnalysisException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Analysis.AnalysisException" /> class with a specified error message and with a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
        </member>
        <member name="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult">
            <summary>
            Defines the result of calling one of the overload of the method <see cref="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis" />.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryGetAnalysisResultRefToCompareWith(NDepend.Project.IProjectBaseline,NDepend.Analysis.IAnalysisResultRef@)" />.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DoCompareWith">
            <summary>
            An analysis result reference to compare with is defined and has been obtained.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DontCompare">
            <summary>
            No analysis result reference to compare with is defined.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.ErrorGettingTheAnalysisResultRef">
            <summary>
            Error when trying to obtain the analysis result reference to compare with.
            </summary>
        </member>
        <member name="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis">
            <summary>
            Provides a set of extension methods to run analysis (only available with a Build Machine license) and to collect existing analysis results references. 
            </summary>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryGetMostRecentAnalysisResultRef(NDepend.Project.IProject,NDepend.Analysis.IAnalysisResultRef@)">
            <summary>
            Gets a reference to the most recent analysis result available for this <paramref name="project" />.
            </summary>
            <returns>A value indicating if a most recent analysis result referece has been found for this <paramref name="project" />.</returns>
            <param name="project">This NDepend project.</param>
            <param name="mostRecentAnalysisResultRef">The reference to the most recent analysis result or <i>null</i> if the method call returned <i>false</i>.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefs(NDepend.Project.IProject)">
            <summary>
            Gets a collection of all analysis results available for this <paramref name="project" /> ordered by <see cref="T:NDepend.Analysis.IAnalysisResultRef" />.<seealso cref="P:NDepend.Analysis.IAnalysisResultRef.Date" /> descending.
            </summary>
            <param name="project">This NDepend project.</param>
            <remarks>
            If <paramref name="project" />.<see cref="P:NDepend.Project.IProject.HistoricAnalysisResult" /> doesn't save historic analysis results, then the returned list will contain the most recent analysis result available for this <paramref name="project" />, or nothing if no analysis result is available for this <paramref name="project" />.<br />
            On a NDepend project with many analysis results available for years, it is performant wise to prefer calling <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)" /> instead of this method, because analysis results references are then lazy-resolved, per month.
            </remarks>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)">
            <summary>
            Gets a collection of all analysis results available for this <paramref name="project" />, grouped per months.
            </summary>
            <param name="project">This NDepend project.</param>
            <remarks>
            If <paramref name="project" />.<see cref="P:NDepend.Project.IProject.HistoricAnalysisResult" /> doesn't save historic analysis results, then the returned list will contain the most recent analysis result available for this <paramref name="project" />, or nothing if no analysis result is available for this <paramref name="project" />.<br />
            On a NDepend project with many analysis results available for years, it is performant wise to call this method than calling <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefs(NDepend.Project.IProject)" />, because analysis results references are then lazy-resolved, per month.
            </remarks>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryGetAnalysisResultRefToCompareWith(NDepend.Project.IProjectBaseline,NDepend.Analysis.IAnalysisResultRef@)">
            <summary>
            Try gets an analysis reference corresponding to this project baseline to compare with.
            </summary>
            <param name="projectBaseline">This NDepend project baseline, obtained from IProject.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" /> or IProject.<see cref="P:NDepend.Project.IProject.BaselineInUI" />.</param>
            <param name="analysisResultRef">If the method returns <see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.<see cref="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DoCompareWith" />, <paramref name="analysisResultRef" /> is not null and references the analysis result used for baseline.</param>
            <returns><see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.<see cref="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DoCompareWith" /> if an an analysis result reference representing the baseline to compare with can be found, else returns another value of the enumeration <see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.</returns>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryGetAnalysisResultRefToCompareWith(NDepend.Project.IProjectBaseline,NDepend.Analysis.IAnalysisResultRef@,System.String@)">
            <summary>
            Try gets an analysis reference corresponding to this project baseline to compare with.
            </summary>
            <param name="projectBaseline">This NDepend project baseline, obtained from IProject.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" /> or IProject.<see cref="P:NDepend.Project.IProject.BaselineInUI" />.</param>
            <param name="analysisResultRef">If the method returns <see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.<see cref="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DoCompareWith" />, <paramref name="analysisResultRef" /> is not null and references the analysis result used for baseline.</param>
            <param name="failureReason">If the method returns <see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.<see cref="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.ErrorGettingTheAnalysisResultRef" />, <paramref name="failureReason" /> is not null not empty, and explains in plain-english why the project baseline cannot be retrieved.</param>
            <returns><see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.<see cref="F:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult.DoCompareWith" /> if an an analysis result reference representing the baseline to compare with can be found, else returns another value of the enumeration <see cref="T:NDepend.Analysis.TryGetAnalysisResultRefToCompareWithResult" />.</returns>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.BuildAnalysisResultRefFor(NDepend.Project.IProject,NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Create an <see cref="T:NDepend.Analysis.IAnalysisResultRef" /> object from a project, an analysis result file (.ndar extension) and a date.
            </summary>
            <remarks>
            The analysis result is not loaded, only the reference to the analysis result is returned.<br />
            The <see cref="T:NDepend.Analysis.IAnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Date" /> is inferred from the directy path if the analysis result parent directory path. NDepend stores historic analysis result in a folder hierarchy named after <i>YYYY_MM</i> and then sub folder <i>DD_HH_MM_SS</i>.<br /> 
            If the analysis result file is not stored in such folder, <see cref="T:NDepend.Analysis.IAnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Date" /> is the last write date of the analysis result file.
            </remarks>
            <param name="project">The project.</param>
            <param name="analysisResultFilePath">The analysis result file path (.ndar extension).</param>
            <returns>The analysis result reference.</returns>
            <exception cref="T:System.IO.FileNotFoundException">This exception is thrown if the analysis result file <paramref name="analysisResultFilePath" /> doesn't exist.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LoadAnalysisResultFromFile(NDepend.Project.IProject,NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Loads the analysis result of a project from an analysis result file (.ndar extension).
            </summary>
            <param name="project">The project.</param>
            <param name="analysisResultFilePath">The analysis result file path.</param>
            <returns>The analysis result loaded.</returns>
            <exception cref="T:NDepend.Analysis.AnalysisException">If the analysis load fails, an AnalysisException with an informative message is thrown.</exception>
            <exception cref="T:System.IO.FileNotFoundException">This exception is thrown if the analysis result file <paramref name="analysisResultFilePath" /> doesn't exist.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LoadCodeBaseFromAnalysisResultFile(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Loads a code base snapshot from an analysis result file (.ndar extension).
            </summary>
            <param name="analysisResultFilePath">The analysis result file path (.ndar extension).</param>
            <returns>The code base snapshot.</returns>
            <exception cref="T:NDepend.Analysis.AnalysisException">If the analysis load fails, an AnalysisException with an informative message is thrown.</exception>
            <exception cref="T:System.IO.FileNotFoundException">This exception is thrown if the analysis result file <paramref name="analysisResultFilePath" /> doesn't exist.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.String)">
            <summary>
            Runs a full analysis on this project, in-process and synchronously. (Only available with a Build Machine license).
            </summary>
            <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="project">This NDepend project to analyze.</param>
            <param name="analysisResultId">(Optional) An id to identify the analysis result build by this call.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
            <exception cref="T:System.ArgumentException">The string for <paramref name="analysisResultId"/> is invalid. It must be trimmed, a length of maximum 64 characters, excluding characters that cannot fit in a file name \ / : * ? " &gt; &lt; |</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.Action{NDepend.Analysis.IAnalysisLog},System.Action{NDepend.Analysis.IProgressLog},System.String)">
            <summary>
            Runs a full analysis on this project, in-process and synchronously. (Only available with a Build Machine license).
            </summary>
            <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="project">This NDepend project to analyze.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
            <exception cref="T:System.Xml.XmlException">The project file might be corrupted.</exception>
            <exception cref="T:System.ArgumentException">The string for <paramref name="analysisResultId"/> is invalid. It must be trimmed, a length of maximum 64 characters, excluding characters that cannot fit in a file name \ / : * ? " &gt; &lt; |</exception>
            <param name="analysisLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IAnalysisLog" /> object.</param>
            <param name="progressLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
            <param name="analysisResultId">(Optional) An id to identify the analysis result build by this call.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject,System.String)">
            <summary>
            Runs a full analysis on this project, in-process and synchronously, and then generate a HTML report. (Only available with a Build Machine license).
            </summary>
            <remarks>
            The report generated is available in project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />, named "NDependReport.html".<br />
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="project">This NDepend project to analyze.</param>
            <param name="analysisResultId">(Optional) An id to identify the analysis result build by this call.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
            <exception cref="T:System.ArgumentException">The string for <paramref name="analysisResultId"/> is invalid. It must be trimmed, a length of maximum 64 characters, excluding characters that cannot fit in a file name \ / : * ? " &gt; &lt; |</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject,System.Action{NDepend.Analysis.IAnalysisLog},System.Action{NDepend.Analysis.IProgressLog},System.String)">
            <summary>
            Runs a full analysis on this project, in-process and synchronously, and then generate a HTML report. (Only available with a Build Machine license).
            </summary>
            <remarks>
            The report generated is available in project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />, named "NDependReport.html".<br />
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="project">This NDepend project to analyze.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
            <exception cref="T:System.ArgumentException">The string for <paramref name="analysisResultId"/> is invalid. It must be trimmed, a length of maximum 64 characters, excluding characters that cannot fit in a file name \ / : * ? " &gt; &lt; |</exception>
            <param name="analysisLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IAnalysisLog" /> object.</param>
            <param name="progressLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
            <param name="analysisResultId">(Optional) An id to identify the analysis result build by this call.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.CanAllPathsReferencedBeResolvedAsAbsolute(NDepend.Project.IProject)">
            <summary>
            This method returns a list of string, that each describes in plain-english, the failure to resolve as absolute a path referenced by <paramref name="project" />. The list returned is empty if all paths can be resolved as absolute.
            </summary>
            <param name="project">The project on which to try to resolve paths referenced as absolute.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.AnalyzeAssemblies(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Analyze a set of assemblies, in-process and synchronously, and return a <see cref="T:NDepend.Analysis.IAnalysisResult" /> object. (Only available with a Build Machine license).
            </summary>
            <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            Internally, this methods creates a temporary project with the method <see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.String)" /> on this temporary project.
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="applicationAssembliesPath">A collection of string that contains assemblies file paths.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
            <exception cref="T:System.ArgumentNullException">One of the string in <paramref name="applicationAssembliesPath" /> is null.</exception>
            <exception cref="T:System.ArgumentException">One of the string in <paramref name="applicationAssembliesPath" /> is not a valid absolute file path.</exception>
            <exception cref="T:System.IO.FileNotFoundException">One absolute file path in <paramref name="applicationAssembliesPath" /> doesn't exist.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.AnalyzeAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath})">
            <summary>
            Analyze a set of assemblies, in-process and synchronously, and return a <see cref="T:NDepend.Analysis.IAnalysisResult" /> object. (Only available with a Build Machine license).
            </summary>
            <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            Internally, this methods creates a temporary project with the method <see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.String)" /> on this temporary project.
            It is possible to run several analysis simultaneously on several threads in the same AppDomain.
            </remarks>
            <param name="applicationAssembliesPath">A collection of <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object that contains assemblies file paths.</param>
            <returns>The analysis result.</returns>
            <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
            <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
            <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concerning the failure.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)">
            <summary>Force log trend metrics values for this <i>analysisResult</i>.</summary>
            <remarks>
            Trend metrics are extracted from code queries found in <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.<see cref="P:NDepend.Project.IProject.CodeQueries" /> and <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            Rules are extracted from the same code queries sets, for computation of code metrics: <i># Rules</i>, <i># Rules Violated</i>, <i># Rules Violations</i>.<br />
            Trend metrics values are logged into the trend metrics store of the project <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.
            </remarks>
            <param name="analysisResult">This <i>analysisResult</i> on which trend metrics values are computed.</param>
            <param name="logDateTime">The time at which trend metrics values are persisted, typically <see cref="T:System.DateTime" />.<see cref="P:System.DateTime.Now" /> or <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Date" />.</param>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while persisting in the trend store.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.DateTime)">
            <summary>Force log trend metrics values for this <i>analysisResult</i>, with the possibility to execute code rules and trend metrics that require to be run in diff mode.</summary>
            <remarks>
            Trend metrics are extracted from code queries found in <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.<see cref="P:NDepend.Project.IProject.CodeQueries" /> and <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            Rules are extracted from the same code queries sets, for computation of code metrics: <i># Rules</i>, <i># Rules Violated</i>, <i># Rules Violations</i>.<br />
            Trend metrics values are logged into the trend metrics store of the project <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.
            </remarks>
            <param name="analysisResult">This <i>analysisResult</i> on which trend metrics values are computed.</param>
            <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object used to execute code rules and trend metrics that require to be run in diff mode.</param>
            <param name="logDateTime">The time at which trend metrics values are persisted, typically <see cref="T:System.DateTime" />.<see cref="P:System.DateTime.Now" /> or <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Date" />.</param>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while persisting in the trend store.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Project.IProject,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue},System.String,System.DateTime)">
            <summary>Force log trend metrics <paramref name="trendMetricsValues" /> already computed, for this <paramref name="project" />.</summary>
            <remarks>
             Typically this overload of <i>LogTrendMetrics</i> is used with <paramref name="trendMetricsValues" /> computed from
             <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesAndTrendMetrics(NDepend.Analysis.IAnalysisResult,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" /> or <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiffAndTrendMetrics(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" />.
            </remarks>
            <param name="project">This <i>project</i> for which trend metrics values are computed.</param>
            <param name="trendMetricsValues">Trend metric values already computed.</param>
            <param name="label">The log label string. If <i>null</i> or empty no label will be stored. Typically this label is computed through <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryComputeLogLabel(NDepend.Project.IProject,NDepend.CodeModel.ICodeBase,System.String@)" /></param>
            <param name="logDateTime">The time at which trend metrics values are persisted, typically <see cref="T:System.DateTime" />.<see cref="P:System.DateTime.Now" /> or <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Date" />.</param>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while persisting in the trend store.</exception>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryComputeLogLabel(NDepend.Project.IProject,NDepend.CodeModel.ICodeBase,System.String@)">
            <summary>
            Try compute the log label from <paramref name="project" /> and <paramref name="codeBase" />.
            </summary>
            <remarks>
            Typically this method is called to compute the parameter <i>label</i> in this overload <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)" />.
            </remarks>
            <param name="project">The project that contains trend metrics log settings.</param>
            <param name="codeBase">The code base thta contains application assemblies from which log versionning is inferred.</param>
            <param name="label">The log label returned.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)">
            <summary>
            This method compiles and runs all rules against <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.CodeBase" /> and returns all issues in an <see cref="T:NDepend.Issue.IIssuesSet" /> object.
            </summary>
            <remarks>
            This method calls <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" />
            with one day for <i>cqlinqQueryExecTimeOut</i> parameter,
            and with <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.No" /> value for <i>issueReferenceRecord</i> parameter.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)">
            <summary>
            This method compiles and runs all rules on <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.CodeBase" /> and returns all issues in an <see cref="T:NDepend.Issue.IIssuesSet" /> object.
            </summary>
            <remarks>
            The rules are the active rules found in the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />,
            the active rules in active rule file(s) referenced by this project,
            and the active rules found in <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            <br />
            The issues debt is computed and formatted against this project <see cref="T:NDepend.Project.IProjectDebtSettings" />.<br />
            <br />
            Before running the rules, this method also computes the <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> from active code queries prefixed with <i>notmycode</i>, found in the same locations than the rules, and returns it through <paramref name="justMyCode" /> .<br />
            <br />
            Returned sequence of <paramref name="logs" /> contains plain-english logs that represent all problems found while compiling and executing rules.
            This includes rules compilation / execution errors, rules that rely on code coverage not available, rules that relies on diff not available.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
            <param name="cqlinqQueryExecTimeOut">The code query execution time-out duration.</param>
            <param name="issueReferenceRecord">A value that indicates if each issue in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object references the corresponding query execution <see cref="T:NDepend.CodeQuery.RecordBase" /> object.</param>
            <param name="justMyCode">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed, against which rules have been executed.</param>
            <param name="logs">A sequence of plain-english logs that represent all problems found while compiling and executing rules, and that can explain some unexpected issues state in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)">
            <summary>
            This method compiles and runs all rules against both code base snapshots of <paramref name="compareContext" /> (<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />) and returns all baseline and newer issues compared in an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.
            </summary>
            <remarks>
            This method calls <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,NDepend.CodeModel.ICodeBaseView@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" />
            with one day for <i>cqlinqQueryExecTimeOut</i> parameter,
            and with <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.No" /> for <i>issueReferenceRecord</i> parameter.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
            <param name="compareContext">Issues are computed for both this <see cref="T:NDepend.CodeModel.ICompareContext" /> object <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, and are the compared in the return <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,NDepend.CodeModel.ICodeBaseView@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)">
            <summary>
            This method compiles and runs all rules against both code base snapshots of <paramref name="compareContext" /> (<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />) and returns all baseline and newer issues compared in an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.
            </summary>
            <remarks>
            The rules are the active rules found in the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />,
            the active rules in active rule file(s) referenced by this project,
            and the active rules found in <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            <br />
            The issues debt is computed and formatted against this project <see cref="T:NDepend.Project.IProjectDebtSettings" />.<br />
            <br />
            Before running the rules, this method also computes both <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> from active code queries prefixed with <i>notmycode</i>, found in the same locations than the rules, and returns them through <paramref name="justMyCodeOld" /> and <paramref name="justMyCodeNew" />.<br />
            <br />
            Returned sequence of <paramref name="logs" /> contains plain-english logs that represent all problems found while compiling and executing rules.
            This includes rules compilation / execution errors, rules that rely on code coverage not available, rules that relies on diff not available.<br />
            <br />
            Rules are executed twice against <paramref name="compareContext" /> <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />,
            except rule that relies on diff, like the rule <i>API breaking change</i> for example.
            Such rule is only executed once and its issues are only present in the <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> of the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.<br />
            <br />
            If a rule has compilation or execution error on one code base snapshot but not on the other one, 
            a log is emitted and issues obtained from execution against the other snapshot are not taken account in the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
            <param name="compareContext">Issues are computed for both this <see cref="T:NDepend.CodeModel.ICompareContext" /> object <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, and are the compared in the return <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.</param>
            <param name="cqlinqQueryExecTimeOut">The code query execution time-out duration.</param>
            <param name="issueReferenceRecord">A value that indicates if each issue in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object references the corresponding query execution <see cref="T:NDepend.CodeQuery.RecordBase" /> object.</param>
            <param name="justMyCodeOld">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed for <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, against which rules have been executed.</param>
            <param name="justMyCodeNew">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed for <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />, against which rules have been executed.</param>
            <param name="logs">A sequence of plain-english log that represents all problems found while compiling and executing rules, and that can explain some unexpected issues state in the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesAndTrendMetrics(NDepend.Analysis.IAnalysisResult,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)">
            <summary>
            This method compiles and runs all rules and trend metrics on <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.CodeBase" /> and returns all issues in an <see cref="T:NDepend.Issue.IIssuesSet" /> object and returns also all <paramref name="trendMetricsValues" />.
            </summary>
            <remarks>
            This method is optimized and takes account of the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object to compute trend metrics.
            Hence this method is almost twice faster than calling first <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)" /> and then <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)" />.
            <br />
            If you wish to log the obtained <paramref name="trendMetricsValues" /> first call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryComputeLogLabel(NDepend.Project.IProject,NDepend.CodeModel.ICodeBase,System.String@)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)" />.
            <br />
            The rules are the active rules found in the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />,
            the active rules in active rule file(s) referenced by this project,
            and the active rules found in <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            <br />
            The issues debt is computed and formatted against this project <see cref="T:NDepend.Project.IProjectDebtSettings" />.<br />
            <br />
            Before running the rules, this method also computes the <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> from active code queries prefixed with <i>notmycode</i>, found in the same locations than the rules, and returns it through <paramref name="justMyCode" /> .<br />
            <br />
            Returned sequence of <paramref name="logs" /> contains plain-english logs that represent all problems found while compiling and executing rules.
            This includes rules compilation / execution errors, rules that rely on code coverage not available, rules that relies on diff not available.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
            <param name="cqlinqQueryExecTimeOut">The code query execution time-out duration.</param>
            <param name="issueReferenceRecord">A value that indicates if each issue in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object references the corresponding query execution <see cref="T:NDepend.CodeQuery.RecordBase" /> object.</param>
            <param name="trendMetricsValues">The trend metrics values extracted from the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.</param>
            <param name="justMyCode">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed, against which rules have been executed.</param>
            <param name="logs">A sequence of plain-english logs that represent all problems found while compiling and executing rules, and that can explain some unexpected issues state in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiffAndTrendMetrics(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)">
            <summary>
            This method compiles and runs all rules and trend metrics against both code base snapshots of <paramref name="compareContext" /> (<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />) and returns all baseline and newer issues compared in an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object and returns also all <paramref name="trendMetricsValues" />.
            </summary>
            <remarks>
            This method is optimized and takes account of the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object to compute trend metrics.
            Hence this method is almost twice faster than calling first <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)" /> and then <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)" />.
            <br />
            If you wish to log the obtained <paramref name="trendMetricsValues" /> first call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryComputeLogLabel(NDepend.Project.IProject,NDepend.CodeModel.ICodeBase,System.String@)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.LogTrendMetrics(NDepend.Analysis.IAnalysisResult,System.DateTime)" />.
            <br />
            The rules are the active rules found in the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />,
            the active rules in active rule file(s) referenced by this project,
            and the active rules found in <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.<br />
            <br />
            The issues debt is computed and formatted against this project <see cref="T:NDepend.Project.IProjectDebtSettings" />.<br />
            <br />
            Before running the rules, this method also computes both <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> from active code queries prefixed with <i>notmycode</i>, found in the same locations than the rules, and returns them through <paramref name="justMyCodeOld" /> and <paramref name="justMyCodeNew" />.<br />
            <br />
            Returned sequence of <paramref name="logs" /> contains plain-english logs that represent all problems found while compiling and executing rules.
            This includes rules compilation / execution errors, rules that rely on code coverage not available, rules that relies on diff not available.<br />
            <br />
            Rules are executed twice against <paramref name="compareContext" /> <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />,
            except rule that relies on diff, like the rule <i>API breaking change</i> for example.
            Such rule is only executed once and its issues are only present in the <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> of the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.<br />
            <br />
            If a rule has compilation or execution error on one code base snapshot but not on the other one, 
            a log is emitted and issues obtained from execution against the other snapshot are not taken account in the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.
            </remarks>
            <param name="analysisResult">The analysis result on which to compute the issues.</param>
            <param name="compareContext">Issues are computed for both this <see cref="T:NDepend.CodeModel.ICompareContext" /> object <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, and are the compared in the return <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.</param>
            <param name="cqlinqQueryExecTimeOut">The code query execution time-out duration.</param>
            <param name="issueReferenceRecord">A value that indicates if each issue in the returned <see cref="T:NDepend.Issue.IIssuesSet" /> object references the corresponding query execution <see cref="T:NDepend.CodeQuery.RecordBase" /> object.</param>
            <param name="trendMetricsValues">The trend metrics values extracted from the project <paramref name="analysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.Project" />.</param>
            <param name="justMyCodeOld">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed for <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, against which rules have been executed.</param>
            <param name="justMyCodeNew">The <i>just-my-code</i> <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object computed for <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />, against which rules have been executed.</param>
            <param name="logs">A sequence of plain-english log that represents all problems found while compiling and executing rules, and that can explain some unexpected issues state in the returned <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.</param>
        </member>
        <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.PointsToSameAnalysisResultAs(NDepend.Analysis.IAnalysisResultRef,NDepend.Analysis.IAnalysisResultRef)">
            <summary>
            Returns <i>true</i> if both analysis result references point to the same analysis result.
            </summary>
            <param name="ref1">This analysis result reference</param>
            <param name="ref2">The other analysis result reference</param>
        </member>
        <member name="T:NDepend.Analysis.AnalysisLogCategory">
            <summary>
            Represents an analysis log category: Info / Warning / Error.
            </summary>
        </member>
        <member name="F:NDepend.Analysis.AnalysisLogCategory.Info">
            <summary>
            AnalysisLogCategory.Info
            </summary>
        </member>
        <member name="F:NDepend.Analysis.AnalysisLogCategory.Warning">
            <summary>
            AnalysisLogCategory.Warning
            </summary>
        </member>
        <member name="F:NDepend.Analysis.AnalysisLogCategory.Error">
            <summary>
            AnalysisLogCategory.Error
            </summary>
        </member>
        <member name="T:NDepend.Analysis.IAnalysisLog">
            <summary>
            Represents a log emitted at analysis execution time.
            </summary>
            <remarks>
            <see cref="T:NDepend.Analysis.IAnalysisLog" /> objects can be gathered by dedicated overloads of run analysis extension methods in <see cref="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis" />.
            </remarks>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisLog.Category">
            <summary>
            Gets this analysis log category.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisLog.Description">
            <summary>
            Gets this analysis log description.
            </summary>
        </member>
        <member name="T:NDepend.Analysis.IAnalysisManager">
            <summary>
            Exposes the unique ShowDialogBuildComparison method. A IAnalysisManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.AnalysisManager" />.
            </summary>
        </member>
        <member name="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(System.IntPtr,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)">
            <summary>
            Shows a dialog that lets the user select an older and newer, project or analysis result reference.
            </summary>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="projectOlder">Project older choosen, is null if <paramref name="analysisResultRefOlder" /> is not null.</param>
            <param name="analysisResultRefOlder">Analysis Result older choosen, is null if <paramref name="projectOlder" /> is not null.</param>
            <param name="projectNewer">Project newer choosen, is null if <paramref name="analysisResultRefNewer" /> is not null.</param>
            <param name="analysisResultRefNewer">Analysis Result newer choosen, is null if <paramref name="projectNewer" /> is not null.</param>
            <returns>True if the user clicked OK, False if the user clicked Cancel</returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(System.IntPtr,NDepend.Project.IProject@)" />
            <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
        </member>
        <member name="T:NDepend.Analysis.IAnalysisResult">
            <summary>
            Represents an analysis result. 
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef">
            <summary>
            Gets a <see cref="T:NDepend.Analysis.IAnalysisResultRef" /> object corresponding to this analysis result.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResult.CodeBase">
            <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBase" /> object representing the code base snapshot for this analysis result.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode">
            <summary>
            Gets the root group containing code rules and queries defined in the code base through the attribute <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
            <seealso cref="M:NDepend.Project.ExtensionMethodsProject.GetRulesInProjectFileAndInRuleFilesAndDeclaredInSourceCode(NDepend.Project.IProject,NDepend.CodeQuery.IGroup)" />
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResult.SuppressedMessages">
            <summary>
            Gets valid usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> in source code with the category "NDepend" indexed by their rule-id or rule category.
            </summary>
            <remarks>
            Invalid usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> with a category string starting with "NDepend" are reported as warnings and are not present here.
            </remarks>
        </member>
        <member name="T:NDepend.Analysis.IAnalysisResultRef">
            <summary>
            Represents a reference to a NDepend analysis result.
            </summary>
        </member>
        <member name="M:NDepend.Analysis.IAnalysisResultRef.Load">
            <summary>
            Loads the analysis result corresponding to this analysis result reference.
            </summary>
            <returns>The analysis result loaded.</returns>
            <exception cref="T:NDepend.Analysis.AnalysisException">If the analysis load fails, an AnalysisException with an informative message is thrown.</exception>
        </member>
        <member name="M:NDepend.Analysis.IAnalysisResultRef.Load(System.Action{NDepend.Analysis.IProgressLog})">
            <summary>
            Loads the analysis result corresponding to this analysis result reference.
            </summary>
            <returns>The analysis result loaded.</returns>
            <param name="progressLogHandler">A procedure delegate object that is invoked each time the current analysis load emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
            <exception cref="T:NDepend.Analysis.AnalysisException">
            If the analysis load fails, an <see cref="T:NDepend.Analysis.AnalysisException" /> is thrown. 
            This <see cref="T:NDepend.Analysis.AnalysisException" /> contains an inner exception with an informative message.
            </exception>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.Project">
            <summary>
            Gets the NDepend project from which the analysis has been done.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.Date">
            <summary>
            Gets the date when the analysis execution finished.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.AnalysisResultFilePath">
            <summary>
            Gets the path to the analysis result data file.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.ReportFilePath">
            <summary>
            Gets the path to the report file corresponding to the analysis result.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.IsHistoric">
            <summary>
            Returns <i>true</i> if the analysis data is stored in a historic directory. Returns false if the analysis data is stored in the project output directory.
            </summary>
            <remarks>
            A historic directory is a sub-directory of the project output directory.
            </remarks>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultRef.Id">
            <summary>
            Gets the analysis result referenced Id if any, else returns the empty string.
            </summary>
            <remarks>
            You can assign the Id "v1.2.3" to an analysis result by adding the suffix "_Id_v1.2.3" to the analysis result .ndar file name like for example: <br />
            NDependAnalysisResult_YourProject_Date_Id_1.2.3.ndar<br />
            An Id is made of maximum 64 characters, excluding characters that cannot fit in a file name \ / : * ? " &gt; &lt; |.
            </remarks>
        </member>
        <member name="T:NDepend.Analysis.IAnalysisResultsRefsForAMonth">
            <summary>
            Represents a collection of available analysis results references, done during a particular month.
            </summary>
            <remarks>
            A collection of <see cref="T:NDepend.Analysis.IAnalysisResultsRefsForAMonth" /> object can be obtained from a <see cref="T:NDepend.Project.IProject" /> object through the extension method <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)" />.<br />
            The collection of analysis results references is lazy loaded when calling the property <see cref="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs" />. 
            </remarks>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.MonthDate">
            <summary>
            Gets the month date.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs">
            <summary>
            Gets a cloned read-only list of analysis results' references available for the specified month.
            </summary>
            <remarks>
            The collection of analysis results references is lazy loaded when calling the property <see cref="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs" />. 
            </remarks>
        </member>
        <member name="T:NDepend.Analysis.IProgressLog">
            <summary>
            Represents a progress log emitted at analysis execution time or existing analysis result load time.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IProgressLog.EstimatedPercentageDone">
            <summary>
            Gets this progress log estimated percentage done, between 0 and 100 included.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IProgressLog.Description">
            <summary>
            Gets this analysis log description.
            </summary>
        </member>
        <member name="T:NDepend.Analysis.IssueComputationLogCategory">
            <summary>
            Represents an issue computation log category: Info / Warning / Error.
            </summary>
            <remarks>
            So far <see cref="F:NDepend.Analysis.IssueComputationLogCategory.Error" /> logs represent rule compilation or execution errors
            and <see cref="F:NDepend.Analysis.IssueComputationLogCategory.Warning" /> logs represent a rule that relies on code coverage or on baseline, that is not available.
            So far there is no <see cref="F:NDepend.Analysis.IssueComputationLogCategory.Info" /> logs emitted during issues computation.
            </remarks>
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)" />
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesAndTrendMetrics(NDepend.Analysis.IAnalysisResult,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" />
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiffAndTrendMetrics(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext,System.TimeSpan,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IReadOnlyList{NDepend.Trend.MetricValue}@,NDepend.CodeModel.ICodeBaseView@,NDepend.CodeModel.ICodeBaseView@,System.Collections.Generic.IEnumerable{NDepend.Analysis.IIssueComputationLog}@)" />
        </member>
        <member name="F:NDepend.Analysis.IssueComputationLogCategory.Info">
            <summary>
            IssueComputationLogCategory.Info
            </summary>
        </member>
        <member name="F:NDepend.Analysis.IssueComputationLogCategory.Warning">
            <summary>
            IssueComputationLogCategory.Warning
            </summary>
        </member>
        <member name="F:NDepend.Analysis.IssueComputationLogCategory.Error">
            <summary>
            IssueComputationLogCategory.Error
            </summary>
        </member>
        <member name="T:NDepend.Analysis.IIssueComputationLog">
            <summary>
            Represents a log emitted at analysis execution time.
            </summary>
            <remarks>
            <see cref="T:NDepend.Analysis.IIssueComputationLog" /> objects can be gathered by dedicated overloads of compute issues extension methods in <see cref="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis" />.
            </remarks>
        </member>
        <member name="P:NDepend.Analysis.IIssueComputationLog.Category">
            <summary>
            Gets this analysis log category.
            </summary>
        </member>
        <member name="P:NDepend.Analysis.IIssueComputationLog.Description">
            <summary>
            Gets this analysis log description.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.FullCoveredAttribute">
            <summary>
            This attribute can be used to declare that a code element is 100% covered by tests. 
            </summary>
            <remarks>
            The code metric ICodeContainer.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> can be used to determine whether a code element is 100% covered by tests or not.<br />
            Having types 100% covered by tests is a good idea because the small portion of code hard to cover, is also the portion of code that is the most likely to contain bugs.<br />
            Usage of this attributes is checked with the two default code rules:
            <ul>
            <li>Types tagged with FullCoveredAttribute should be 100% covered</li>
            <li>Types 100% covered should be tagged with FullCoveredAttribute</li>
            </ul>
            If you don't want to link <i>NDepend.API.dll</i>, you can use your own <i>FullCoveredAttribute</i> and adapt the rules.<br />
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.FullCoveredAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.FullCoveredAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.FullBranchCoveredAttribute">
            <summary>
            This attribute can be used to declare that a method is 100% branch covered by tests (branch coverage is only available with NCover and OpenCover). 
            </summary>
            <remarks>
            The branch coverage code metric is only available with NCover. <br />
            The code metric IMethod.<see cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" /> can be used to determine whether a method is 100% branch covered by tests or not.<br />
            A code rule is provided by default to continuously make sure that all method tagged with this attribute are indeed 100% branch covered by tests.<br />
            A code rule is provided by default to continuously make sure that all method 100% branch covered by tests are tagged with this attribute.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.FullBranchCoveredAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.FullBranchCoveredAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.MoreThan95PercentCoveredAttribute">
            <summary>
            This attribute can be used to declare that a code element is more than 95% covered by tests. 
            </summary>
            <remarks>
            The code metric ICodeContainer.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> can be used to determine whether a code element is more than 95% covered by test or not.<br />
            A code rule is provided by default to continuously make sure that all code elements tagged with this attribute are indeed more than 95% covered by tests.<br />
            A code rule is provided by default to continuously make sure that all code elements more than 95% covered by tests are tagged with this attribute.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.MoreThan95PercentCoveredAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.MoreThan95PercentCoveredAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.UncoverableByTestAttribute">
            <summary>
            This attribute can be used to declare that a code element is not coverable by tests. 
            </summary>
            <remarks>
            This attribute is useful to keep a class deemed as 100% covered by tests, even if one of its methods is not coverable by tests (for example because it calls a blocking method such as MessageBox.Show()).<br />
            This attribute is typically defined through  <see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />.
            </remarks>
            <seealso cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.UncoverableByTestAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.UncoverableByTestAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.CodeRuleAttribute">
            <summary>
            This attribute can be used to declare a code rule (or query) in your source code.
            </summary>
            <remarks>
            The code rule is a CQLinq or CQL string.<br />
            It is extracted automatically from assemblies analyzed at analysis time.<br />
            A code rule gathered from a <see cref="T:NDepend.Attributes.CodeRuleAttribute" /> appears under a group named: "Rules extracted from Source Code".<br />
            Under this rule, code rules are grouped under the parent namespaces of code elements tagged by <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.<br />
            More information at <a href="https://www.ndepend.com/docs/declare-cqlinq-rules-in-csharp-or-vbnet-code">Rules extracted from code</a>
            </remarks>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
            <seealso cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />
        </member>
        <member name="M:NDepend.Attributes.CodeRuleAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Attributes.CodeRuleAttribute" /> class, from the specified <paramref name="codeRuleString" />.
            </summary>
            <remarks>
            When declaring a code rule in source file, you can use one of the tags $FullName$ or $Name$ to paste in the rule string the <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the code element tagged or the <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the member (type/method/field) tagged.
            </remarks>
            <param name="codeRuleString">The string that contains the CQLinq or CQL code rule or query.</param>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.CodeRuleString">
            <summary>
            Gets the CQLinq or CQL code rule string or query string.
            </summary>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.Active">
            <summary>
            Gets or sets a value that indicates whether the code rule is active.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplayListInReport">
            <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements are listed into the report.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplayStatInReport">
            <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements statistics are shown into the report.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplaySelectionViewInReport">
            <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.
            </summary>
            <remarks>
            The default value is false.
            </remarks>
        </member>
        <member name="P:NDepend.Attributes.CodeRuleAttribute.IsCriticalRule">
            <summary>
            Gets or sets a value that indicates whether the code rule is critical or not.
            </summary>
            <remarks>
            The default value is false.<br />
            A critical code rule is useful to break the build process once the rule is violated.<br />
            More information at: <a href="https://www.ndepend.com/docs/critical-cqlinq-rule">Critical Rules and Build Failure</a>
            </remarks>
        </member>
        <member name="M:NDepend.Attributes.CodeRuleAttribute.GetHashCode">
            <summary>
            System.Object.GetHashCode() is overridden for this class <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
        </member>
        <member name="M:NDepend.Attributes.CodeRuleAttribute.Equals(System.Object)">
            <summary>
            System.Object.GetHashCode() is overridden for this class <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.ImmutableAttribute">
            <summary>
            This attribute can be used to declare a type as immutable. 
            </summary>
            <remarks>
            A class or structure is immutable if its instance object's state, cannot be modified after it is created. This is in contrast to a mutable object, which can be modified after it is created.<br />
            The property IType.<see cref="P:NDepend.CodeModel.IType.IsImmutable" /> can be used to determine whether a type is immutable or not.<br />
            A code rule is provided by default to continuously make sure that all types tagged with this attribute are indeed immutable.<br />
            A code rule is provided by default to continuously make sure that all immutable types are tagged with this attribute.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.IsImmutable" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.ImmutableAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.PureAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.PureAttribute">
            <summary>
            This attribute can be used to declare a method as pure. 
            </summary>
            <remarks>
            A method is pure if it cannot be called in a way to provoque a side-effect.<br />
            The properties IMethod.<see cref="P:NDepend.CodeModel.IMethod.ChangesObjectState" /> and IMethod.<see cref="P:NDepend.CodeModel.IMethod.ChangesTypeState" /> can be used to determine whether a method is pure or not.<br />
            A code rule is provided by default to continuously make sure that all methods tagged with this attribute are pure.<br />
            A code rule is provided by default to continuously make sure that all pure methods are tagged with this attribute.<br />
            Since .NET v4, you can also use the attribute type System.Diagnostics.Contracts.PureAttribute declared in mscorlib (only for VS projects on which Microsoft Code Contract is enabled, else the PureAttribute is discarded by the compiler).
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.ChangesObjectState" />
            <seealso cref="P:NDepend.CodeModel.IMethod.ChangesTypeState" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.PureAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.PureAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute">
            <summary>
            This attribute can be used to signify that despite a member could have a lower visibility without provoking any syntax error, your intention is to not change this member visibility.
            </summary>
            <remarks>
            Default Visibility code rules take account of this attribute.<br />
            Compare IMember.<see cref="P:NDepend.CodeModel.IMember.Visibility" /> and IMember.<see cref="P:NDepend.CodeModel.IMember.OptimalVisibility" /> values to detect members whose visibility can be decreased.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMember.CouldBePrivate" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.CannotDecreaseVisibilityAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.Attributes.IsNotDeadCodeAttribute">
            <summary>
            This attribute can be used to signify that despite a member could be removed without provoking any syntax error (we also say it is dead code), your intention is to not remove this member.
            </summary>
            <remarks>
            Some code rules are provided by default to match dead types, methods and fields, except those tagged with this attribute.<br />
            Typically, this attribute is useful when the code element  :
            <ul>
            <li>is only used by tests</li>
            <li>is only used for debugging purposes</li>
            <li>is only used by reflection or remoting, like for some serialization methods</li>
            <li>is a class that contains only constants, hence it is never used in IL code, and it is never seen as used by NDepend</li>
            <li>is a field whose only need is for LayoutKind.Sequential reasons</li>
            </ul>
            </remarks>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
        </member>
        <member name="M:NDepend.Attributes.IsNotDeadCodeAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.IsNotDeadCodeAttribute" /> class.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ExtensionMethodsProjection">
            <summary>
            Provides a set of extension methods to realize projection of a sequence of code elements to a sequence of children or parents code elements. 
            </summary>
            <remarks>
            All output sequences contain distinct code elements objects, even upon input sequence containing doublons code elements objects.<br />
            Sequences returned are ordered this way: all assemblies objects first (if any), then all namespaces objects (if any), then all types objects (if any), then all methods objects (if any), then all fields objects (if any).<br />
            Some <i>OrderByHierarchy()</i> and <i>OrderByName()</i> extension methods are also provided by this class to order result sequence differently if needed.
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> objects child of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> and <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> and <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildNamespacesTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> and <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildNamespacesTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" /> and <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects, containing these <paramref name="assemblies" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects.
            </summary>
            <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects, containing these <paramref name="fields" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="fields" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing these <paramref name="fields" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="fields" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="fields" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IMember" /> objects contained in this sequence <paramref name="members" />.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects, containing these <paramref name="members" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMember" /> objects contained in this sequence <paramref name="members" />.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="members" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IMember" /> objects contained in this sequence <paramref name="members" />.
            </summary>
            <remarks>
            For a <see cref="T:NDepend.CodeModel.IType" /> object in the sequence <paramref name="members" />, a parent type is added to the result sequence only if it is a nested type.<br /> 
            If such a type is nested in a nested type all its parents types are added to the result sequence.<br />  
            If the parent type of a nested type is already in the sequence <paramref name="members" />, it is not added a second time because all sequences returned by projection methods are doublon-free.
            </remarks>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing these <paramref name="members" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <remarks>
            For a <see cref="T:NDepend.CodeModel.IType" /> object in the sequence <paramref name="members" />, a parent type is added to the result sequence only if it is a nested type.<br />
            If such a type is nested in a nested type all its parents types are added to the result sequence.<br />  
            If the parent type of a nested type is already in the sequence <paramref name="members" />, it is not added a second time because all sequences returned by projection methods are doublon-free.
            </remarks>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IMember" /> objects contained in this sequence <paramref name="members" />.
            </summary>
            <remarks>
            For a <see cref="T:NDepend.CodeModel.IType" /> object in the sequence <paramref name="members" />, a parent type is added to the result sequence only if it is a nested type.<br />
            If such a type is nested in a nested type all its parents types are added to the result sequence.<br />  
            If the parent type of a nested type is already in the sequence <paramref name="members" />, it is not added a second time because all sequences returned by projection methods are doublon-free.
            </remarks>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="members" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <remarks>
            For a <see cref="T:NDepend.CodeModel.IType" /> object in the sequence <paramref name="members" />, a parent type is added to the result sequence only if it is a nested type.<br />
            If such a type is nested in a nested type all its parents types are added to the result sequence.<br />  
            If the parent type of a nested type is already in the sequence <paramref name="members" />, it is not added a second time because all sequences returned by projection methods are doublon-free.
            </remarks>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMember" /> objects contained in this sequence <paramref name="members" />.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="members" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="methods" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="methods" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="methods" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <remarks>This extension method could also return a sequence of <see cref="T:NDepend.CodeModel.IMember" />. The choice of <see cref="T:NDepend.CodeModel.ICodeContainer" /> is arbitrary and <see cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" /> can still be used on returned sequence.</remarks>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesNamespacesAndTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="methods" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="methods" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all <see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> objects, and all their <see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildTypesAndMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="namespaces" /> and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects.
            </summary>
            <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.OrderByHierarchy(System.Collections.Generic.IEnumerable{NDepend.CodeModel.ICodeElement})">
            <summary>
            Returns a sequence that contain these <paramref name="codeElements" /> ordered by hierarchy. For example an assembly of <paramref name="codeElements" /> is followed by its first child namespace in sequence, that is followed by its first child type in the sequence...
            </summary>
            <remarks>
            An <see cref="T:NDepend.CodeModel.IAssembly" /> object, is followed by its child <see cref="T:NDepend.CodeModel.INamespace" /> objects.<br />
            A <see cref="T:NDepend.CodeModel.INamespace" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IType" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IMethod" /> and <see cref="T:NDepend.CodeModel.IField" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is also followed by its nested <see cref="T:NDepend.CodeModel.IType" />objects.<br /> 
            </remarks>
            <param name="codeElements">This sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.OrderByHierarchy(System.Collections.Generic.IEnumerable{NDepend.CodeModel.ICodeElementParent})">
            <summary>
            Returns a sequence that contain these <paramref name="codeElementParents" /> ordered by hierarchy. For example an assembly of <paramref name="codeElementParents" /> is followed by its first child namespace in sequence, that is followed by its first child type in the sequence...
            </summary>
            <remarks>
            An <see cref="T:NDepend.CodeModel.IAssembly" /> object, is followed by its child <see cref="T:NDepend.CodeModel.INamespace" /> objects.<br />
            A <see cref="T:NDepend.CodeModel.INamespace" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IType" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is also followed by its nested <see cref="T:NDepend.CodeModel.IType" />objects.<br /> 
            </remarks>
            <param name="codeElementParents">This sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.OrderByHierarchy(System.Collections.Generic.IEnumerable{NDepend.CodeModel.ICodeContainer})">
            <summary>
            Returns a sequence that contain these <paramref name="codeContainers" /> ordered by hierarchy. For example an assembly of <paramref name="codeContainers" /> is followed by its first child namespace in sequence, that is followed by its first child type in the sequence...
            </summary>
            <remarks>
            An <see cref="T:NDepend.CodeModel.IAssembly" /> object, is followed by its child <see cref="T:NDepend.CodeModel.INamespace" /> objects.<br />
            A <see cref="T:NDepend.CodeModel.INamespace" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IType" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IMethod" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is also followed by its nested <see cref="T:NDepend.CodeModel.IType" />objects.<br /> 
            </remarks>
            <param name="codeContainers">This sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.OrderByHierarchy(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMember})">
            <summary>
            Returns a sequence that contain these <paramref name="members" /> ordered by hierarchy. For example a type of <paramref name="members" /> is followed by its first child method in sequence, that is followed by its second child method in the sequence...
            </summary>
            <remarks>
            A <see cref="T:NDepend.CodeModel.IType" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IMethod" /> and <see cref="T:NDepend.CodeModel.IField" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is also followed by its nested <see cref="T:NDepend.CodeModel.IType" />objects.<br /> 
            </remarks>
            <param name="members">This sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.OrderByHierarchy(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAttributeTarget})">
            <summary>
            Returns a sequence that contain these <paramref name="attributeTargets" /> ordered by hierarchy. For example an assembly of <paramref name="attributeTargets" /> is followed by its first child type in sequence, that is followed by its first child method in the sequence...
            </summary>
            <remarks>
            An <see cref="T:NDepend.CodeModel.IAssembly" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IType" /> objects.<br />
            A <see cref="T:NDepend.CodeModel.IType" /> object, is followed by its child <see cref="T:NDepend.CodeModel.IMethod" /> and <see cref="T:NDepend.CodeModel.IField" /> objects.<br /> 
            A <see cref="T:NDepend.CodeModel.IType" /> object, is also followed by its nested <see cref="T:NDepend.CodeModel.IType" />objects.<br /> 
            </remarks>
            <param name="attributeTargets">This sequence of <see cref="T:NDepend.CodeModel.IAttributeTarget" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="types" /> and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="types" /> and all their <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeContainer" /> objects, containing these <paramref name="types" /> and all their <see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" /> objects.
            </summary>
            <remarks>This extension method could also return a sequence of <see cref="T:NDepend.CodeModel.IMember" />. The choice of <see cref="T:NDepend.CodeModel.ICodeContainer" /> is arbitrary and <see cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" /> can still be used on returned sequence.</remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.IType.Fields" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing these <paramref name="types" /> and all their <see cref="P:NDepend.CodeModel.IType.Fields" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing all <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElementParent" /> objects, containing these <paramref name="types" /> and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing all <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMember" /> objects, containing these <paramref name="types" /> and and all their <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndParentAssembliesAndNamespacesAndChildMembers(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.ICodeElement" /> objects, containing these <paramref name="types" /> and and all their <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" />, <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMembers" /> objects.
            </summary>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.NestedTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all types nested in types of the sequence <paramref name="types" />.
            </summary>
            <remarks>
            If a type has a nested type that has a nested type, both nested types are returned.<br />
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation represented by <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> is not resolved.
            Hence this extension method only works for application types, not for third-party types.
            </remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects made of parent types of types in <paramref name="types" /> that are nested in parent types.
            </summary>
            <remarks>
            If a type is nested in a type nested in a type, both parent types are returned.
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation represented by <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> is not resolved.
            Hence this extension method only works for application types, not for third-party types.
            </remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndOurNestedTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing these <paramref name="types" /> and all their nested types.
            </summary>
            <remarks>
            If a type has a nested type that has a nested type, both nested types are returned.
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation represented by <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> is not resolved.
            Hence this extension method only works for application types, not for third-party types.
            </remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndOurParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing these <paramref name="types" /> and, for types in <paramref name="types" /> that are nested in parent types, the returned sequence contains also all their parent types.
            </summary>
            <remarks>
            If a type is nested in a type nested in a type, both parent types are returned.
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation represented by <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> is not resolved.
            Hence this extension method only works for application types, not for third-party types.
            </remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.UsAndOurParentTypesAndOurNestedTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing these <paramref name="types" /> and all their nested types and, for types in <paramref name="types" /> that are nested in parent types, the returned sequence contains also all their parent types.
            </summary>
            <remarks>
            If a type has a nested type that has a nested type, both nested types are returned.<br />
            If a type is nested in a type nested in a type, both parent types are returned.<br />
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation represented by <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> is not resolved.
            Hence this extension method only works for application types, not for third-party types.
            </remarks>
            <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="T:NDepend.CodeModel.Visibility">
            <summary>
            Represents the visibility of a <see cref="T:NDepend.CodeModel.IMember" /> object.
            </summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.None">
            <summary>Visibility.None</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.Public">
            <summary>Visibility.Public</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.ProtectedAndInternal">
            <summary>Visibility.ProtectedAndInternal</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.ProtectedOrInternal">
            <summary>Visibility.ProtectedOrInternal</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.Internal">
            <summary>Visibility.Internal</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.Protected">
            <summary>Visibility.Protected</summary>
        </member>
        <member name="F:NDepend.CodeModel.Visibility.Private">
            <summary>Visibility.Private</summary>
        </member>
        <member name="T:NDepend.CodeModel.ExtensionMethodsHelpers">
            <summary>
            Provides a set of extension methods that makes the code model API usage more convenient to use. 
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)">
            <summary>Creates a new <see cref="T:NDepend.CodeModel.ICompareContext" /> object, with <paramref name="newer" /> for <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <paramref name="older" /> for <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.</summary>
            <param name="newer">The <see cref="T:NDepend.CodeModel.ICodeBase" /> object that represents the <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> in the created compare context.</param>
            <param name="older">The <see cref="T:NDepend.CodeModel.ICodeBase" /> object that represents the <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> in the created compare context.</param>
            <remarks>
            <paramref name="newer" /> can be equal to <paramref name="older" />. This possibility is convenient if you need a see <seealso cref="T:NDepend.CodeModel.ICompareContext" /> object from a <seealso cref="T:NDepend.CodeModel.ICodeBase" /> object.
            </remarks>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ExceptThirdParty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filter code elements object from this <paramref name="codeElements" /> sequence. Keeps only code elements for those <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" /> is <i>false</i>.
            </summary>
            <param name="codeElements">This sequence of code elements objects.</param>
            <returns>A sequence of code elements objects with a <i>false</i> value for <see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" />.</returns>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <remarks>
            This extension method has a <i>O(<paramref name="codeElements" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElements" /> sequence contains the same set of code elements than the <paramref name="otherCodeElements" /> sequence. Otherwise returns <i>false</i>.
            </summary>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="codeElements">This sequence of code elements objects.</param>
            <param name="otherCodeElements">The other sequence of code elements objects.</param>
            <remarks>
            Notice that both sequences can contain doublons, hence this operation first gets <i><paramref name="codeElements" />.Distinct()</i> and <i><paramref name="otherCodeElements" />.Distinct()</i>.<br />
            This extension method has a <i>O(<paramref name="codeElements" />.Count + <paramref name="otherCodeElements" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElements" /> sequence contains the same set of code elements than the <paramref name="otherCodeElementsHashset" /> hashset. Otherwise returns <i>false</i>.
            </summary>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="codeElements">This sequence of code elements objects.</param>
            <param name="otherCodeElementsHashset">The hahshet of code elements objects.</param>
            <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that <paramref name="otherCodeElementsHashset" /> is a hashset to execute with a faster <i>O(<paramref name="codeElements" />.Count)</i> time complexity.<br />
            Notice that <paramref name="codeElements" /> can contain doublons, hence this operation first gets <i><paramref name="codeElements" />.Distinct()</i>.<br />
            <paramref name="otherCodeElementsHashset" /> necessarily contains distinct code elements.<br />
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElementsHashset" /> hashset contains the same set of code elements than the <paramref name="otherCodeElementsHashset" /> hashset. Otherwise returns <i>false</i>.
            </summary>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="codeElementsHashset">This hahshet of code elements objects.</param>
            <param name="otherCodeElementsHashset">The other hahshet of code elements objects.</param>
            <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that both <paramref name="codeElementsHashset" /> and <paramref name="otherCodeElementsHashset" /> are hashsets, to execute with a faster <i>O(<paramref name="codeElementsHashset" />.Count)</i> time complexity.<br />
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElementsHashset" /> hashset contains the same set of code elements than the <paramref name="otherCodeElements" /> sequence. Otherwise returns <i>false</i>.
            </summary>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="codeElementsHashset">This hahshet of code elements objects.</param>
            <param name="otherCodeElements">The other sequence of code elements objects.</param>
            <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that both <paramref name="codeElementsHashset" /> and <paramref name="otherCodeElements" /> are hashsets, to execute with a faster <i>O(<paramref name="otherCodeElements" />.Count)</i> time complexity.<br />
            Notice that <paramref name="otherCodeElements" /> can contain doublons, hence this operation first gets <i><paramref name="otherCodeElements" />.Distinct()</i>.<br />
            <paramref name="codeElementsHashset" /> necessarily contains distinct code elements.<br />
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Iteratively fills a sequence of code elements, until no new element can be added. The first iteration starts with <paramref name="initialSeq" />, and the function <paramref name="func" /> is used to compute new elements of the iteration <i>N+1</i> from new elements computed at iteration <i>N</i>.
            </summary>
            <remarks>
            This method differs from <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIncremental``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" /> because only elements computed at iteration <i>N</i> are used to compute elements of iteration <i>N+1</i>.
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="initialSeq">The initial sequence of code elements consumed by the first iteration.</param>
            <param name="func">The function used to compute new elements of the iteration <i>N+1</i> from new elements computed at iteration <i>N</i>.</param>
            <returns>A new <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object. The code metric value for each element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is the iteration number when it was added. Value for code elements in <paramref name="initialSeq" /> is 0.</returns>
            <exception cref="T:System.InvalidOperationException">The number of iterations has outreached the maximum iterations threshold, which is fixed to 100.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="initialSeq" /> or a sequence returned by a call to <paramref name="func" /> contains a null <typeparamref name="TCodeElement" />.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIncremental``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Iteratively fills a sequence of code elements, until no new element can be added. The first iteration starts with <paramref name="initialSeq" />, and the function <paramref name="func" /> is used to compute new elements of the iteration <i>N+1</i> from all elements computed until the iteration <i>N</i>.
            </summary>
            <remarks>
            This method differs from <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" /> because all elements computed until iteration <i>N</i> are used to compute elements of iteration <i>N+1</i>.
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <param name="initialSeq">The initial sequence of code elements consumed by the first iteration.</param>
            <param name="func">The function used to compute new elements of the iteration <i>N+1</i> from all elements computed until the iteration <i>N</i>.</param>
            <returns>A new <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object. The code metric value for each element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is the iteration number when it was added. Value for code elements in <paramref name="initialSeq" /> is 0.</returns>
            <exception cref="T:System.InvalidOperationException">The number of iterations has outreached the maximum iterations threshold, which is fixed to 100.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="initialSeq" /> or a sequence returned by a call to <paramref name="func" /> contains a null <typeparamref name="TCodeElement" />.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)">
            <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.ICodeElement" /> object as input parameter, and returns a boolean that determines whether the code element's <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matches the regular expression <paramref name="regexString" />.
            </summary>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)">
            <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.IMember" /> object as input parameter, and returns a boolean that determines whether the member's <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> matches the regular expression <paramref name="regexString" />.
            </summary>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.ICodeElement,System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)">
            <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.IMethod" /> object as input parameter, and returns a boolean that determines whether the code element's <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> matches the regular expression <paramref name="regexString" />.
            </summary>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)">
            <summary>
            Try gets a number of lines of code for an application <paramref name="codeElement" />. 
            This value is guaranteed not being zero if the code element is in an assembly for which PDB file has been found and parsed.
            </summary>
            <remarks>
            The metric <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is computed from number of sequence points obtained at analysis time when parsing a PDB file.<br />
            As a consequence, if a PDB file is not found, all associated <see cref="T:NDepend.CodeModel.ICodeElement" /> objects have a <i>null</i> <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />. <br />
            <br />s
            However there are several cases where this metric is not defined for a code elements declared in an assembly with PDB file found: <br />
             - Abstract method<br />
             - Implicit constructor<br />
             - Field<br />
             - Interface<br />
             - Enumeration<br />
             - Namespace, assembly or code base that contains only interfaces and enumerations<br />
            <br />
            This method is returning a non-null, non-zero value if <paramref name="codeElement" /> satisfies the PDB found condition.<br />
             - This value is 1 for any abstract method, implicit constructor or field.<br />
             - In all other cases, <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object, and this methods returns <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> + <see cref="P:NDepend.CodeModel.ICodeElementParent.MeAndRecursiveChildren" />.<see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />. 
            <br />
            Notice that in the peculiar case where <paramref name="codeElement" />is a <see cref="T:NDepend.CodeModel.ICodeBase" />, 
            the PDB found condition means that a PDB file must have been resolved for all application assemblies at analysis time.<br />
            Notice that this method returns <i>null</i> for any third-party code element.
            </remarks>
            <param name="codeElement">The code element for which we want to obtain the number of line of code</param>
            <seealso cref="P:NDepend.CodeModel.IAssembly.PDBFound" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetImage``1(NDepend.CodeModel.ICodeElement)">
            <summary>
            Get the image that represents the <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.TryGetSourceFileContent(NDepend.CodeModel.ICodeBase,NDepend.Path.IAbsoluteFilePath,System.String@,System.String@)">
            <summary>
            Try to get the content of a source file as it was at analysis time.
            </summary>
            <remarks>
            If <seealso cref="P:NDepend.Project.IProjectProperties.ZipSourceFiles" /> is <i>true</i> (which is the default value) source files get zipped at analysis time.<br />
            This method attempts to retrieve a source file content from this zipped store.<br />
            This method is different than trying to get the content from <paramref name="sourceFilePath" />. Since the analysis has been executed the source file might have been edited or removed.
            </remarks>
            <param name="codeBase">The code base that contains the source file.</param>
            <param name="sourceFilePath">The source file absolute path obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> or from <see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.SourceFiles" />.</param>
            <param name="sourceFileContent">If this method succeeds and returns <i>true</i>, contains source file content.</param>
            <param name="failureReason">If this method fails and returns <i>false</i>, contains a plain-english description of the failure.</param>
            <returns></returns>
        </member>
        <member name="T:NDepend.CodeModel.ExtensionMethodsNaming">
            <summary>
            Provides a set of extension methods to filter a sequence of code elements by <see cref="P:NDepend.CodeModel.ICodeElement.FullName" />, <see cref="P:NDepend.CodeModel.ICodeElement.Name" />  or <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" />. 
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals <i>case sensitive</i> to <paramref name="name" /> .
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="name">The name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals <i>case sensitive</i> to <paramref name="name0" /> or <paramref name="names" />, or equals to a string contained in <paramref name="names" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="name0">One of the possible name string.</param>
            <param name="names">An array of possible name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> not equals <i>case sensitive</i> to <paramref name="name0" /> and <paramref name="names" />, and not equals to a string contained in <paramref name="names" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="name0">One of the forbidden name string.</param>
            <param name="names">An array of forbidden name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching the regular expression <paramref name="regexString" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching the wildcard pattern string <paramref name="nameWildcardPattern" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="nameWildcardPattern">The wildcard pattern string.</param>
            <remarks>
            The string <paramref name="nameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="nameWildcardPattern" /> is equal to "*", it means <i>match all.</i><br />
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching any wildcard pattern string in <paramref name="nameWildcardPattern0" /> union <paramref name="nameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="nameWildcardPattern0">The wildcard pattern string.</param>
            <param name="nameWildcardPatterns">An array of wildcard pattern strings.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="nameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching none of the wildcard pattern string in <paramref name="nameWildcardPattern0" /> union <paramref name="nameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="nameWildcardPattern0">The wildcard pattern string.</param>
            <param name="nameWildcardPatterns">An array of wildcard pattern strings.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="nameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> equals <i>case sensitive</i> to <paramref name="fullName" /> .
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullName">The code element full name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> equals <i>case sensitive</i> to <paramref name="fullName0" /> or <paramref name="fullNames" />, or equals to a string contained in <paramref name="fullNames" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullName0">One of the possible full name string.</param>
            <param name="fullNames">An array of possible full name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> not equals <i>case sensitive</i> to <paramref name="fullName0" /> and <paramref name="fullNames" />, and not equals to a string contained in <paramref name="fullNames" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullName0">One of the forbidden full name string.</param>
            <param name="fullNames">An array of forbidden full name string.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> matching the regular expression <paramref name="regexString" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.ICodeElement,System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> matching the wildcard pattern string <paramref name="fullNameWildcardPattern" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullNameWildcardPattern">The wildcard pattern string.</param>
            <remarks>
            The string <paramref name="fullNameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="fullNameWildcardPattern" /> is equal to "*", it means <i>match all.</i><br />
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> matching any wildcard pattern string in <paramref name="fullNameWildcardPattern0" /> union <paramref name="fullNameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullNameWildcardPattern0">The wildcard pattern string.</param>
            <param name="fullNameWildcardPatterns">An array of wildcard pattern strings.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullNameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> matching none of the wildcard pattern string in <paramref name="fullNameWildcardPattern0" /> union <paramref name="fullNameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of code elements objects.</param>
            <param name="fullNameWildcardPattern0">The wildcard pattern string.</param>
            <param name="fullNameWildcardPatterns">An array of wildcard pattern strings.</param>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullNameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> equals <i>case sensitive</i> to <paramref name="simpleName" /> .
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleName">The method simple name string.</param>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> equals <i>case sensitive</i> to <paramref name="simpleName0" /> or equals to a string contained in <paramref name="simpleNames" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleName0">One of the possible simple name string.</param>
            <param name="simpleNames">An array of possible simple name string.</param>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> not equals <i>case sensitive</i> to <paramref name="simpleName0" /> and <paramref name="simpleNames" />, and not equals to a string contained in <paramref name="simpleNames" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleName0">One of the possible simple name string.</param>
            <param name="simpleNames">An array of possible simple name string.</param>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> matching the regular expression <paramref name="regexString" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="regexString">The regular expression string.</param>
            <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="regexString" /> is an invalid regular exception.</exception>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> matching the wildcard pattern string <paramref name="simpleNameWildcardPattern" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleNameWildcardPattern">The wildcard pattern string.</param>
            <remarks>
            The string <paramref name="simpleNameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="simpleNameWildcardPattern" /> is equal to "*", it means <i>match all.</i><br />
            </remarks>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> matching any wildcard pattern string in <paramref name="simpleNameWildcardPattern0" /> union <paramref name="simpleNameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleNameWildcardPattern0">A wildcard pattern string.</param>
            <param name="simpleNameWildcardPatterns">An array of wildcard pattern strings.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="simpleNameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> matching none of the wildcard pattern string in <paramref name="simpleNameWildcardPattern0" /> union <paramref name="simpleNameWildcardPatterns" />.
            </summary>
            <param name="seq">This sequence of methods objects.</param>
            <param name="simpleNameWildcardPattern0">A wildcard pattern string.</param>
            <param name="simpleNameWildcardPatterns">An array of wildcard pattern strings.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="simpleNameWildcardPatterns" /> must not contain a null string.</exception>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
        </member>
        <member name="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage">
            <summary>
            Provides a set of extension methods to resolve incoming or outgoing dependencies, from or to, a sequence of code elements.
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <paramref name="codeElementUser" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementUser">The code element that uses code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <i>any</i> code element in the sequence <paramref name="codeElementsUser" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementsUser">The sequence of code elements that uses code elements in the returned sequence.</param>
            <remarks>
            Elements contained in both sequences are removed from the result, since such element is used by itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <i>all</i> code elements in the sequence <paramref name="codeElementsUser" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementsUser">The sequence of code elements that all uses code elements in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity if <typeparamref name="TUsed" /> is strictly finer-grained than <typeparamref name="TUser" />, like for example <typeparamref name="TUser" /> is <see cref="T:NDepend.CodeModel.INamespace" /> and <typeparamref name="TUsed" /> is <see cref="T:NDepend.CodeModel.IType" />. <br />
            Otherwise it has a O(<paramref name="codeElementsUser" />.Count) time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <paramref name="codeElementUser" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementUser">The code element that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in the sequence <paramref name="codeElementsUser" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementsUser">The sequence of code elements that <i>directly or indirectly</i> uses code elements in the returned sequence.</param>
            <remarks>
            Elements contained in both sequences are removed from the result, since such element is used by itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <paramref name="codeElementUser" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementUser">The code element that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
            <remarks>
            If <paramref name="codeElementUser" /> or a child or parent of <paramref name="codeElementUser" /> is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUsed" />, directly used by <paramref name="codeElementUser" /> or a child or parent of <paramref name="codeElementUser" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in <paramref name="codeElementsUser" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUsed">This sequence of code elements.</param>
            <param name="codeElementsUser">The sequence of code elements that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
            <remarks>
            If a code element in <paramref name="codeElementsUser" /> or a child or parent of a code element in <paramref name="codeElementsUser" />, is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUsed" />, directly used by a code element in <paramref name="codeElementsUser" /> or a child or parent of a code element in <paramref name="codeElementsUser" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.Using``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly using <paramref name="codeElementUsed" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementUsed">The code element that is used by code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly used by <i>any</i> code element in the sequence <paramref name="codeElementsUsed" />.
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementsUsed">The sequence of code elements that are used by <i>any</i> code elements in the returned sequence.</param>
            <remarks>
            Elements contained in both sequences are removed from the result, since such element is using itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly using <i>all</i> code elements in the sequence <paramref name="codeElementsUsed" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementsUsed">The sequence of code elements that are all used by code elements in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity if <typeparamref name="TUser" /> is strictly finer-grained than <typeparamref name="TUsed" />, like for example <typeparamref name="TUsed" /> is <see cref="T:NDepend.CodeModel.INamespace" /> and <typeparamref name="TUser" /> is <see cref="T:NDepend.CodeModel.IType" />. <br />
            Otherwise it has a O(<paramref name="codeElementsUsed" />.Count) time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <paramref name="codeElementUsed" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementUsed">The code element that is  <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in the sequence <paramref name="codeElementsUsed" /> .
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementsUsed">The sequence of code elements that are <i>directly or indirectly</i> used by <i>any</i> code elements in the returned sequence.</param>
            <remarks>
            Elements contained in both sequences are removed from the result, since such element is using itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsing``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <paramref name="codeElementUsed" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementUsed">The code element that is <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
            <remarks>
            If <paramref name="codeElementUsed" /> or a child or parent of <paramref name="codeElementUsed" /> is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUser" />, directly using <paramref name="codeElementUsed" /> or a child or parent of <paramref name="codeElementUsed" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <i>any</i> code element in <paramref name="codeElementsUsed" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
            <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
            <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
            <param name="codeElementsUser">This sequence of code elements.</param>
            <param name="codeElementsUsed">The sequence of code elements that are <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
            <remarks>
            If a code element in <paramref name="codeElementsUsed" /> or a child or parent of a code element in <paramref name="codeElementsUsed" />, is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUser" />, directly using a code element in <paramref name="codeElementsUsed" /> or a child or parent of a code element in <paramref name="codeElementsUsed" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count + <paramref name="codeElementsUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <paramref name="typeAttribute" /> .
            </summary>
            <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
            <param name="codeElementsTagged">This sequence of code elements.</param>
            <param name="typeAttribute">The type attribute that tags code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <i>any</i> attribute type in <paramref name="typesAttribute" /> .
            </summary>
            <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
            <param name="codeElementsTagged">This sequence of code elements.</param>
            <param name="typesAttribute">A sequence of types attribute that tag code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count + <paramref name="typesAttribute" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <i>all</i> attribute types in <paramref name="typesAttribute" /> .
            </summary>
            <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
            <param name="codeElementsTagged">This sequence of code elements.</param>
            <param name="typesAttribute">A sequence of types attribute that all tag code elements in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count + <paramref name="typesAttribute" />.Count)</i> time complexity.</remarks>
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <paramref name="typeBase" /> .
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typeBase">The type base of types in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.</remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <i>any</i> type in <paramref name="typesBase" /> .
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typesBase">Types base of types in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.</remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that <i>directly</i> derive from <paramref name="typeBase" /> .
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typeBase">The <i>direct</i> type base of types in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.</remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that <i>directly</i> derive from <i>any</i> type in <paramref name="typesBase" /> .
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typesBase"><i>Direct</i> types base of types in the returned sequence.</param>
            <remarks>This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.</remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <paramref name="typeBase" />. The metric value for each type in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of inheritance relative to <paramref name="typeBase" />.
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typeBase">The type base of types in the returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />.</param>
            <remarks>
            The depth of <paramref name="typeBase" /> is 0.<br />
            The depth of types that directly derive from <paramref name="typeBase" /> is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <i>any</i> type in <paramref name="typesBase" />. The metric value for each type in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of inheritance relative to <i>any</i> type in <paramref name="typesBase" />.
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="typesBase">Types base of types in the returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />.</param>
            <remarks>
            The depth of <i>any</i> type in <paramref name="typesBase" /> is 0.<br />
            The depth of types that directly derive from <i>any</i> type in <paramref name="typesBase" /> is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <paramref name="interface" />.
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="interface">The interface implemented by types in the returned sequence.</param>
            <remarks>
            If the <paramref name="interface" /> type is not an interface, the sequence returned is empty.<br />
            This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <i>any</i> interface in <paramref name="interfaces" />.
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="interfaces">The sequence of interfaces implemented by types in the returned sequence.</param>
            <remarks>
            Types in <paramref name="interfaces" /> that are not interface, are not taken account.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="interfaces" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <i>all</i> interfaces in <paramref name="interfaces" />.
            </summary>
            <param name="types">This sequence of types.</param>
            <param name="interfaces">The sequence of interfaces all implemented by all types in the returned sequence.</param>
            <remarks>
            Types in <paramref name="interfaces" /> that are not interface, are not taken account.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="interfaces" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns the field <paramref name="fieldAssigned" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="fieldAssigned">The field assigned by all methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns <i>any</i> field in <paramref name="fieldsAssigned" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="fieldsAssigned">The sequence of fields assigned by methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns <i>directly or indirectly any</i> field in <paramref name="fieldsAssigned" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="fieldsAssigned">The sequence of fields <i>directly or indirectly </i> assigned by methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> assign <paramref name="fieldAssigned" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage of the field.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="fieldAssigned">The field assigned by all methods in the returned sequence.</param>
            <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly assigning <paramref name="fieldAssigned" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a method that assigns <paramref name="fieldAssigned" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> assign <i>any</i> field in <paramref name="fieldsAssigned" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of <i>any</i> field assigned.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="fieldsAssigned">The sequence of fields assigned by methods in the returned sequence.</param>
            <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly assigning <i>any</i> field in <paramref name="fieldsAssigned" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a method that assigns <i>any</i> field in <paramref name="fieldsAssigned" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that calls a constructor of <paramref name="typeCreated" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="typeCreated">The type instantiated by all methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that calls a constructor of <i>any</i> type in <paramref name="typesCreated" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="typesCreated">The types instantiated by methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> calls a constructor of <i>any</i> type in <paramref name="typesCreated" />.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="typesCreated">The types instantiated <i>directly or indirectly</i> by methods in the returned sequence.</param>
            <remarks>
            Constructors of types in <paramref name="typesCreated" /> are not kept in the returned sequence.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> call a constructor of <paramref name="typeCreated" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of a constructor.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="typeCreated">The type <i>directly or indirectly</i> instantiated by all methods in the returned sequence.</param>
            <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are constructors of <paramref name="typeCreated" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a constructor of <paramref name="typeCreated" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> call a constructor of a type in <paramref name="typesCreated" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of a constructor.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="typesCreated">The types <i>directly or indirectly</i> instantiated by methods in the returned sequence.</param>
            <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are constructors of <i>any</i> type in <paramref name="typesCreated" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a constructor of <i>any</i> type in <paramref name="typesCreated" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that have <paramref name="returnType" /> for return type.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="returnType">The return type of all methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that have <i>any</i> type in <paramref name="returnTypes" /> for return type.
            </summary>
            <param name="methods">This sequence of methods.</param>
            <param name="returnTypes">The sequence of return types of methods in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="returnTypes" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="fields" />, containing only fields that have <paramref name="fieldType" /> for field type.
            </summary>
            <param name="fields">This sequence of fields.</param>
            <param name="fieldType">The field type of all fields in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="fields" />.Count)</i> time complexity.
            </remarks>
            <see cref="P:NDepend.CodeModel.IField.FieldType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
            <summary>
            Returns a sub-sequence of this sequence <paramref name="fields" />, containing only fields that have <i>any</i> type in <paramref name="fieldTypes" /> for field type.
            </summary>
            <param name="fields">This sequence of fields.</param>
            <param name="fieldTypes">The sequence of field types of fields in the returned sequence.</param>
            <remarks>
            This extension method has a <i>O(<paramref name="fields" />.Count + <paramref name="fieldTypes" />.Count)</i> time complexity.
            </remarks>
            <see cref="P:NDepend.CodeModel.IField.FieldType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
        </member>
        <member name="T:NDepend.CodeModel.ExtensionMethodsTooling">
            <summary>
            Provides a set of extension methods to open source code elements declarations with a text editor tool (like Visual Studio), or even compare source declarations with a diff tool.
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)">
            <summary>
            Opens the source file containing the declaration of this <see cref="T:NDepend.CodeModel.ICodeElement" />, and points to the declaration line.
            </summary>
            <remarks>
            Code elements such as <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> objects, often have multiple source declarations in the sequence <see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            In such a case, a dialog is shown to the user asking which declaration should be opened.<br />
            The source file declaration is opened in the editor tool defined through: <i>NDepend > Options panel > Source File Editor Tool</i> <br />
            This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.
            </remarks>
            <returns>
            <i>true</i> if the source declaration was opened successfully.
            </returns>
            <param name="codeElement">The code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement,System.String@)">
            <summary>
            Opens the source file containing the declaration of this <see cref="T:NDepend.CodeModel.ICodeElement" />, and points to the declaration line.
            </summary>
            <remarks>
            Code elements such as <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> objects, often have multiple source declarations in the sequence <see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            In such a case, a dialog is shown to the user asking which declaration should be opened.<br />
            The source file declaration is opened in the editor tool defined through: <i>NDepend > Options panel > Source File Editor Tool</i><br />
            This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.
            </remarks>
            <returns>
            <i>true</i> if the source declaration was opened successfully.
            </returns>
            <param name="codeElement">The code element.</param>
            <param name="failureReason">If <i>false</i> is returned, contains the plain-english description of the failure.</param>
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)">
            <summary>
            Opens with a textual files compare/diff tool, two source files declarations, this <paramref name="sourceDecl" /> and <paramref name="sourceDeclOther" />.
            </summary>
            <remarks>
            <paramref name="sourceDecl" /> and <paramref name="sourceDeclOther" /> can be obtained through <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            The textual files compare/diff tool is defined through: <i>NDepend > Options panel > Build Comparison > Sources Files Compare Tool</i><br />
            This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.
            </remarks>
            <returns>
            <i>true</i> if the two source declarations were compared successfully.
            </returns>
            <param name="sourceDecl">The first line position in a source file.</param>
            <param name="sourceDeclOther">The second line position in a source file.</param>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl,System.String@)">
            <summary>
            Opens with a textual files compare/diff tool, two source files declarations, this <paramref name="sourceDecl" /> and <paramref name="sourceDeclOther" />.
            </summary>
            <remarks>
            <paramref name="sourceDecl" /> and <paramref name="sourceDeclOther" /> can be obtained through <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            The textual files compare/diff tool is defined through: <i>NDepend > Options panel > Build Comparison > Sources Files Compare Tool</i><br />
            This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.
            </remarks>
            <returns>
            <i>true</i> if the two source declarations were compared successfully.
            </returns>
            <param name="sourceDecl">The first line position in a source file.</param>
            <param name="sourceDeclOther">The second line position in a source file.</param>
            <param name="failureReason">If <i>false</i> is returned, contains the plain-english description of the failure.</param>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryDiffSource(NDepend.CodeModel.ICodeElement,NDepend.CodeModel.ICompareContext,System.String@)" />
        </member>
        <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryDiffSource(NDepend.CodeModel.ICodeElement,NDepend.CodeModel.ICompareContext,System.String@)">
             <summary>
             Opens with a textual files compare/diff tool, the older and newer source versions of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If source files get zipped at analysis time, the older source file version is this zipped version.<br />
             The textual files compare/diff tool is defined through: <i>NDepend > Options panel > Build Comparison > Sources Files Compare Tool</i>.<br />
             If <paramref name="codeElement" /> has more than one <see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />, this method fails.
             In this situation you can use instead the method <see cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
             to compare source files older/newer versions one by one.<br />
             This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.
             </remarks>
             <param name="codeElement">The code element to open the source from</param>
             <param name="compareContext">The compare context from which we can get the older version of the <paramref name="codeElement" />.</param>
             <param name="failureReason">If <i>false</i> is returned, contains the plain-english description of the failure.</param>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="T:NDepend.CodeModel.IAssembly">
            <summary>
            Represents an application assembly, or a third-party assembly used by one or several application assemblies.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.FilePath">
            <summary>
            Gets this assembly main module file path, found during analysis.
            </summary>
            <remarks>
            The returned reference is <i>null</i> if the assembly <seealso cref="P:NDepend.CodeModel.ICodeElement.IsThirdPartyInferredFromRef" /> is <i>true</i>.
            In such case the third-party assembly hasn't been found and has been inferred from references.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.VisualStudioProjectFilePath">
            <summary>
            Gets this assembly corresponding Visual Studio project file path, if found at analysis-time, otherwise gets <i>null</i>.
            </summary>
            <remarks>
            NDepend uses an heuristic to try to infer the Visual Studio project file corresponding to this assembly.<br />
            This facility is only supported for C# project so far.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.Version">
            <summary>
            Gets the assembly version, the version specified with the System.Reflection.AssemblyVersionAttribute attribute.
            </summary>
            <remarks>
            If the version is not specified, the version "0.0.0.0" will be returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.TargetFrameworkName">
            <summary>
             Gets the target framework name (TFM) of the assembly.
            </summary>
            <remarks>
             Returns a string such as 'net5.0', 'net5.0-windows', 'netcoreapp3.1', 'netstandard2.0', 'net462', 'net4x'.<br />
             Related documentation: https://github.com/dotnet/designs/blob/main/accepted/2020/net5/net5.md <br />
             The string "Not available" is returned for third-party assemblies. This is because the NDepend third-party assemblies resolution logic can differ in some situations from the CLR resolution logic and the value returned could be wrong.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.TargetPlatform">
            <summary>
             Gets the target platform of the assembly (Any CPU, x86, x64...).
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.CompanyName">
            <summary>
            Get the string value of the attribute <i>System.Reflection.AssemblyCompanyAttribute</i>, or empty string if this assembly hasn't such attribute.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.PublicKeyToken">
            <summary>
            Get the hexadecimal upper string value of the <i>PublicKeyToken</i>, or empty string if this assembly is not signed.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.ContainsNamespaceDependencyCycle">
            <summary>
            Gets a value indicating whether this application assembly contains a dependency cycle between its <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />. Gets <i>null</i> if this assembly is a third-party assembly.
            </summary>
            <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.AssembliesUsed">
            <summary>
            Gets a sequence of assemblies that this assembly is using. If this assembly is a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.AssembliesUsed" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.AssembliesUsingMe">
            <summary>
            Gets a sequence of assemblies that are using this assembly.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.AssembliesUsingMe" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.PDBFound">
            <summary>Gets a boolean value that indicates if the PDB file for this assembly has been found at analysis time.</summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.NbTypes">
            <summary>
            Gets the number of types declared in this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.NbNamespaces">
            <summary>
            Gets the number of namespaces declared in this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.Abstractness">
            <summary>
            Gets a float numeric nullable value in the range [0,1] assessing the ratio of the number of internal abstract types (i.e abstract classes and interfaces) to the number of internal types.
            </summary>
            <remarks>
            <i>Abstractness</i>=0 indicates a completely concrete assembly and <i>Abstractness</i>=1 indicates a completely abstract assembly.<br />
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br /><br /><i><u>Availability:</u></i><br />
            A null numeric value is returned for any third-party assembly.
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.Instability">
            <summary>
            Gets a float numeric nullable value in the range [0,1] assessing an value of the assembly's resilience to change..
            </summary>
            <remarks>
            The <i>Instability</i> value for an assembly is equal to the ratio of the incoming coupling (<see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" />) to the total coupling (<see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" /> + <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsed" />).<br />
            This metric is an indicator of the assembly's resilience to change.<br />
            The range for this metric is 0 to 1, with <i>Instability</i>=0 indicating a completely stable package and <i>Instability</i>=1 indicating a completely instable package.<br />
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br />
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.DistFromMainSeq">
            <summary>
            Gets a float numeric nullable value equals to <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> / Sqrt(2), assessing the balance between <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> and <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> for this assembly. A returned value close to 0 indicates an ideal balance.
            </summary>
            <remarks>
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br />
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.DistFromMainSeq" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq">
            <summary>
            Gets a float numeric nullable value in the range [0,1] assessing the balance between <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> and <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> for this assembly. A returned value close to 0 indicates an ideal balance.
            </summary>
            <remarks>
            <i><u>Abstractness versus Instability Metrics:</u></i><br />
            By measuring coupling between types of your application, NDepend assesses the stability of each assembly.<br />
            An assembly is considered stable if its child types are used by a lot of types of others application assemblies (i.e stable = painful to modify).<br />
            If an assembly contains many abstract types (i.e interfaces and abstract classes) and few concrete types, it is considered as abstract.<br />
            Thus, <b>NDepend helps you detect which assemblies are potentially painful to maintain (i.e concrete and stable) and which assemblies are potentially useless (i.e abstract and instable).</b><br /><i>This theory and metrics have been first introduced by the excellent book <a href="http://www.amazon.com/Principles-Patterns-Practices-Robert-Martin/dp/0131857258/" target="_blank">Agile Software Development: Principles, Patterns, and Practices in C#, Robert C. Martin (Prentice Hall PTR, 2006)</a>.</i><br /><br /><i><u>Distance from main Sequence definition:</u></i><br />
            It represents the perpendicular normalized distance of an assembly from the idealized line <i>A</i> + <i>I</i> = 1. <i>A</i> stands for <i>Abstractness</i> and <i>I</i> for <i>Instability</i>. This line is called main sequence.<br />
            This metric is an indicator of the assembly's balance between abstractness and instability. An assembly squarely on the main sequence is optimally balanced with respect to its abstractness and stability.<br />
            Ideal assemblies are either completely abstract and stable (<i>I</i>=0, <i>A</i>=1) or completely concrete and instable (<i>I</i>=1, <i>A</i>=0).<br />
            The range for this <i>NormDistFromMainSeq</i> metric is 0 to 1, with <i>D</i>=0 indicating an assembly that is coincident with the main sequence and <i>D</i>=1 indicating an assembly that is as far from the main sequence as possible.<br />
            A picture provided within the NDepend report reveals if an assembly is in the zone of pain (<i>I</i> and <i>A</i> both close to 0) or in the zone of uselessness (<i>I</i> and <i>A</i> both close to 1).<br /><br /><i><u>Recommendations:</u></i><br />
            Assemblies where <i>NormDistFromMainSeq</i> is higher than 0.7 might be problematic. However, in the real world it is very hard to avoid such assemblies.<br />
            Therefore, you should allow just a few of your application assemblies to violate this 0.7 threshold.<br />
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.RelationalCohesion">
            <summary>
            Gets a float numeric nullable value assessing this assembly child types average cohesion.
            </summary>
            <remarks>
            Let <i>R</i> be the number of types relationships that are internal to this assembly (i.e that do not connect to types outside the assembly).<br />
            Let <i>N</i> be the number of types within the assembly.<br /><i>H</i> = (<i>R</i> + 1)/ <i>N</i>. The extra 1 in the formula prevents <i>H</i>=0 when <i>N</i>=1.<br />
            The relational cohesion represents the relationship that this assembly has to all its types.<br /><br /><i><u>Recommendations:</u></i><br />
            As classes inside an assembly should be strongly related, the cohesion should be high. On the other hand, too high values may indicate over-coupling.<br />
            A good range for <i>RelationalCohesion</i> is 1.5 to 4.0.<br />
            Hence, assemblies where <i>RelationalCohesion</i> &lt; 1.5 or <i>RelationalCohesion</i> &gt; 4.0 might be problematic.<br />
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe">
            <summary>
            Gets a numeric nullable value counting types outside this assembly using a child type of this assembly.
            </summary>
            <remarks>
            More information concerning the usefulness of this code metric is available in the descripions of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> and <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> code metrics.<br />
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IAssembly.NbTypesUsed">
            <summary>
            Gets a numeric nullable value counting types outside this assembly used by child types of this assembly. Third-party types are taken account in this cout.
            </summary>
            <remarks>
            More information concerning the usefulness of this code metric is available in the descripions of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> and <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> code metrics.<br />s
            </remarks>
            <returns>
            <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsed" /> numeric value.<br />
            </returns>
        </member>
        <member name="T:NDepend.CodeModel.IAttributeTarget">
            <summary>
            Represents a code element that can be tagged by an attribute. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)">
            <summary>
            Returns true if this code element is tagged by <paramref name="attributeClass" />.
            </summary>
            <param name="attributeClass">The attribute class that potentially tags this code element.</param>
            <seealso cref="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IAttributeTarget.AttributeClassesThatTagMe">
             <summary>
             Returns a sequence of attribute classes that tag this code element.
             </summary>
            <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
        </member>
        <member name="T:NDepend.CodeModel.ICodeBase">
            <summary>
            Represents a code base snapshot, produced by a NDepend analysis. A <see cref="T:NDepend.CodeModel.ICodeBase" /> object can be obtained from the <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.CodeBase" /> property.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBase.Application">
            <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object restrained only to application assemblies and code elements declared in application assemblies.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBase.ThirdParty">
            <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object restrained only to third-party assemblies and code elements declared in third-party assemblies and used by application assemblies.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBase.AnalysisResultFilePath">
            <summary>
            Get the file path of the analysis result that contains this code base.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBase.SourceFiles">
            <summary>
            Get the list of source files of the application.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ICodeBaseView">
            <summary>
            Represents a total or restrained view of a <see cref="T:NDepend.CodeModel.ICodeBase" /> object.
            </summary>
            <remarks>
            Apart the <see cref="T:NDepend.CodeModel.ICodeBase" /> interface that implements <see cref="T:NDepend.CodeModel.ICodeBaseView" />, three code base views are available per default:<br />
            <ul>
            <li><see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" />, available in CQLinq through the predefined field <i>Application</i>.</li>
            <li><see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.ThirdParty" />, available in CQLinq through the predefined field <i>ThirdParty</i>.</li>
            <li><see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeQueries" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />, available in CQLinq through the predefined field <i>JustMyCode</i>.
            The <i>JustMyCode</i> code base view represents code elements that are not matched by any queries prefixed with the CQLinq keyword <i>notmycode</i> (<see cref="T:NDepend.CodeQuery.KindOfCodeQueryExpression" />.<see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode" />).</li>
            </ul>
            A custom <see cref="T:NDepend.CodeModel.ICodeBaseView" /> can be created through the method <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="M:NDepend.CodeModel.ICodeBaseView.CreateSubView(System.Predicate{NDepend.CodeModel.ICodeElement})" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.CodeBase">
            <summary>
            Gets the original <see cref="T:NDepend.CodeModel.ICodeBase" /> object from which this <see cref="T:NDepend.CodeModel.ICodeBaseView" /> is inferred from.
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ICodeBaseView.Contains(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value indicating whether <paramref name="codeElement" /> is part of this code base view.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.ICodeBaseView.CreateSubView(System.Predicate{NDepend.CodeModel.ICodeElement})">
            <summary>
            Creates a sub-view object, containing only this view code elements for which <paramref name="predicate" /> returns true;
            </summary>
            <remarks>Internally this method is used to create <i>codeBase.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /></i> and <i>codeBase.<see cref="P:NDepend.CodeModel.ICodeBase.ThirdParty" /></i> views.</remarks>
            <param name="predicate">The predicate that elements in returned sub-view must satisfy.</param>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Assemblies">
            <summary>
            Gets the sequence of assemblies within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Namespaces">
            <summary>
            Gets the sequence of namespaces within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Types">
            <summary>
            Gets the sequence of types within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Methods">
            <summary>
            Gets the sequence of methods within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Fields">
            <summary>
            Gets the sequence of fields within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.CodeElements">
            <summary>
            Gets the sequence of all code elements (assemblies, namespace, types, methods, fields) within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.CodeElementParents">
            <summary>
            Gets the sequence of assemblies, namespace and types within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.CodeContainers">
            <summary>
            Gets the sequence of all code elements that contains executable code (assemblies, namespace, types, methods) within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.Members">
            <summary>
            Gets the sequence of methods and fields within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.TypesAndMembers">
            <summary>
            Gets the sequence of types, methods and fields within this code base view.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeBaseView.AttributeTargets">
            <summary>
            Gets the sequence of assemblies, types, methods and fields within this code base view.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ICodeContainer">
            <summary>
            Represents a code element that can contain executable code. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IAssembly" /> and <see cref="T:NDepend.CodeModel.ICodeBase" />.
            </summary>
            <remarks>
            This interface implements <see cref="T:NDepend.CodeModel.IUser" /> because <see cref="T:NDepend.CodeModel.ICodeContainer" /> contains executable code per definition, and executable code can used code elements.<br />
            A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object doesn't necessarily contain executable code. For example an abstract method object, is a <see cref="T:NDepend.CodeModel.IMethod" />, that is a <see cref="T:NDepend.CodeModel.ICodeContainer" />, yet an abstract method doesn't contain executable code.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.NbILInstructions">
            <summary>
            Gets a numeric nullable value counting the number of IL instructions for this code element.
            </summary>
            <remarks>
            The number of IL instructions can vary depending if an application assembly is compiled in <i>debug</i> or in <i>release</i> mode.<br /> 
            Indeed compiler's optimizations can modify the number of IL instructions.<br /> 
            For example a compiler can add some <i>nop</i> IL instructions in <i>debug</i> mode, to handle <i>Edit and Continue</i>, or to allow attaching an IL instruction to a curly brace.
            </remarks>
            <returns>
            <i>null</i> if this code element is defined in a third-party assembly.<br />
            <i>null</i> if this code element is an interface, an enumeration or an abstract method.<br />
            Otherwise returns the number of IL instructions for this code element.
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode">
            <summary>
            Gets a numeric nullable value counting the number of <i>logical</i> lines of code for this code element.
            </summary>
            <remarks>
            This metric (known as <i>LoC</i>) can be computed only if PDB files are present.<br /> 
            NDepend computes this metric directly from the information provided in PDB files.<br /> 
            The <i>LoC</i> for a method is equal to the number of sequence points found for this method in the PDB file.<br />
            A sequence point is used to mark a spot in the IL code that corresponds to a specific location in the original source.<br />
            More info about sequence points can be found <a href="http://blogs.msdn.com/b/rmbyers/archive/2005/09/08/462676.aspx" target="_blank">here</a><br />
            Notice that sequence points which correspond to C# braces‘{‘ and ‘}’ are not taken account.<br />
            Computing the number of lines of code from PDB’s sequence points allows to obtain a logical <i>LoC</i> of code instead of a physical <i>LoC</i> (i.e directly computed from source files).<br />
            Two significant advantages of logical  <i>LoC</i> over physical <i>LoC</i> are:
            <ul>
            <li>Coding style doesn’t interfere with logical <i>LoC</i>. For example the <i>LoC</i> won’t change because a method call is spawn on several lines because of a high number of arguments.</li>
            <li>Logical <i>LoC</i> is independent from the programming language. Values obtained from assemblies written with different languages are comparable and can be summed.</li>
            </ul>
            Notice that the <i>LoC</i> for a type is the sum of its methods’ <i>LoC</i>, the <i>LoC</i> for a namespace is the sum of its types’ <i>LoC</i>, the <i>LoC</i> for an assembly is the sum of its namespaces’ <i>LoC</i> and the <i>LoC</i> for a code base is the sum of its application assemblies <i>LoC</i>.<br />
            Here are some observations:
            <ul>
            <li>Interfaces, abstract methods and enumerations have a <i>NbLinesOfCode</i> value equals to <i>null</i>. Only concrete code that is effectively executed is considered when computing <i>LoC</i>.</li>
            <li>Namespaces, types, fields and methods declarations are not considered as line of code because they don’t have corresponding sequence points.</li>
            <li>When the C# or VB.NET compiler faces an inline instance fields initialization, it generates a sequence point for each of the instance constructor (the same remark applies for inline static fields initialization and static constructor).</li>
            <li><i>LoC</i> computed from an anonymous method doesn’t interfere with the <i>LoC</i> of its outer declaring methods.</li>
            <li>The overall ratio between <see cref="P:NDepend.CodeModel.ICodeContainer.NbILInstructions" /> and <i>LoC</i> (in C# and VB.NET) is usually around 7.</li>
            </ul>
            <i><u>Recommendations:</u></i><br /> 
            Methods where <i>NbLinesOfCode</i> is higher than 20 are hard to understand and maintain.<br /> 
            Methods where <i>NbLinesOfCode</i> is higher than 40 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).
            </remarks>
            <returns>
            <i>null</i> if this code element is defined in a third-party assembly.<br />
            <i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            <i>null</i> if this code element is an interface, an enumeration, an abstract method or a default constructor.<br />
            Otherwise returns the number of <i>logical</i> lines of code for this code element.
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment">
            <summary>
            Gets a numeric nullable value counting the number of lines of comments contained in the body of this code element.
            </summary>
            <remarks>
            This metric can be computed only if assemblies PDB files are found at analysis-time and if corresponding source files can be found.<br /> 
            So far this metric is only computed for C# code and a VB.NET version will be released in the future.<br />
            The number of lines of comment is computed as follow:<br />
            <ul>
            <li>For a method, this metric value is the number of lines of comment that can be found in its body. In C# the body of a method begins with a '{' and ends with a '}'. If a method contains an anonymous method, lines of comment defined in the anonymous method are not counted for the outer method but are counted for the anonymous method.</li>
            <li>For a type, this metric value is the sum of the number of lines of comment that can be found in each of its partial definition. In C#, each partial definition of a type begins with a '{ and ends with a '}'.</li>
            <li>For a namespace, this metric value is the sum of the number of lines of comment that can be found in each of its partial definition. In C# each partial definition of a namespace begins with a '{ and ends with a '}'.</li>
            <li>For an assembly, this metric value is the sum of the number of lines of comment that can be found in each of its source file.</li>
            </ul>
            Notice that this metric is not an additive metric (i.e for example, the number of lines of comment of a namespace can be greater than the number of lines of comment over all its types).<br />
            <i><u>Recommendations:</u></i><br />  
            This metric is not helpful to assess the quality of source code from a commenting perspective. Prefer using the metric <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageComment" />. 
            </remarks>
            <returns>
            <i>null</i> if this code element is defined in a third-party assembly.<br />
            <i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            <i>null</i> if the source code file path referenced from the PDB file cannot be found.<br />
            <i>null</i> if the source code of this code element is written with a programming language different than C#.<br />
            Otherwise returns the number of comments for this code element.
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.PercentageComment">
            <summary>
            Gets a numeric float nullable value in the range [0,100] assessing the percentage of comments for this code element.
            </summary>
            <remarks>
            This metric value is computed with the following formula: <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageComment" /> = 100*<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" />  / ( <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" />  + <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />).<br />
            <br />
            <i><u>Recommendations:</u></i><br />
            Code where the percentage of comment is lower than 20% might need to be more commented. However overly commented code (more than 40%) is not necessarily a blessing as it can be considered as an insult to the intelligence of the reader.<br />
            Guidelines about code commenting can be found <a href="http://www.icsharpcode.net/TechNotes/Commenting20020413.pdf" target="_blank">here</a>. 
            </remarks>
            <returns>
            <i>null</i> if this code element is defined in a third-party assembly.<br />
            <i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            <i>null</i> if the source code file path referenced from the PDB file cannot be found.<br />
            <i>null</i> if the source code of this code element is written with a programming language different than C#.<br />
            Otherwise returns the comments percentage for this code element.
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable">
             <summary>
             Gets a boolean value that indicates if coverage data is available for this code element.
             </summary>
            <returns>
            <li><i>false</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.</li>
            <li><i>false</i> if this code element is defined in a third-party assembly.</li>
            <li><i>false</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.</li>
            <li><i>false</i> if the code element is tagged with an attribute that excludes elements from coverage statistics.</li>
            <li><i>false</i> if the code element does not contain any PDB sequence point.</li>
            else returns <i>true</i>.<br />
            This property returned boolean flag is the inverse value of <see cref="P:NDepend.CodeModel.ICodeContainer.IsExcludedFromCoverage" />.
            </returns>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.IsExcludedFromCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.ExcludedFromCoverageStatistics" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage">
            <summary>
            Gets a numeric float nullable value in the range [0f,100f] assessing the percentage of comments for this code element.
            </summary>
            <remarks>
            <i><u>Recommendations:</u></i><br /> 
            The closer to 100%, the better!
            </remarks>
            <returns>
            <li><i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.</li>
            <li><i>null</i> if this code element is defined in a third-party assembly.</li>
            <li><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.</li>
            <li><i>null</i> if the code element is tagged with the attribute defined in <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />.</li>
            <li><i>null</i> if the code element does not contain any PDB sequence point.</li>
            <li><i>0</i> if the code element <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is 0 and the code element contains at least one PDB sequence point (opening/closing braces have sequence points but don't count as lines of code).</li>
            <li>Otherwise returns the code coverage by tests percentage for this code element computed as <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> / (<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> + <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />).</li>
            Notice that if a code element parent (assembly/namespace/type) contains some child code elements tagged with <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />
            the lines of code of these child code elements are not counted neither in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> nor in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />.<br />
            As a consequence (<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> + <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />) can be lower than <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />.<br />
            As a consequence a code element can have 100% code coverage, even if <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> is lower than <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />,
            as long as <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" /> value is 0.
            </returns>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered">
            <summary>
            Gets a numeric nullable value in the range [0,this.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />] counting the number of lines of code of this code element, covered by tests.
            </summary>
            <returns>
            <li><i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.</li>
            <li><i>null</i> if this code element is defined in a third-party assembly.</li>
            <li><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.</li>
            <li><i>null</i> if the code element is tagged with the attribute defined in <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />.</li>
            <li><i>null</i> if the code element does not contain any PDB sequence point.</li>
            <li><i>0</i> if the code element <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is 0 and the code element contains at least one PDB sequence point (opening/closing braces have sequence points but don't count as lines of code).</li>
            <li>Otherwise returns the number of lines of code covered by tests for this code element.</li>
            Notice that if a code element parent (assembly/namespace/type) contains some child code elements tagged with <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />
            the lines of code of these child code elements are not counted neither in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> nor in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />.
            </returns>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered">
            <summary>
            Gets a numeric nullable value in the range [0,this.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />] counting the number of lines of code of this code element, <b>not</b> covered by tests.
            </summary>
            <returns>
            <li><i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.</li>
            <li><i>null</i> if this code element is defined in a third-party assembly.</li>
            <li><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.</li>
            <li><i>null</i> if the code element is tagged with the attribute defined in <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />.</li>
            <li><i>null</i> if the code element does not contain any PDB sequence point.</li>
            <li><i>0</i> if the code element <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is 0 and the code element contains at least one PDB sequence point (opening/closing braces have sequence points but don't count as lines of code).</li>
            <li>Otherwise returns the number of lines of code <b>not</b> covered by tests for this code element.</li>
            Notice that if a code element parent (assembly/namespace/type) contains some child code elements tagged with <see cref="T:NDepend.Project.IProjectCoverage" />.<see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />
            the lines of code of these child code elements are not counted neither in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" /> nor in <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />.
            </returns>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.IsExcludedFromCoverage">
            <summary>Gets a value indicating whether this assembly, namespace, type or method don’t have associated coverage data.</summary>
            <remarks>
            This property returns: 
            <li><i>true</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.</li>
            <li><i>true</i> if this code element is defined in a third-party assembly.</li>
            <li><i>true</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.</li>
            <li><i>true</i> if the code element is tagged with an attribute that excludes elements from coverage statistics.</li>
            <li><i>true</i> if the code element does not contain any PDB sequence point.</li>
            else returns <i>false</i>.<br />
            This property returned boolean flag is the inverse value of <see cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />.<br />
            Unlike the property <seealso cref="P:NDepend.CodeModel.ICodeContainer.ExcludedFromCoverageStatistics" />, this property also returns <i>true</i> for code elements whose coverage data is not available in coverage files provided - but that are not explicitly excluded from coverage.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.ExcludedFromCoverageStatistics" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeContainer.ExcludedFromCoverageStatistics">
            <summary>Gets a value indicating whether this assembly, namespace, type or method is explicitly excluded from coverage.</summary>
            <remarks>
             This property returns <i>true</i> for code elements matched by the &lt;CodeCoverage&gt; exclusion section within the <i>.runsettings</i> file provided (if any).<br />
             No matter the coverage technology used, methods and types tagged with 'System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute' are excluded from coverage statistics.<br />
             For the VS coverage technology, tagging a method or a type with 'System.Diagnostics.DebuggerNonUserCodeAttribute' or 'System.Diagnostics.DebuggerHiddenAttribute' exclude it also from coverage statistics.<br />
             You can also specify a custom attribute to excluded elements from coverage statistics in the Project Propeties &gt; Analysis &gt; Coverage &gt; Settings form.<br />
             Unlike the property <seealso cref="P:NDepend.CodeModel.ICodeContainer.IsExcludedFromCoverage" />, this property returns <i>false</i> for code elements whose coverage data is not available in coverage files provided - but that are not explicitly excluded from coverage.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.IsExcludedFromCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
        </member>
        <member name="T:NDepend.CodeModel.ICodeElement">
            <summary>
            Represents a code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.UniqueID">
            <summary>
            Gets an integer identifier for this code element, unique in the scope of this <see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.
            </summary>
            <remarks>
            This code element's unique identifier might be useful in situations where a unique hash code per code element, unique in the scope of this <see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />, is needed.
            </remarks> 
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.Name">
            <summary>Gets a string representing the name of this code element.</summary>
            <remarks>
            <ul>
            <li>In case of a code base, the name is equal to the <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.Name" />.</li>
            <li>In case of a type the name is <i>TypeName&lt;T&gt;</i> not prefixed with the parent namespace name.</li>
            <li>In case of a nested type the name is <i>OutterTypeName+TypeName&lt;T&gt;</i> prefixed with the parent type name but not prefixed with the parent namespace name.</li>
            <li>In case of a method the name is <i>MethodName&lt;T&gt;(parameters types)</i> not prefixed with the parent namespace name or parent type name.</li>
            <li>In case of a field the name is <i>FieldName</i> not prefixed with the parent namespace name or parent type name.</li>
            <li>In case of a namespace the name is simply the  namespace name like <i>N1.N2.N3</i>.</li>
            <li>The anonymous namespace of an assembly has a <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals to the empty string.</li>
            <li>In case of an assembly the name is the assembly main module file name, without file extension.</li>
            </ul>
            This property getter has a constant time complexity.<br />
            </remarks>
            <returns>The name of this code element.</returns>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.FullName">
            <summary>Gets a string representing the full name of this code element.</summary>
            <remarks>
            <ul>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IType" />, the full name is <i>NamespaceName.TypeName&lt;T&gt;</i>.</li>
            <li>If this code element is a nested <see cref="T:NDepend.CodeModel.IType" />, the full name is <i>NamespaceName.OutterTypeName+TypeName&lt;T&gt;</i>.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IMethod" />, the full name is <i>NamespaceName.TypeName.Method&lt;T&gt;(parameters types)</i>.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IField" />, the full name is <i>NamespaceName.TypeName.FieldName</i>.</li>
            <li>If the parent namespace is the anonymous namespace, the full name begins directly with <i>TypeName...</i>.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.INamespace" /> or an <see cref="T:NDepend.CodeModel.IAssembly" /> returns <i>this</i>.<see cref="P:NDepend.CodeModel.ICodeElement.Name" />.</li>
            </ul>
            This property getter has a constant time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="P:NDepend.CodeModel.ICodeElement.SimpleName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.SimpleName">
            <summary>
            Gets this code element simple name, without its eventual parameters signature nor its eventual generic signature not prefixed by its parent type or namespace name.
            </summary>
            <remarks>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IType" />, the simple name is is the type name without the parent namespace name nor the generic arity.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IMethod" />, the simple name is is the method name without the parent type name nor the parameters.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.INamespace" />, the simple name is is the namespace name without the parent namespaces names.</li>
            <li>If this code element is a <see cref="T:NDepend.CodeModel.IField" /> or an <see cref="T:NDepend.CodeModel.IAssembly" /> returns <i>this</i>.<see cref="P:NDepend.CodeModel.ICodeElement.Name" />.</li>
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="P:NDepend.CodeModel.IMethod.Overloads" />
            <seealso cref="P:NDepend.CodeModel.IMethod.IsOverloaded" />
            <seealso cref="P:NDepend.CodeModel.IMethod.NbOverloads" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.ParentCodeBase">
            <summary>Gets the parent code base of this code element</summary>
            <remarks>
            If <i>this</i> is a code base, return <i>this</i>.
            </remarks>
            <returns>The parent code base of this code element.</returns>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.Parent">
            <summary>
            Returns the code element parent of this code element. 
            </summary>
            <remarks>
            If this is a code base, returns <i>this</i>.<br />
            If this is an assembly, returns this <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.<br />
            If this is a namespace, returns <see cref="T:NDepend.CodeModel.INamespace" />.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<br />
            If this is a type, returns <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentNamespace" />.<br />
            If this is a type nested in one or several other types returns also <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentNamespace" />.<br />
            If this is a member (method or field), returns <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<br /> 
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.Parents">
            <summary>
            Returns a sequence of code element parent of this code element. 
            </summary>
            <remarks>
            If this is a code base, the returned sequence is empty.<br />
            If this is an assembly, the returned sequence contains only the <see cref="T:NDepend.CodeModel.IAssembly" />.<see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.<br />
            If this is a namespace, the returned sequence contains <see cref="T:NDepend.CodeModel.INamespace" />.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" /> and then <see cref="T:NDepend.CodeModel.INamespace" />.<see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.<br />
            If this is a type, the returned sequence contains first <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and then <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.<br />
            If this is a type nested in one or several other types, the returned sequence doesn't contain the parent type(s).<br />
            If this is a member (method or field), the returned sequence contains first <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentType" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> and <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> and then <see cref="T:NDepend.CodeModel.IMember" />.<see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.<br /> 
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsThirdParty">
            <summary>Gets a value indicating whether this code element is an application or a third-party code element.</summary>
            <remarks>This property getter has a constant time complexity.</remarks>
            <returns>true if this code element is declared in a third-party assembly, or is itself a third-party assembly.</returns>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ExceptThirdParty``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsThirdPartyInferredFromRef">
            <summary>Gets a value indicating whether this code element is a third-party code element resolved from reference.</summary>
            <remarks>Since NDepend v2021.2 when a third-party assembly is not found at analysis time, such assembly and its child namespaces, types, methods and fields are resolved from their references in application assemblies.</remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable">
            <summary>Gets a value indicating whether source file declaration(s) of this code element have been gathered at analysis time and is now available.</summary>
            <remarks>
            So far only C# code is parsed and also, source file declarations for abstract methods and fields are not retreived.
            This situation will evolve in the future.
            </remarks>
            <returns>
            <b>true</b> if source file declaration(s) are available for this code element.
            </returns>
            <seealso cref="T:NDepend.Project.IProjectSourceFilesRebasing" />
            <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.SourceDecls">
            <summary>
            Returns one or several source file declarations of this code element.
            Returns an empty sequence if not SourceFileDeclAvailable.
            </summary>
            <remarks>
            Assemblies, namespaces and types can have several source file declarations.
            Methods and fields can have at most one source file declaration.
            </remarks>
            <seealso cref="T:NDepend.Project.IProjectSourceFilesRebasing" />
            <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsCodeBase">
            <summary>Gets a value indicating whether this code element is a code base, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.ICodeBase" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsAssembly">
            <summary>Gets a value indicating whether this code element is an assembly, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IAssembly" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsNamespace">
            <summary>Gets a value indicating whether this code element is a namespace, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.INamespace" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsMethod">
            <summary>Gets a value indicating whether this code element is a method, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IMethod" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsType">
            <summary>Gets a value indicating whether this code element is a type, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IType" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsField">
            <summary>Gets a value indicating whether this code element is a field, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IField" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsMember">
            <summary>Gets a value indicating whether this code element is a method or field, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IMember" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsTypeOrMember">
            <summary>Gets a value indicating whether this code element is a type, method or field, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IMember" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsCodeElementParent">
            <summary>Gets a value indicating whether this code element is an assembly, a namespace or a type, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.ICodeElementParent" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsCodeContainer">
            <summary>Gets a value indicating whether this code element is an assembly, a namespace a type or a method, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.ICodeContainer" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.IsAttributeTarget">
            <summary>Gets a value indicating whether this code element is an assembly, a type, a method or a field, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IAttributeTarget" />.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsCodeBase">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.ICodeBase" /> if it is a code base, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsAssembly">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IAssembly" /> if it is an assembly, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsNamespace">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.INamespace" /> if it is a namespace, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsType">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IType" /> if it is a type, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsMethod">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IMethod" /> if it is a method, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsField">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IField" /> if it is a field, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsMember">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IMember" /> if it is a method or field, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsTypeOrMember">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IMember" /> if it is a type, method or field, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsCodeElementParent">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.ICodeElementParent" /> if it is an assembly, a namespace or a type, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsCodeContainer">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.ICodeContainer" /> if it is a an assembly, a namespace, a type or a method, else gets <i>null</i>.</summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElement.AsAttributeTarget">
            <summary>Gets this code element casted to <see cref="T:NDepend.CodeModel.IAttributeTarget" /> if it is a an assembly, a type, a method or a field, else gets <i>null</i>.</summary>
        </member>
        <member name="T:NDepend.CodeModel.ICodeElementParent">
            <summary>
            Represents a parent code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.DirectChildren">
            <summary>
            Returns a sequence of direct children code elements. 
            </summary>
            <remarks>
            If <i>this</i> code element is an assembly, a sequence of child namespaces will be returned. <br />
            If <i>this</i> code element is a namespace, a sequence of child types will be returned. <br />
            If <i>this</i> code element is a type, a sequence of child methods and fields will be returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.MeAndDirectChildren">
            <summary>
            Returns a sequence of <i>this</i> code element followed by its direct children code elements. 
            </summary>
            <remarks>
            If <i>this</i> code element is an assembly, a sequence starting with <i>this</i> assembly followed by its child namespaces will be returned. <br />
            If <i>this</i> code element is a namespace, a sequence starting with <i>this</i> namespace followed by its child types will be returned. <br />
            If <i>this</i> code element is a type, a sequence starting with <i>this</i> type followed by its child methods and fields will be returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren">
            <summary>
            Returns a sequence of all children code elements. 
            </summary>
            <remarks>
            If <i>this</i> code element is an assembly, a sequence of child namespaces, types, methods and fields will be returned. <br />
            If <i>this</i> code element is a namespace, a sequence of child types, methods and fields will be returned. <br />
            If <i>this</i> code element is a type, a sequence of child methods and fields will be returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.MeAndRecursiveChildren">
            <summary>
            Return a sequence of <i>this</i> code element followed by all its children code elements. 
            </summary>
            <remarks>
            If <i>this</i> code element is an assembly, a sequence starting with <i>this</i> assembly followed by its child namespaces, types, methods and fields will be returned. <br />
            If <i>this</i> code element is a namespace, a sequence starting with <i>this</i> namespace followed by its child types, methods and fields will be returned. <br />
            If <i>this</i> code element is a type, a sequence starting with <i>this</i> type followed by its child methods and fields will be returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces">
            <summary>
            Gets a sequence of namespaces declared in this scope. If this code element is declared in (or is) a third-party assembly, gets only methods used by the application.
            </summary>
            <remarks>
            If this is an assembly:<br />
             - Gets a sequence of namespaces declared in this application assembly. For a third-party assembly, gets only namespaces used by the application.<br />
             - Notice that if <i>N</i> assemblies declare the same namespace, there are <i>N</i> <see cref="T:NDepend.CodeModel.INamespace" /> objects with a common <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> value, one object for each assembly that declares the namespace.<br />
            If this is a namespace:<br />
             - The anonymous namespace doesn't have any child namespace.<br />
             - See: <see cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />, <see cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />, <see cref="P:NDepend.CodeModel.INamespace.ParentNamespace" /><br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />.Count)</i> time complexity.<br />
            If this is a type returns an empty sequence.<br />
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.Namespaces" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildTypes">
            <summary>
            Gets a sequence of types declared in this scope. If this code element is declared in (or is) a third-party assembly, gets only methods used by the application.
            </summary>
            <remarks>
            The result includes classes, structures, interfaces, enumerations and delegates classes.<br />
            If this is a type, returns <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.NestedTypes" />.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" />.Count)</i> time complexity.<br />
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.Types" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildTypesAndMembers">
            <summary>
            Gets a sequence of types, methods and fields declared in this scope. If this code element is declared in (or is) a third-party assembly, gets only types, methods and fields used by the application.
            </summary>
            <remarks>
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.TypesAndMembers" />.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" /> 
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> 
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> 
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildMembers">
            <summary>
            Gets a sequence of methods and fields declared in this scope. If this code element is declared in (or is) a third-party assembly, gets only methods and fields used by the application.
            </summary>
            <remarks>
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.Members" />.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" /> 
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" /> 
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildMethods">
            <summary>
            Gets a sequence of methods declared in this namespace. If this code element is declared in (or is) a third-party assembly, gets only methods used by the application.
            </summary>
            <remarks>
            The result includes methods, constructors, class constructors, property getter and setters, event adders and removers.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildMethods" />.Count)</i> time complexity.<br />
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.Methods" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.ChildFields">
            <summary>
            Gets a sequence of fields declared in this namespace. If this code element is declared in (or is) a third-party assembly, gets only fields used by the application.
            </summary>
            <remarks>
            The result includes instance and static fields, and enumeration values and literal constant fields.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildFields" />.Count)</i> time complexity.
            If this is a <see cref="T:NDepend.CodeModel.ICodeBase" />, return the same sequence as <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="P:NDepend.CodeModel.ICodeBaseView.Fields" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.NbMethods">
            <summary>
            Gets the number of methods declared in types of this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeElementParent.NbFields">
            <summary>
            Gets the number of fields declared in types of this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ICodeMetric`2">
            <summary>
            Represent a code metric, a correspondance between a set of code elements and some numerical values.
            </summary>
            <remarks>
            A code metric object is returned by extension methods of <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" /> defined on sequences of code elements.<br />
            A custom code metric object can also be created through the particular method <see cref="T:NDepend.CodeModel.ExtensionMethodsHelpers" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" />.
            </remarks>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <typeparam name="TNumeric">
            The numeric value type that is one of these type: <i>byte</i>, <i>sbyte</i>, <i>short</i>, <i>ushort</i>, <i>int</i>, <i>uint</i>, <i>long</i>, <i>ulong</i>, <i>float</i>, <i>double</i>, <i>decimal</i>. <br />
            </typeparam>
            <seealso cref="T:NDepend.CodeModel.ICodeMetricValue`2" />
            <seealso cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount">
            <summary>
            Gets the number of code elements for which this code metric is defined.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain">
            <summary>
            Gets the sequence of code elements for which this code metric is defined.
            </summary>
            <remarks>
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ICodeMetric`2.DefinedFor(`0)">
            <summary>
            Gets a value indicating whether this code metric is defined for <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This method has a constant time complexity.
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ICodeMetric`2.ValueOf(`0)">
            <summary>
            Gets this code metric value for <paramref name="codeElement" />. Gets <i>null</i> if the metric is not defined for <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This method has a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.Item(`0)">
            <summary>
            Gets this code metric value for <paramref name="codeElement" />. Gets <i>null</i> if the metric is not defined for <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This accessor is equivalent to the method <see cref="M:NDepend.CodeModel.ICodeMetric`2.ValueOf(`0)" />.<br />
            This method has a constant time complexity.
            </remarks>
        </member>
        <member name="M:NDepend.CodeModel.ICodeMetric`2.ElementsWithValue(`1)">
            <summary>
            Gets the sequence of code elements for which, this code metric value is equal to <paramref name="value" /> Gets an empty sequence if no code element are matched.
            </summary>
            <param name="value">The value.</param>
            <remarks>
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.Values">
            <summary>
            Gets the sequence of this code metric values taken by all code elements in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />. Numeric values are sorted with an ascending order in the sequence.
            </summary>
            <remarks>
            Gets an empty sequence if DefinitionDomain is empty.<br />
            Notice that this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.Count() can be lower than this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> if several code elements have the same value.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.MinValue">
            <summary>
            Gets the the minimum value in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.
            </summary>
            <remarks>
            If this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> is zero, returns <i>null</i>.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetric`2.MaxValue">
            <summary>
            Gets the the maximum value in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.
            </summary>
            <remarks>
            If this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> is zero, returns <i>null</i>.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
        </member>
        <member name="T:NDepend.CodeModel.ICodeMetricValue`2">
            <summary>
            Represent a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> value.
            </summary>
            <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
            <typeparam name="TNumeric">
            The numeric value type that is one of these type: <i>byte</i>, <i>sbyte</i>, <i>short</i>, <i>ushort</i>, <i>int</i>, <i>uint</i>, <i>long</i>, <i>ulong</i>, <i>float</i>, <i>double</i>, <i>decimal</i>. <br />
            </typeparam>
            <seealso cref="T:NDepend.CodeModel.ICodeMetric`2" />
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetricValue`2.CodeElement">
            <summary>
            Gets the code element of this <see cref="T:NDepend.CodeModel.ICodeMetricValue`2" /> object.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ICodeMetricValue`2.Value">
            <summary>
            Gets the numeric value of this <see cref="T:NDepend.CodeModel.ICodeMetricValue`2" /> object.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ICompareContext">
            <summary>
            Represents a diff context of two <see cref="T:NDepend.CodeModel.ICodeBase" /> objects compared, <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />. A <see cref="T:NDepend.CodeModel.ICompareContext" /> object can be obtained through the extension method <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />.
            </summary>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="P:NDepend.CodeModel.ICompareContext.NewerCodeBase">
            <summary>
            Gets the newer version of the code base for this <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
            <remarks>
            This property getter has a constant time complexity.<br />
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />
        </member>
        <member name="P:NDepend.CodeModel.ICompareContext.OlderCodeBase">
            <summary>
            Gets the older version of the code base for this <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
            <remarks>
            This property getter has a constant time complexity.<br />
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />
        </member>
        <member name="P:NDepend.CodeModel.ICompareContext.ContainsChanges">
            <summary>
            Returns true if any change is detected between <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </summary>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)">
            <summary>
            Returns the newer version of the <paramref name="codeElement" /> object.
            </summary>
            <remarks>
            If <paramref name="codeElement" /> is already the newer version, returns the <paramref name="codeElement" /> object.<br />
            If <paramref name="codeElement" /> has been removed and has no corresponding newer version, returns <i>null</i>.<br />
            This method has a constant time complexity.<br />
            </remarks>
            <typeparam name="T"><i>T</i> is a <see cref="T:NDepend.CodeModel.ICodeElement" /> type.</typeparam>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.NewerVersion``1(``0)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)">
            <summary>
            Returns the older version of the <paramref name="codeElement" /> object.
            </summary>
            <remarks>
            If <paramref name="codeElement" /> is already the older version, returns the <paramref name="codeElement" /> object.<br />
            If <paramref name="codeElement" /> has been added and has no corresponding older version, returns <i>null</i>.<br />
            This method has a constant time complexity.<br />
            </remarks>
            <typeparam name="T"><i>T</i> is a <see cref="T:NDepend.CodeModel.ICodeElement" /> type.</typeparam>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.OlderVersion``1(``0)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.MeInOtherBuild``1(``0)">
             <summary>
             Returns the older version of <paramref name="codeElement" /> if <see cref="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild(NDepend.CodeModel.ICodeElement)" />, else return the older version.
             </summary>
             <remarks>
             If <paramref name="codeElement" /> has been added in newer build, or removed from older build, this method returns <i>null</i>.
             This method has a constant time complexity.
             </remarks>
            <typeparam name="T"><i>T</i> is a <see cref="T:NDepend.CodeModel.ICodeElement" /> type.</typeparam>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in the newer version of the code base.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. </param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInNewerBuild(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in the older version of the code base.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. </param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInOlderBuild(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is both in the newer and older versions of the code base.
            </summary>
            <remarks>
            If <i>true</i> is returned, this means that the <paramref name="codeElement" /> has not been added nor removed.<br />
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. </param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsPresentInBothBuilds(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object was changed in any way (code change, comment change, visibility change...).
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. </param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasChanged(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object has been added and thus, is not present in the older version of the code base.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasAdded(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object has been removed and thus, is not present in the newer version of the code base.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasRemoved(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the newer version of the code base, but not by the older version.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedRecently(NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the older version of the code base, but not by the newer version.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)">
            <summary>
            Returns <i>true</i> if the code of this <paramref name="codeContainer" /> object, has been modified.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeContainer">The <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeContainer" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)">
            <summary>
            Returns <i>true</i> if comments of this <paramref name="codeContainer" /> object, have been modified.
            </summary>
            <remarks>
            So far, comments change is detected only when <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" /> has been changed.<br />
            This method has a constant time complexity.
            </remarks>
            <param name="codeContainer">The <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeContainer" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)">
            <summary>
            Returns <i>true</i> if the visibility of this <paramref name="member" /> has been changed.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="member">The <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="member" /> does not belong to <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.VisibilityWasChanged(NDepend.CodeModel.IMember)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)">
            <summary>
            Returns <i>true</i> if the <paramref name="member" /> is not tagged with <i>System.ObsoleteAttribute</i> in the older version of the code base, but is tagged as obsolete in the newer version of the code base.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="member">The <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="member" /> does not belong to <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.BecameObsolete(NDepend.CodeModel.IMember)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)">
            <summary>
            Returns <i>true</i> if the <paramref name="codeElementParent" /> is a namespace or a type in a third-party assembly (or is a third-party assembly itself) and if some of its children code elements are not used anymore by the newer version of the code base, or are used by the newer version of the code base, but are not used by the older version.
            </summary>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <param name="codeElementParent">The <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object. A <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IType" /> object.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElementParent" /> is not <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> nor <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> not a code element that belong to any of these code base.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceFilePath" /> content is different between the older and the newer build.
            </summary>
            <remarks>
            <paramref name="sourceFilePath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<br />
            If only some formatting have been changed within the source file without touching any code behavior, the source file is seen as changed while no code element declared within the source file is seen as changed.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceFilePath">The absolute source file path.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteFilePath)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceFilePath" /> has been added since the baseline.
            </summary>
            <remarks>
            <paramref name="sourceFilePath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceFilePath">The absolute source file path.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteFilePath)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceFilePath" /> has been removed since the baseline.
            </summary>
            <remarks>
            <paramref name="sourceFilePath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<br />
            The code element from which the <paramref name="sourceFilePath" /> is obtained must be obtained from <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceFilePath">The absolute source file path.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteFilePath)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceDirPath" /> contains source files changed, added or removed since the baseline.
            </summary>
            <remarks>
            <paramref name="sourceDirPath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<see cref="P:NDepend.Path.IPath.ParentDirectoryPath" />.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceDirPath">The absolute directory path that contains some source files.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteDirectoryPath)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceDirPath" /> has been added since the baseline.
            </summary>
            <remarks>
            <paramref name="sourceDirPath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<see cref="P:NDepend.Path.IPath.ParentDirectoryPath" />.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceDirPath">The absolute directory path that contains some source files.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteDirectoryPath)" />
        </member>
        <member name="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Returns <i>true</i> if the <paramref name="sourceDirPath" /> has been removed since the baseline.
            </summary>
            <remarks>
            <paramref name="sourceDirPath" /> can be obtained from <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" /> , <see cref="T:NDepend.CodeModel.ISourceDecl" />.<see cref="P:NDepend.CodeModel.ISourceDecl.SourceFile" />.<see cref="P:NDepend.CodeModel.ISourceFile.FilePath" />.<see cref="P:NDepend.Path.IPath.ParentDirectoryPath" />.<br />
            The code element from which the <paramref name="sourceDirPath" /> is obtained must be obtained from <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.<br />
            This method works even when the path is rebased, thanks to an heuristic.
            </remarks>
            <param name="sourceDirPath">The absolute directory path that contains some source files.</param>
            <seealso cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.Path.IAbsoluteFilePath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.Path.IAbsoluteDirectoryPath)" />
            <seealso cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.Path.IAbsoluteDirectoryPath)" />
        </member>
        <member name="T:NDepend.CodeModel.IField">
            <summary>
            Represents a field declared in an application assembly, or declared in a third-party assembly and used the by application code.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IField.MethodsUsingMe">
            <summary>
            Gets a sequence of methods that are using this field. A field is considered as used if it is read or assigned.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IField.MethodsAssigningMe">
            <summary>
            Gets a sequence of methods that are assigning this field.
            </summary>
            <remarks>
            For an instance field, constructor(s) of its class that assign the field are not counted.
            
            For a static field, the class constructor that assigns the field is not counted.
            
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe">
            <summary>
            Gets a sequence of methods that are reading this field but not assigning it.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count + this.<see cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IField.FieldType">
            <summary>
            Gets the field type of this field. Gets <i>null</i> if the field type of this field is not in the scope of assemblies analyzed defined by <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeToAnalyze" />.
            </summary>
            <remarks>
            This property getter has a constant time complexity.
            </remarks>
            <see cref="P:NDepend.CodeModel.IField.FieldType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IField.IsEnumValue">
            <summary>
            Gets a value indicating whether this field is a value of an enumeration.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IField.IsEventDelegateObject">
            <summary>
            Gets a value indicating whether this field is an event delegate object. C# and VB.NET compilers define for each event an event adder, an event remover, and a field typed with a delegate class.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IField.IsLiteral">
            <summary>
            Gets a value indicating whether this field is declared with the <i>const</i> keyword in C# and the <i>Const</i> keyword in VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IField.IsInitOnly">
            <summary>
            Gets a value indicating whether this field is declared with the <i>readonly</i> keyword in C# and the <i>ReadOnly</i> keyword in VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IField.IsImmutable">
            <summary>
            Gets a value indicating whether this field is <i>immutable</i>.
            </summary>
            <remarks>
            A <i>static</i> field is considered as immutable if it is private and if it is only assigned by the static constructor.<br />
            An <i>instance</i> field is considered as immutable if it is private and if it is only assigned by its type’s constructor(s) or its type’s static constructor.<br />
            Fields with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsLiteral" />, <see cref="P:NDepend.CodeModel.IField.IsEnumValue" /> or <see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" /> are <b>never</b> considered as immutable to avoid noise in the search for immutable fields.<br />
            A field with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsInitOnly" /> is <b>always</b> considered as immutable. <br />
            In addition, a field with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsImmutable" /> can be safely marked as <i>readonly</i>.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IField.SizeOfInst">
            <summary>
            Gets a numeric nullable value measuring this field contribution, in bytes, to the parent's <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> value.
            </summary>
            <remarks>
            <i><u>Size of Instance code metric description:</u></i><br /><i>SizeOfInst</i> for an instance field with a reference type field (class, interface, delegate) counts for 4 bytes.<br /><i>SizeOfInst</i> for an instance field with a value type field (structure, int, byte, double...) is equal to the value type <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> value.<br /><i>SizeOfInst</i> for a static field is null.<br />
            </remarks>
            <returns>
            <i>null</i> if this field is declared in a third-party assembly.<br /><i>null</i> if this field is static.<br />
            Otherwise returns this field <see cref="P:NDepend.CodeModel.IField.SizeOfInst" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IField.NbMethodsUsingMe">
            <summary>
            Gets the number of methods that use this field.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.IMember">
            <summary>
            Represents a member code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" /> and <see cref="T:NDepend.CodeModel.IType" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.Visibility">
            <summary>Gets a <see cref="P:NDepend.CodeModel.IMember.Visibility" /> value representing the visibility of this member.</summary>
            <seealso cref="P:NDepend.CodeModel.IMember.IsPublic" />
            <seealso cref="P:NDepend.CodeModel.IMember.IsInternal" />
            <seealso cref="P:NDepend.CodeModel.IMember.IsProtected" />
            <seealso cref="P:NDepend.CodeModel.IMember.IsProtectedAndInternal" />
            <seealso cref="P:NDepend.CodeModel.IMember.IsProtectedOrInternal" />
            <seealso cref="P:NDepend.CodeModel.IMember.IsPrivate" />
            <seealso cref="P:NDepend.CodeModel.IMember.OptimalVisibility" />
        </member>
        <member name="P:NDepend.CodeModel.IMember.OptimalVisibility">
            <summary>Gets a <see cref="P:NDepend.CodeModel.IMember.Visibility" /> value representing the optimal visibility this member could have.</summary>
            <seealso cref="P:NDepend.CodeModel.IMember.CouldBeInternal" />
            <seealso cref="P:NDepend.CodeModel.IMember.CouldBeProtected" />
            <seealso cref="P:NDepend.CodeModel.IMember.CouldBeInternalProtected" />
            <seealso cref="P:NDepend.CodeModel.IMember.CouldBePrivate" />
            <seealso cref="P:NDepend.CodeModel.IMember.Visibility" />
            <seealso cref="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute" />
        </member>
        <member name="P:NDepend.CodeModel.IMember.ParentType">
            <summary>
            Gets the parent type of this member.
            </summary>
            <remarks>
            This property getter has a constant time complexity.<br />
            If this member is a type not nested in another type, this property returns <i>null</i>.<br />
            If this member is an application type nested in another type, this property returns the parent type.<br />
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, but the parent/nested relation is not resolved. 
            Hence for a third-party nested types, <i>null</i> is returned by this property.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.ParentNamespace">
            <summary>
            Gets the parent namespace where this member is declared in.
            </summary>
            <remarks>
            This property getter has a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.ParentAssembly">
            <summary>
            Gets the parent assembly where this member is declared in.
            </summary>
            <remarks>
            This property getter has a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsPubliclyVisible">
            <summary>
            Gets a value indicating whether this member is publicly visible outside of its declaring assembly.
            </summary>
            <remarks>
            Being a publicly visible member is a stronger condition than just having the property getter <see cref="P:NDepend.CodeModel.IMember.IsPublic" /> equals to <i>true.</i>.<br />
            Indeed, it is common that a <i>public</i> member is declared in an <i>internal</i> type, in which case the member is not <i>publicly visible</i>.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsPublic">
            <summary>
            Gets a value indicating whether this member is declared as <i>public</i>.
            </summary>
            <remarks>
            See the condition <see cref="P:NDepend.CodeModel.IMember.IsPubliclyVisible" /> if you wish to assess if a member is publicly visible outside of its declaring assembly.s
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsPrivate">
            <summary>
            Gets a value indicating whether this member is declared as <i>private</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsInternal">
            <summary>
            Gets a value indicating whether this member is declared as <i>internal</i> in C#, or <i>Friend</i> in VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsProtected">
            <summary>
            Gets a value indicating whether this member is declared as <i>protected</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsProtectedAndInternal">
            <summary>
            Gets a value indicating whether this member is declared as <i>protected <b>and</b> internal</i>. This visibility level is provided by the IL language but is not supported neither by C# nor VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsProtectedOrInternal">
            <summary>
            Gets a value indicating whether this member is declared as <i>protected internal</i> in C#, or <i>Protected Friend</i> in VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsStatic">
            <summary>
            Gets a value indicating whether this member is a static method or field, or a static type.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsSpecialName">
            <summary>
            Gets a value indicating whether this member has a name that requires special handling, in the sense defined by <i>System.Type.IsSpecialName</i> and <i>System.Reflection.MethodBase.IsSpecialName</i>.
            </summary>
            <remarks>
            Typically methods with special names are constructors, properties/events/indexers accessors, explicit interface method implementation.<br />
            Fields with special names is the instance field named <i>value__</i> generated for each enumeration.<br />
            &gt;
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsGeneratedByCompiler">
            <summary>
            Gets a value indicating whether this member has been generated by the compiler. This situation typically results from the compiler implementing lambdas, anonymous methods and iterators.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.IsObsolete">
            <summary>
            Gets a value indicating whether this member is tagged with <i>System.ObsoleteAttribute</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMember.ShouldBePublic">
            <summary>
            Gets a value indicating whether this member is used outside of its declaring assembly thanks to the attribute <i>System.Compilers.Services.InternalsVisibleToAttribute</i>.
            </summary>
            <remarks>
            Often, having code elements that are considered as <see cref="P:NDepend.CodeModel.IMember.ShouldBePublic" /> is not a problem because it is made on purpose. However, it can be interesting to list them.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.CouldBeInternal">
            <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>internal</i> in C# (<i>Friend</i> in VB.NET) within the context of the analyzed application.
            </summary>
            <remarks>
            A public code element can be declared as <i>internal</i> if it is not used outside of the assembly it is declared in.<br />
            When analyzing a framework, many of public members will be considered as <see cref="P:NDepend.CodeModel.IMember.CouldBeInternal" /> because there is no analyzed client code using them.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.CouldBeInternalProtected">
            <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>protected internal</i> in C# (<i>Protected Friend</i> in VB.NET) within the context of the analyzed application.
            </summary>
            <remarks>
            A public member can be declared as <i>protected internal</i> (reads <i>protected <b>or</b> internal</i>) if it is not used outside of the assembly it is declared in and if it is not used outside of the classes that derive from the class it is declared in.<br />
            When analyzing a framework, some of the public members will be considered as <see cref="P:NDepend.CodeModel.IMember.CouldBeInternalProtected" /> because there is no analyzed client code using them.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.CouldBeProtected">
            <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>protected</i> in C# (<i>Protected</i> in VB.NET) within the context of the analyzed application.
            </summary>
            <remarks>
            A public member can be declared as <i>protected</i> if it is not used outside of the classes that derive from the class it is declared in.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMember.CouldBePrivate">
            <summary>
            Gets a value indicating whether this member could be declared as <i>private</i> in C# (<i>Protected</i> in VB.NET) within the context of the analyzed application.
            </summary>
            <remarks>
            A member can be declared as <i>protected</i> if it is not used outside of its parent class.
            </remarks>
        </member>
        <member name="T:NDepend.CodeModel.IMethod">
            <summary>
            Represents a method declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsExtensionMethod">
            <summary>
            Gets a value indicating whether this method is an extension method.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.AccessThis">
            <summary>
            Gets a value indicating whether this method is explicitly accessign the this reference.
            </summary>
            <remarks>
            Returns false for any static method.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.MethodsCalled">
            <summary>
            Gets a sequence of methods that this method is calling. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MethodsCalled" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.MembersUsed">
            <summary>
            Gets a sequence of fields and methods that this method is using and calling. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MembersUsed" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.MethodsCallingMe">
            <summary>
            Gets a sequence of methods that are calling this method.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MethodsCallingMe" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.FieldsUsed">
            <summary>
            Gets a sequence of fields that this method is using. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.FieldsAssigned">
            <summary>
            Gets a sequence of fields that this method is assigning. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned">
            <summary>
            Gets a sequence of fields that this method is reading but not assigning. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.OverridesDerived">
            <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DerivedTypes" />, overriding this method. If this method is not overridden, gets an empty sequence.
            </summary>
            <remarks>
            A sequence of methods overriding this method is also returned even if this method is declared in a third-party assembly.<br />
            Methods for which <see cref="P:NDepend.CodeModel.IMethod.IsNewSlot" /> is <i>true</i>, are not in the returned sequence.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.NbChildren" />.Count) time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />
            <seealso cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.OverridesDirectDerived">
            <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />, overriding this method. If this method is not overridden, gets an empty sequence.
            </summary>
            <remarks>
            A sequence of methods overriding this method is also returned even if this method is declared in a third-party assembly.<br />
            Methods for which <see cref="P:NDepend.CodeModel.IMethod.IsNewSlot" /> is <i>true</i>, are not in the returned sequence.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.NbChildren" />.Count) time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDerived" />
            <seealso cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.OverriddensBase">
            <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.BaseClasses" /> and <see cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />, overridden by this method. If this method doesn't override any method, gets an empty sequence.
            </summary>
            <remarks>
            A sequence of methods overridden by this method is also returned even if this method is declared in a third-party assembly.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />.Count) time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDerived" />
            <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.Overloads">
            <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />, sharing the same <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> with this method. The sequence returned doesn't contain this method.
            </summary>
            <remarks>
            If this method doesn't have any overload, gets an empty sequence.<br />
            If this method is declared in a third party assembly, gets an empty sequence no matter this method is overloaded or not.<br />
            Properties getters <see cref="P:NDepend.CodeModel.IMethod.IsOverloaded" /> and <see cref="P:NDepend.CodeModel.IMethod.NbOverloads" /> are faster to invoke than this property getter and might be better suited in some situations.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />.Count) time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.IsOverloaded" />
            <seealso cref="P:NDepend.CodeModel.IMethod.NbOverloads" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ReturnType">
            <summary>
            Gets the return type of this method. Gets <i>null</i> if the return type of this method is not in the scope of assemblies analyzed defined by <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeToAnalyze" />.
            </summary>
            <remarks>
            This property getter has a constant time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)">
            <summary>
            Gets a value indicating whether this method is assigning the field <paramref name="fieldAssigned" />.
            </summary>
            <param name="fieldAssigned">The field object.</param>
            <remarks>
            This method has a <i>O(<paramref name="fieldAssigned" />.<see cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
            <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
            <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)">
            <summary>
            Gets a value indicating whether this method is calling a constructor of the type <paramref name="typeCreated" />.
            </summary>
            <param name="typeCreated">The type object.</param>
            <remarks>
            This method has a O(this.<see cref="P:NDepend.CodeModel.IMethod.NbMethodsCalled" />.Count) time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsPropertyInit">
            <summary>
            Gets a value indicating whether this method is a property initializer defined with the C# keyword <i>init</i>.
            </summary>
            <remarks>
            Notice that if this value is <i>true</i> <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.IsPropertySetter" /> is also <i>true</i>.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsConstructor">
            <summary>
            Gets a value indicating whether this method is an instance constructor.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsClassConstructor">
            <summary>
            Gets a value indicating whether this method is a class constructor.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsPropertySetter">
            <summary>
            Gets a value indicating whether this method is a property getter.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsPropertyGetter">
            <summary>
            Gets a value indicating whether this method is a property setter.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsIndexerSetter">
            <summary>
            Gets a value indicating whether this method is an indexer setter.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsIndexerGetter">
            <summary>
            Gets a value indicating whether this method is an indexer getter.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsEventAdder">
            <summary>
            Gets a value indicating whether this method is an event adder.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsEventRemover">
            <summary>
            Gets a value indicating whether this method is an event remover.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsOperator">
            <summary>
            Gets a value indicating whether this method is an operator implementation method.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsEntryPoint">
            <summary>
            Gets a value indicating whether this method is defined as the entry point.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsFinalizer">
            <summary>
            Gets a value indicating whether this method is a finalizer.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsGeneric">
            <summary>
            Gets a value indicating whether this method is a generic method.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsOverloaded">
            <summary>
            Gets a value indicating whether this method one of several methods the same <see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" />
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsVirtual">
            <summary>
            Gets a value indicating whether this method is declared as virtual.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsFinal">
            <summary>
            Gets a value indicating whether this method is declared with the <i>sealed</i> keyword in C#, <i>NotOverridable</i> keyword in VB.NET.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsNewSlot">
            <summary>
            Gets a value indicating whether this method has a new slot in the type's method table.
            </summary>
            <remarks>
            Certainly the best resource on the web about this <i>new slot</i> advanced topic is <a href="http://stackoverflow.com/questions/2072983/more-about-virtual-new-plus-interfaces">this stackoverflow Q&amp;A</a><br />
            Internally, NDepend relies on this <i>new slot</i> value to compute the override/overriden methods sets in <see cref="T:NDepend.CodeModel.IMethod" /> property getter <see cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />, <see cref="P:NDepend.CodeModel.IMethod.OverridesDerived" /> and <see cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsPInvokeImpl">
            <summary>
            Gets a value indicating whether this method is tagged with the <i>System.Runtime.InteropServices.DllImportAttribute</i> attribute.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsExplicitInterfaceImpl">
            <summary>
            Gets a value indicating whether this method is an explicit interface method implementation.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsAbstract">
            <summary>
            Gets a value indicating whether this method is an abstract method, or a method declared on an interface.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsUsingBoxing">
            <summary>
            Gets a value indicating whether this method IL body is using the <b>box</b> IL instruction.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsUsingUnboxing">
            <summary>
            Gets a value indicating whether this method IL body is using the <b>unbox</b> IL instruction.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsUsingPointers">
            <summary>
            Gets a value indicating whether this method contains <i>unsafe code</i> that is using some pointers.
            </summary>
            <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsAsync">
            <summary>
            Gets a value indicating whether this method is asynchronous, declared with the keyword <i>async</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.IsUsingPinning">
            <summary>
            Gets a value indicating whether this method contains <i>unsafe code</i> that is using <i>pinning</i>.
            </summary>
            <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.<br />
            In C#, <i>pinning</i> is generated through the <i>fixed</i> keyword.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ChangesObjectState">
            <summary>
            Gets a value indicating whether this method assigns an <i>instance</i> field of its parent type
            </summary>
            <remarks>
            <i>true</i> can be returned also for a constructor or a class constructor method.<br /><i>true</i> is returned for a static method or a class constructor that modifies the state of an object passed by reference.<br /><i>true</i> is returned for an instance method of a type <i>T</i> that modifies an instance of <i>T</i> that is not the one referenced by the <i>this</i> reference.<br />
            Methods that <i>ChangesObjectState</i> complexify the program because they break type immutability (see <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsImmutable" />).<br />
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ChangesTypeState">
            <summary>
            Gets a value indicating whether this method assigns a <i>static</i> field of its parent type.
            </summary>
            <remarks>
            <i>true</i> can be returned also for a constructor or a class constructor method.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ReadsMutableTypeState">
            <summary>
            Gets a value indicating whether this method reads a <i>static</i> field with a <i>false</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" />
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ReadsMutableObjectState">
            <summary>
            Gets a value indicating whether this method reads an <i>instance</i> field with a <i>false</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" />
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ReadsImmutableTypeState">
            <summary>
            Gets a value indicating whether this method reads a <i>static</i> field with a <i>true</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" />
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ReadsImmutableObjectState">
            <summary>
            Gets a value indicating whether this method reads an <i>instance</i> field with a <i>true</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" />
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.CyclomaticComplexity">
            <summary>
            Gets a numeric nullable value measuring this method body complexity computed from source code.
            </summary>
            <remarks>
            <i><u>Cyclomatic Complexity code metric description:</u></i><br />
            The Cyclomatic Complexity (CC) is a popular procedural software metric equal to the number of decisions that can be taken in a procedure. <br />
            Concretely, in C# the CC of a method is 1 + {the number of following expressions found in the body of the method}:<br /><br />
            if | while | for | foreach | case | default | continue | goto | &amp;&amp; | || | catch | ternary operator ?: | ??<br /><br />
            Following expressions are not counted for CC computation:<br /><br />
            else | do | switch | try | using | throw | finally | return | object creation | method call | field access<br /><br />
            Notice that the CC of a lambda method or an anonymous method is not counted when computing the CC of its outer method.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods where CC is higher than 15 are hard to understand and maintain. Methods where CC is higher than 30 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).<br />
            </remarks>
            <returns>
            <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract or is a default constructor.<br /><i>null</i> if the PDB file of this method parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this method is written with a programming language different than C#.<br />
            Otherwise returns this method body complexity computed from source code.<br />
            More information on this can be found at: <a href="https://www.ndepend.com/docs/ndepend-analysis-inputs-explanation" target="_blank">Understanding NDepend Analysis Inputs</a><br />
            If source code CC is not available for a non-abstract method, the code metric <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> can be used instead.
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity">
            <summary>
            Gets a numeric nullable value measuring this method body complexity computed from IL code.
            </summary>
            <remarks>
            <i><u>Methods IL Cyclomatic Complexity code metric description:</u></i><br />
            The <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> (CC) metric is language dependent. Thus, NDepend provides the metric <i>ILCyclomaticComplexity</i> (ILCC) which is language independent because it is computed from IL as:<br />
            1 + {the number of different offsets targeted by a jump/branch IL instruction}. <br />
            Experience shows that ILCC is a bit more larger than the source code CC. Indeed, a C# <i>if</i> expression yields one IL jump. A C# <i>for</i> loop yields two different offsets targeted by a branch IL instruction while a <i>foreach</i> C# loop yields three.<br />
            </remarks>
            <returns>
            <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract or is a default constructor.<br />
            Otherwise returns this method body complexity computed from IL code.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.ILNestingDepth">
            <summary>
            Gets a numeric nullable value measuring this method body maximum nesting scopes depth.
            </summary>
            <remarks>
            <i><u>Methods IL Nesting Depth code metric description:</u></i><br />
            The metric Nesting Depth for a method is the maximum number of encapsulated scopes inside the body of the method. The metric <i>IL Nesting Depth</i> is computed from the IL code. Values computed are similar to what we would expect by computing them from the C# or VB.NET source code.<br />
            A testing condition with <i>N</i> conditions, such as <i>if( i &gt; 9 &amp;&amp; i &lt; 12)</i>, is considered as <i>N</i> scopes because it is possible to decompose such conditions into <i>N</i> atomic conditions.<br />
            When a method has a large number of case statements corresponding to a switch, the C# and VB.NET compiler generally produce optimizations while generating the IL. In such case, the <i>IL Nesting Depth</i> corresponding value might be slightly higher to what you would expect.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods with a <i>IL Nesting Depth</i> value higher than 4 are hard to understand and maintain. Methods with a <i>IL Nesting Depth</i> value higher than 8 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).<br /><br />
            </remarks>
            <returns>
            <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract.<br />
            Otherwise returns this method body maximum nesting scopes depth.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.NbOverloads">
            <summary>
            Gets the number of overloads of this method or this constructor. Gets 1 if this method is not overloaded. Gets null if this method is declared in a third-party assembly.
            </summary>
            <remarks>
            <i><u>Recommendations:</u></i><br />
            Methods where <i>NbOverloads</i> is higher than 6 might be a problem to maintain and provoke higher coupling than necessary.<br />
            This might also reveal a potential misused of the C# and VB.NET language that supports object initialization since versions C#v3 and VB9. This language feature helps reducing the number of constructors of a class.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.NbParameters">
            <summary>
            Gets the number of parameters of a method. <i>ref</i> and <i>out</i> parameters are also counted. The <i>this</i> reference passed to instance methods in IL is not counted as a parameter.
            </summary>
            <remarks>
            <i><u>Recommendations:</u></i><br />
            Methods where <i>NbParameters</i> is higher than 5 might be painful to call and might degrade performance. You should prefer using additional properties/fields to the declaring type to handle numerous states.<br />
            Another alternative is to provide a class or structure dedicated to handle arguments passing. For example see the class <i>System.Diagnostics.ProcessStartInfo</i> and the method <i>System.Diagnostics.Process.Start(ProcessStartInfo)</i>.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.NbVariables">
            <summary>
            Gets the number of variables declared in the body of this method. Gets null if this methods is abstract or if it is declared in a third-party assembly.
            </summary>
            <remarks>
            <i><u>Recommendations:</u></i><br />
            Methods where <i>NbVariables</i> is higher than 8 are hard to understand and maintain.<br />
            Methods where <i>NbVariables</i> is higher than 15 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.NbMethodsCalled">
            <summary>
            Gets the number of methods this method is calling. Gets null if this method is declared in a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.NbMethodsCallingMe">
            <summary>
            Gets the number of methods that call this method.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.Rank">
            <summary>
            Gets a numeric nullable value assessing this method rank, computed by the original <a href="http://www.sirgroane.net/google-page-rank/" target="_blank">Google Parge Rank</a> algorithm.
            </summary>
            <remarks>
            A homothety of center 0.15 is applied to make it so that the average of all application methods.<i>Rank</i> is 1.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods with high rank should be more carefully tested because bugs in such methods will likely be more catastrophic.<br /><br />
            </remarks>
            <returns>
            <i>null</i> if this method is declared in a third-party assembly.<br />
            Otherwise returns this method <see cref="P:NDepend.CodeModel.IMethod.Rank" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage">
            <summary>
            Gets a numeric nullable value measuring the percentage of branch coverage by tests for this method.
            </summary>
            <remarks>
            Branch coverage is a more accurate measure of code coverage than <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> because it compensates for method complexity.<br />
            Since branch coverage is generated from the underlying opcodes, it often does not map cleanly to source code.<br />
            This means that it might be difficult to take branch coverage values and determine how to write tests that will improve coverage.<br /><br /><i><u>Availability:</u></i><br />
            Branch coverage is only available if your coverage data are imported from <a href="http://www.ncover.com/" target="_blank">NCover</a> coverage files and if the metric <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is available for this method.
            </remarks>
        </member>
        <member name="T:NDepend.CodeModel.INamespace">
            <summary>
            Represents a namespace declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
            <remarks>
            If <i>N</i> assemblies declare the same namespace, there are <i>N</i> <see cref="T:NDepend.CodeModel.INamespace" /> objects with a common <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> value, one object for each assembly that declares the namespace.<br />
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.ParentAssembly">
            <summary>
            Gets the parent assembly of this namespace.
            </summary>
            <remarks>
            This property getter has a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.DirectChildNamespaces">
            <summary>
            Gets a sequence of direct child namespaces of this namespace. For example child namespaces of the namespace <i>AA.BB</i> could be <i>AA.BB.CC</i> but not <i>AA.BB.CC.DD</i>.
            </summary>
            <remarks>
            The anonymous namespace doesn't have any direct child namespace.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespace" />
        </member>
        <member name="P:NDepend.CodeModel.INamespace.ParentNamespaces">
            <summary>
            Gets a sequence of parent namespaces of this namespace. For example parent namespaces of the namespace <i>AA.BB.CC</i> could be <i>AA.BB</i> and <i>AA</i>.
            </summary>
            <remarks>
            The anonymous namespace doesn't have any parent namespace.<br />
            If the namespace <i>AA.BB</i> doesn't contain any type, it is not shown as a parent namespace of <i>AA.BB.CC</i>. Indeed, if a namespace doesn't contain any type, the NDepend code model doesn't contain an associated <i>INamespace</i> object.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespace" />
        </member>
        <member name="P:NDepend.CodeModel.INamespace.ParentNamespace">
            <summary>
            Gets the parent namespaces of this namespace. Gets <i>null</i> if no parent namespace is found. For example the parent namespace of the namespace <i>AA.BB.CC</i> could be <i>AA.BB</i> but not <i>AA</i>.
            </summary>
            <remarks>
            The anonymous namespace doesn't have any parent namespace.<br />
            If the namespace <i>AA.BB</i> doesn't contain any type, it is not shown as a parent namespace of <i>AA.BB.CC</i>. Indeed, if a namespace doesn't contain any type, the NDepend code model doesn't contain an associated <i>INamespace</i> object. In such case <i>AA</i> is deemed as being the direct parent namespace of <i>AA.BB.CC</i>.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElementParent.ChildNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />
            <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />
        </member>
        <member name="P:NDepend.CodeModel.INamespace.ContainsTypeDependencyCycle">
            <summary>
            Gets a value indicating whether this namespace contains a dependency cycle between its <see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" />. Gets <i>null</i> if this namespace is declared in a third-party assembly.
            </summary>
            <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.ICodeElementParent.ChildTypes" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.NamespacesUsed">
            <summary>
            Gets a sequence of namespaces that this namespace is using. If this namespace is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.NamespacesUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.INamespace.NamespacesUsingMe" />
        </member>
        <member name="P:NDepend.CodeModel.INamespace.NamespacesUsingMe">
            <summary>
            Gets a sequence of namespaces that are using this namespace.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.NamespacesUsingMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.INamespace.NamespacesUsed" />
        </member>
        <member name="P:NDepend.CodeModel.INamespace.IsGeneratedByCompiler">
            <summary>
            Gets a value indicating whether this namespace contains only types generated by the compiler.
            </summary>
            <remarks>
             Such namespace can be named for example  Microsoft.CodeAnalysis  or  System.Runtime.CompilerServices.
            </remarks> 
        </member>
        <member name="P:NDepend.CodeModel.INamespace.IsPublic">
            <summary>
            Gets a value indicating whether this namespace contains at least one public type.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.IsInternal">
            <summary>
            Gets a value indicating whether this namespace contains only internal types.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.CouldBeInternal">
            <summary>
            Gets a value indicating whether this namespace has at least one child public type, but is not used by any namespace declared in another assembly.
            </summary>
            <remarks>
            A public code element can be declared as <i>internal</i> if it is not used outside of the assembly it is declared in.<br />
            When analyzing a framework, many of public members will be considered as <see cref="P:NDepend.CodeModel.INamespace.CouldBeInternal" /> because there is no analyzed client code using them.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.NbTypes">
            <summary>
            Gets the number of types declared in this namespace. Gets null if this namespace is declared in a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.NbNamespacesUsed">
            <summary>
            Gets the number of namespaces this namespace is using. Gets null if this namespace is declared in a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.INamespace.NbNamespacesUsingMe">
            <summary>
            Gets the number of namespaces that use this namespace.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ISourceFile">
            <summary>
            Represents a source file of the analyzed application.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.FilePath">
            <summary>
            Gets this absolute source file path object.
            </summary>
            <remarks>
            This property cannot be used in CQLinq context because <see cref="T:NDepend.Path.IAbsoluteFilePath" /> is not supported by CQLinq.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.FilePathString">
            <summary>
            Gets a string that contains this absolute source file path, like <i>"C:\Dir\FileName.cs"</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.DirectoryPath">
            <summary>
            Gets a string that contains this absolute source file's parent directory path, like <i>"C:\Dir"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.FileName">
            <summary>
            Gets a string that contains this source file name, like <i>"FileName.cs"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.FileNameWithoutExtension">
            <summary>
            Gets a string that contains this source file name without extension, like <i>"FileName"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.FileNameExtension">
            <summary>
            Gets a string that contains this source file name extension, like <i>".cs"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceFile.Language">
            <summary>
            Gets this source file language, inferred from the source file extension.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.ISourceDecl">
            <summary>
            Represents a 1-based line number in a source file of the analyzed application.
            </summary>
            <remarks>
            This interface is useful to represents a source file declaration of a code element <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />
            and of an issue <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.SourceDecl" /><br />
            Such a declaration can be opened with the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsTooling" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.ISourceDecl.SourceFile">
            <summary>
            Gets the source file object.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceDecl.Line">
            <summary>
            Gets the 1-based line number in the source file.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.ISourceDecl.Column">
            <summary>
            Gets the 1-based column number in the source file.
            </summary>
        </member>
        <member name="T:NDepend.CodeModel.IType">
            <summary>
            Represents a type declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.TypesUsed">
            <summary>
            Gets a sequence of types that this type is using. If this type is declared in a third-party assembly, gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.TypesUsingMe" />
        </member>
        <member name="P:NDepend.CodeModel.IType.TypesUsingMe">
            <summary>
            Gets a sequence of types that are using this type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsingMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.TypesUsed" />
        </member>
        <member name="P:NDepend.CodeModel.IType.ContainsMethodDependencyCycle">
            <summary>
            Gets a value indicating whether this type contains a dependency cycle between its <see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />. Gets <i>null</i> if this type is declared in a third-party assembly.
            </summary>
            <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.DirectNestedTypes">
            <summary>
            Gets a sequence of types nested in this type. The sequence doesn't contain types nested in types nested in this type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.<br />
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation is not resolved. Hence for third-party types, an empty sequence is returned by this property.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
        </member>
        <member name="P:NDepend.CodeModel.IType.NestedTypes">
            <summary>
            Gets a sequence of types nested in this type, or nested in a type nested in this type (recursive).
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.<br />
            Notice that for third-party nested types, the property <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsNested" /> is set to <i>true</i>, 
            but the parent/nested relation is not resolved. Hence for third-party types, an empty sequence is returned by this property.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.DirectNestedTypes" />
        </member>
        <member name="P:NDepend.CodeModel.IType.OutterTypes">
            <summary>
            Gets a sequence of parent type(s) in which this type is nested.
            </summary>
            <remarks>
             If this type is not nested returns an empty sequence.<br />
             The first type in sequence is the type returned by <i>this</i>.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<br />
             If the parent type is also nested, the second type in sequence if its parent type and so on.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.Constructors">
            <summary>
            Gets a sequence of constructors of this type. The sequence doesn't contain class constructor.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMethodsAndConstructors" />
        </member>
        <member name="P:NDepend.CodeModel.IType.Methods">
            <summary>
            Gets a sequence of methods of this type. The sequence doesn't contain constructors nor class constructors but contain properties getters and setters, and events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMethods" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticMethods" />
        </member>
        <member name="P:NDepend.CodeModel.IType.MethodsAndContructors">
            <summary>
            Gets a sequence of methods and constructors of this type. The sequence also contains properties getters and setters, and events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMethodsAndConstructors" />
        </member>
        <member name="P:NDepend.CodeModel.IType.MethodsAndConstructors">
            <summary>
            Gets a sequence of methods and constructors of this type. The sequence also contains properties getters and setters, and events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMethodsAndConstructors" />
        </member>
        <member name="P:NDepend.CodeModel.IType.Fields">
            <summary>
            Gets a sequence of fields of this type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InstanceFields" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticFields" />
        </member>
        <member name="P:NDepend.CodeModel.IType.Members">
            <summary>
            Gets a sequence of members of this type. The sequence contains constructors, methods and fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMembers" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticMembers" />
        </member>
        <member name="P:NDepend.CodeModel.IType.ClassConstructor">
            <summary>
            Gets the <see cref="T:NDepend.CodeModel.IMethod" /> object representing this class constructor, if any, otherwise gets <i>null</i>.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.StaticMethods">
            <summary>
            Gets a sequence of static methods of this type. The sequence doesn't contain the class constructor (if any) but contain static properties getters and setters, and static events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Methods" />
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMethods" />
        </member>
        <member name="P:NDepend.CodeModel.IType.StaticFields">
            <summary>
            Gets a sequence of static fields of this type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Fields" />
            <seealso cref="P:NDepend.CodeModel.IType.InstanceFields" />
        </member>
        <member name="P:NDepend.CodeModel.IType.StaticMembers">
            <summary>
            Gets a sequence of static members of this type. The sequence contains the class constructor (if any), static methods and fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Members" />
            <seealso cref="P:NDepend.CodeModel.IType.InstanceMembers" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InstanceMethods">
            <summary>
            Gets a sequence of non-static methods of this type. The sequence doesn't contain non-static constructors but contain non-static properties getters and setters, and non-static events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Methods" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticMethods" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InstanceMethodsAndContructors">
            <summary>
            Gets a sequence of non-static methods and constructors of this type. The sequence also contains non-static properties getters and setters, and non-static events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />
            <seealso cref="P:NDepend.CodeModel.IType.ClassConstructor" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InstanceMethodsAndConstructors">
            <summary>
            Gets a sequence of non-static methods and constructors of this type. The sequence also contains non-static properties getters and setters, and non-static events adders and removers.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.MethodsAndConstructors" />
            <seealso cref="P:NDepend.CodeModel.IType.ClassConstructor" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InstanceFields">
            <summary>
            Gets a sequence of non-static fields of this type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Fields" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticFields" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InstanceMembers">
            <summary>
            Gets a sequence of non-static members of this type. The sequence contains non-static constructors, non-static methods and non-static fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.Members" />
            <seealso cref="P:NDepend.CodeModel.IType.StaticMembers" />
        </member>
        <member name="P:NDepend.CodeModel.IType.BaseClass">
            <summary>
            Gets the <see cref="T:NDepend.CodeModel.IType" /> object representing the base class of this class, if any, otherwise gets <i>null</i>.
            </summary>
            <remarks>
            Interfaces or the class <i>System.Object</i> don't have a base class.<br />
            This property getter has a constant time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.BaseClasses">
            <summary>
            Gets a sequence of all base classes of this class. The sequence is empty if this type doesn't have any base class.
            </summary>
            <remarks>
            Interfaces or the class <i>System.Object</i> don't have any base class.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)">
            <summary>Returns a value indicating whether this type derives <i> directly or indirectly</i> from <paramref name="baseClass" />.</summary>
            <param name="baseClass">The base class to derive from.</param>
            <remarks>
            For any type <i>T</i>, <i>T.DeriveFrom(T)</i> returns false.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)">
            <summary>Returns a nullable numeric value equals to this type depth of inheritance, relative to <paramref name="baseClass" />. Returns <i>null</i> if this type doesn't derive from <paramref name="baseClass" />.</summary>
            <param name="baseClass">The base class.</param>
            <remarks>
            For any type <i>T</i>, <i>T.DepthOfDeriveFrom(T)</i> returns 0.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.DirectDerivedTypes">
            <summary>
            Gets a sequence of types that derives directly from this type. The sequence is empty if this type has no derived type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.DerivedTypes">
            <summary>
            Gets a sequence of all types derived from this type. The sequence is empty if this type has no derived type.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DerivedTypes" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)">
            <summary>Returns a value indicating whether this type implements <paramref name="interface" />.</summary>
            <param name="interface">The interface to implement.</param>
            <remarks>
            This method has a constant time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.InterfacesImplemented">
            <summary>
            Gets a sequence of interfaces implemented by this type. The sequence returned is empty if this type doesn't implement any interface.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.TypesThatImplementMe">
            <summary>
            If this type is an interface, gets a sequence of types implementing this interface, otherwise gets an empty sequence.
            </summary>
            <remarks>
            This property getter has a <i>O(this.<seealso cref="P:NDepend.CodeModel.IType.TypesUsingMe" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="P:NDepend.CodeModel.IType.IsTypeForwaded">
            <summary>
            Returns a value indicating if this type is defined through the attribute <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute" />.
            </summary>
            <remarks>
            If <i>true</i> is returned the property <see cref="P:NDepend.CodeModel.IType.TypeForwadedDeclAssemblyName" /> returns the name of the assembly that contains the declaration of this type.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.TypeForwadedDeclAssemblyName">
            <summary>
            If this type is defined through the attribute <see cref="T:System.Runtime.CompilerServices.TypeForwardedToAttribute" />, returns the name of the assembly that contains the declaration of this type. Else returns <i>null</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsRecord">
            <summary>
            Gets a value indicating whether this type is a record class, defined with the C# keyword <i>record</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsVisibleOnlyInFile">
            <summary>
            Gets a value indicating whether this type is declared with the C# keyword <i>file</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsReadOnly">
            <summary>
            Gets a value indicating whether this type is declared with the C# keyword <i>readonly</i>.
            </summary>
            <remarks>
             So far only structures can be declared as <i>readonly</i>.
             Doing so leads the C# compiler and the JIT to perform some low-level optimizations.
             </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsGeneric">
            <summary>
            Gets a value indicating whether this type is a generic type.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsAbstract">
            <summary>
            Gets a value indicating whether this type is an abstract class or an interface.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsClass">
            <summary>
            Gets a value indicating whether this type is a class.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsStructure">
            <summary>
            Gets a value indicating whether this type is a structure.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsEnumeration">
            <summary>
            Gets a value indicating whether this type is an enumeration.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsInterface">
            <summary>
            Gets a value indicating whether this type is an interface.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsDelegate">
            <summary>
            Gets a value indicating whether this type is a delegate class, deriving from <i>System.MulticastDelegate</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsExceptionClass">
            <summary>
            Gets a value indicating whether this type is an exception class, deriving from <i>System.Exception</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsAttributeClass">
            <summary>
            Gets a value indicating whether this type is an attribute class, deriving from <i>System.Attribute</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsSealed">
            <summary>
            Gets a value indicating whether this class is declared with the <i>sealed</i> keyword in C#, <i>NotInheritable</i> keyword in VB.NET.
            </summary>
            <remarks>
            Structures and necessarily marked as sealed.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsNested">
            <summary>
            Gets a value indicating whether this type is nested in a parent type.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsSerializable">
            <summary>
            Gets a value indicating whether this type is serializable.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsUsingBoxing">
            <summary>
            Gets a value indicating whether this type contains at least a method with an IL body that uses the <b>box</b> IL instruction.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsUsingUnboxing">
            <summary>
            Gets a value indicating whether this type contains at least a method with an IL body that uses the <b>unbox</b> IL instruction.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsUsingPointers">
            <summary>
            Gets a value indicating whether this type contains at least a method that contains <i>unsafe code</i> that is using some pointers.
            </summary>
            <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsUsingPinning">
            <summary>
            Gets a value indicating whether this type contains at least a method that contains <i>unsafe code</i> that is using <i>pinning</i>.
            </summary>
            <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.<br />
            In C#, <i>pinning</i> is generated through the <i>fixed</i> keyword.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.HasFinalizer">
            <summary>
            Gets a value indicating whether this type contains a finalizer method.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.IsImmutable">
            <summary>
            Gets a value indicating whether this type is <i>immutable</i>. A type is considered as <i>immutable</i> if its instance fields cannot be modified once an instance has been built by a constructor.
            </summary>
            <remarks>
            <ul><li>A stateless type (i.e a type without any instance field) is considered as immutable.</li><li>A type with at least one non-private instance field is considered as mutable, because such a field can be eventually modified outside the type.</li><li>A class that derives directly or indirectly from a mutable type is considered as mutable.</li><li>Enumerations, static types, types defined in third-party assemblies and delegate classes are never considered as immutable. Although these types might match the definition of immutability, considering them as immutable would introduce noise when searching for immutable types.</li><li>Particularly, classes that derive directly or indirectly from a class defined in a third-party assembly that is not the <i>System.Object class</i>, is never considered as immutable.</li><li>Using the <i>readonly</i> C# keyword (<i>ReadOnly</i> in VB.NET) on your own instance field is a good way to achieve immutability.</li><li>Notice that if a type <i>T</i> has some instance fields that are of reference type, the object pointed by such a reference might be modified without breaking the immutability of <i>T</i>. We are talking of <b>shallow immutability</b>.</li></ul>
            It is still possible to break immutability by using the <i>ref</i> C# keyword (<i>ByRef</i> in VB.NET) to allow a tier method to modify the state of an instance field.<br />
            As .NET framework designers considered that the immutability of the class <i>System.String</i> can be broken using advanced means such as reflection or unsafe code, you should consider that using the C# keyword <i>ref</i> or reflection or unsafe code are <i>advanced</i> means to break immutability of your own types.<br />
            Immutable types are especially useful when you have to deal with multi-threading application. Indeed, accesses to instances of immutable types don’t need to be synchronized because such objects can’t be modified; hence all accesses are read-only accesses.<br />
            To enforce your classes and structures immutability, see the attribute class <see cref="T:NDepend.Attributes.ImmutableAttribute" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.CyclomaticComplexity">
            <summary>
            Gets a numeric nullable value measuring this type child methods additive source code complexity.
            </summary>
            <remarks>
            <i><u>Types Cyclomatic Complexity code metric description:</u></i><br />
            Adapted to the Object-Oriented world, the <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> (CC) metric is also defined for classes and structures as the sum of its methods CC.<br /><br /><i><u>Availability:</u></i><br />
            A non-null numeric value is returned for types with methods where<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type has no method where <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> is available.<br /><i>null</i> if the PDB file of this type parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this type is written with a programming language different than C#.<br />
            Otherwise returns this type child methods additive source code complexity.<br />
            More information on this can be found at: <a href="https://www.ndepend.com/docs/ndepend-analysis-inputs-explanation" target="_blank">Understanding NDepend Analysis Inputs</a>
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.ILCyclomaticComplexity">
            <summary>
            Gets a numeric nullable value measuring this type child methods additive IL code complexity.
            </summary>
            <remarks>
            <i><u>Types IL Cyclomatic Complexity code metric description:</u></i><br />
            Adapted to the Object-Oriented world, the <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> (ILCC) metric is also defined for classes and structures as the sum of its methods ILCC.<br /><br /><i><u>Availability:</u></i><br />
            A non-null numeric value is returned for types with methods where <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> is available.<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type has no method with <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> available.<br />
            Otherwise returns this type child methods additive IL code complexity.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.SizeOfInst">
            <summary>
            Gets a numeric nullable value measuring this type's instance object footprint, measured in bytes.
            </summary>
            <remarks>
            <i><u>Size of Instance code metric description:</u></i><br /><i>SizeOfInst</i> for a class or a structure is defined as the sum of <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.SizeOfInst" /> values of its fields plus the size of instances of its base class.<br /><i>SizeOfInst</i> for a generic type might be erroneous because we cannot statically know the footprint of parameter types (except when they have the <i>class</i> constraint).<br /><i>SizeOfInst</i> for an enumeration is equal to the size of instances of the underlying numeric primitive type. It is computed from the enumeration's <i>value__</i> instance field (all enumerations have such a field when compiled in IL).<br /><i>SizeOfInst</i> for a static class or an interface is null.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where <i>SizeOfInst</i> is higher than 64 might degrade performance (depending on the number of instances created at runtime) and might be hard to maintain.<br />
            However this is not a rule since sometime there are no alternatives. For example, the <i>SizeOfInst</i> value for the <i>System.Net.NetworkInformation.SystemIcmpV6Statistics</i> .NET framework class is 2064 bytes.<br />
            Non-static and non-generic types where <i>SizeOfInst</i> is equal to 0 indicate stateless types that might eventually be turned into static classes.<br /><br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static or is an interface.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.DepthOfInheritance">
            <summary>
            Gets a numeric nullable value measuring this type's depth of inheritance.
            </summary>
            <remarks>
            The depth of inheritance for a class directly deriving from <i>System.Object</i> class is equal to 1.<br />
            The depth of inheritance for a structure is equal to 2 since it derives from <i>System.ValueType</i> that derives from <i>System.Object</i>.<br />
            The depth of inheritance for an enumeration is equal to 3 since it derives from <i>System.Enum</i> that derives from <i>System.ValueType</i> that derives from <i>System.Object</i>.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where <i>DepthOfInheritance</i> is higher or equal than 6 might be hard to maintain. However this is not a rule since sometime your classes might inherit from third-party classes that have a high depth of inheritance.<br />
            For example, the average depth of inheritance for .NET Framework classes that derive from <i>System.Windows.Forms.Control</i> is 5.3.<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static or is an interface.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.NbChildren">
            <summary>
            Gets a numeric nullable value counting this class's number of derived classes, or this interface number of implementer types.
            </summary>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static, is a structure or is an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.NbChildren" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.NbInterfacesImplemented">
            <summary>
            Gets a numeric value counting this class's number of implemented interfaces, or this interface number of extended interfaces.
            </summary>
            <remarks>
            For derived class, the sum of interfaces implemented by base class(es) is also counted.
            </remarks>
        </member>
        <member name="P:NDepend.CodeModel.IType.NbTypesUsed">
            <summary>
            Gets the number of types this type is using. Gets null if this type is declared in a third-party assembly.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.NbTypesUsingMe">
            <summary>
            Gets the number of types that use this type.
            </summary>
        </member>
        <member name="P:NDepend.CodeModel.IType.ABT">
            <summary>
            Gets the <i>Association Between Classes</i> for this type, computed as the number of members of others types it directly uses in the body of its child methods.
            </summary>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.ABT" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.Rank">
            <summary>
            Gets a numeric nullable value assessing this type rank, computed by the original <a href="http://www.sirgroane.net/google-page-rank/" target="_blank">Google Parge Rank</a> algorithm.
            </summary>
            <remarks>
            When discovering a legacy application, type ranking naturally sorts application types by an order of importance. Hence this code metric can help focusing on most relevant types first.<br />
            A homothety of center 0.15 is applied to make it so that the average of all application types.<i>Rank</i> is 1.<br /><br /><i><u>Recommendations:</u></i><br />
            Types with high rank should be more carefully tested because bugs in such types will likely be more catastrophic.<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.Rank" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.LCOM">
            <summary>
            Gets a numeric nullable value assessing the class members cohesion, through the standard <i>Lack of Cohesion Of Methods</i> code metric.
            </summary>
            <remarks>
            The single responsibility principle states that a class should not have more than one reason to change. Such a class is said to be cohesive.<br />
            A high LCOM value generally pinpoints a poorly cohesive class. There are two LCOM metrics.<br /><ul><li>The LCOM takes its values in the range [0-1].</li><li>The LCOM HS defined by <see cref="P:NDepend.CodeModel.IType.LCOMHS" /> (<i>HS</i> stands for <i>Henderson-Sellers</i>) takes its values in the range [0-2]. A LCOM HS value highest than 1 should be considered alarming.</li></ul>
            Here are algorithms used by NDepend to compute LCOM metrics:<br /><ul><li>LCOM = 1 - (sum(MF)/M*F)</li><li>LCOM HS = (M - sum(MF)/F)(M-1)</li></ul>
            Where:<br /><ul><li>M is the number of methods in class (both static and instance methods are counted, it includes also constructors, properties getters/setters, events add/remove methods).</li><li>F is the number of instance fields in the class.</li><li>MF is the number of methods of the class accessing a particular instance field.</li><li>Sum(MF) is the sum of MF over all instance fields of the class.</li></ul>
            The underlying idea behind these formulas can be stated as follow: a class is utterly cohesive if all its methods use all its instance fields, which means that sum(MF)=M*F and then LCOM = 0 and LCOMHS = 0.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where LCOM &gt; 0.8 and NbFields &gt; 10 and NbMethods &gt;10 might be problematic. However, it is difficult to avoid such non-cohesive types. <br />
            Types where LCOMHS &gt; 1.0 and NbFields &gt; 10 and NbMethods &gt;10 should be avoided. Note that this constraint is stronger (hence easier to satisfy) than the constraint types where LCOM &gt; 0.8 and NbFields &gt; 10 and NbMethods &gt;10.<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is an interface or an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.LCOM" /> numeric value.<br />
            </returns>
        </member>
        <member name="P:NDepend.CodeModel.IType.LCOMHS">
            <summary>
            Gets a numeric nullable value assessing the class members cohesion, through the standard <i>Lack of Cohesion Of Methods Henderson-Sellers</i> code metric.
            </summary>
            <remarks>
            See the <see cref="P:NDepend.CodeModel.IType.LCOM" /> code metric definition for detailled explanations on the <i>Lack of Cohesion Of Methods Henderson-Sellers</i> code metric.<br />
            </remarks>
            <returns>
            <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is an interface or an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.LCOMHS" /> numeric value.<br />
            </returns>
        </member>
        <member name="T:NDepend.CodeModel.IUsed">
            <summary>
            Represents a code element that can be used from another code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
            <seealso cref="T:NDepend.CodeModel.IUser" />
        </member>
        <member name="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns true if this code element is used by <paramref name="codeElementUser" />, otherwise returns false.
            </summary>
            <param name="codeElementUser">The code element that potentially uses this code element.</param>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
        </member>
        <member name="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)">
            <summary>
            Returns true if this code element is used by <paramref name="assemblyUser" />, otherwise returns false.
            </summary>
            <param name="assemblyUser">The assembly that potentially uses this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)">
            <summary>
            Returns true if this code element is used by <paramref name="namespaceUser" />, otherwise returns false.
            </summary>
            <param name="namespaceUser">The namespace that potentially uses this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)">
            <summary>
            Returns true if this code element is used by <paramref name="typeUser" />, otherwise returns false.
            </summary>
            <param name="typeUser">The type that potentially uses this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)">
            <summary>
            Returns true if this code element is used by <paramref name="methodUser" />, otherwise returns false.
            </summary>
            <param name="methodUser">The method that potentially uses this code element.</param>
        </member>
        <member name="T:NDepend.CodeModel.IUser">
            <summary>
            Represents a code element that can use another code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
            <seealso cref="T:NDepend.CodeModel.IUsed" />
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns true if this code element is used by <paramref name="codeElementUsed" />, otherwise returns false.
            </summary>
            <param name="codeElementUsed">The code element that is potentially used by this code element.</param>
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.Using``2(System.Collections.Generic.IEnumerable{``0},``1)" />
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)">
            <summary>
            Returns true if this code element is used by <paramref name="assemblyUsed" />, otherwise returns false.
            </summary>
            <param name="assemblyUsed">The assembly that is potentially used by this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)">
            <summary>
            Returns true if this code element is used by <paramref name="namespaceUsed" />, otherwise returns false.
            </summary>
            <param name="namespaceUsed">The namespace that is potentially used by this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)">
            <summary>
            Returns true if this code element is used by <paramref name="typeUsed" />, otherwise returns false.
            </summary>
            <param name="typeUsed">The type that is potentially used by this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)">
            <summary>
            Returns true if this code element is used by <paramref name="methodUsed" />, otherwise returns false.
            </summary>
            <param name="methodUsed">The method that is potentially used by this code element.</param>
        </member>
        <member name="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)">
            <summary>
            Returns true if this code element is used by <paramref name="fieldUsed" />, otherwise returns false.
            </summary>
            <param name="fieldUsed">The field that is potentially used by this code element.</param>
        </member>
        <member name="P:NDepend.CodeModel.IUser.Level">
            <summary>Gets a numeric nullable value indicating whether this assembly, namespace, type or method depends on a dependency cycle.</summary>
            <remarks>
            <i><u>Level code metric description:</u></i><br />
            The Level value for a namespace is defined as follow:<br />
            <ul>
            <li>Level = 0 : if the namespace doesn’t use any other namespace.</li>
            <li>Level = 1 : if the namespace only uses directly namespace defined in third-party assemblies.</li>
            <li>Level = 1 + (Max <i>Level</i> over namespace it uses direcly).</li>
            <li>Level = null : if the namespace is involved in a dependency cycle or uses directly or indirectly a namespace involved in a dependency cycle.</li>
            </ul>
            Level metric definitions for assemblies, types and methods are inferred from the above definition. This metric has been first defined by <i>John Lakos</i> in his book <a href="http://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620" target="_blank">Large-Scale C++ Software Design</a>.
            <br />
            <br />
            <i><u>Recommendations:</u></i>
            This metric helps objectively classify the assemblies, namespaces, types and methods as high level mid level or low level.<br /> 
            There is no particular recommendation for high or small values. This metric is also useful to discover dependency cycles in your application.<br /> 
            <br /> 
            </remarks>
        </member>
        <member name="T:NDepend.CodeModel.SourceFileLanguage">
            <summary>
            Represents the programming <see cref="P:NDepend.CodeModel.ISourceFile.Language" /> of a <see cref="T:NDepend.CodeModel.ISourceFile" /> object.
            </summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.Other">
            <summary>Other</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.CSharp">
            <summary>CSharp</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.VBNet">
            <summary>VBNet</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.Cpp">
            <summary>Cpp</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.Java">
            <summary>Java</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.Xaml">
            <summary>Xaml</summary>
        </member>
        <member name="F:NDepend.CodeModel.SourceFileLanguage.FSharp">
            <summary>FSharp</summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryCompiledUnresolved">
            <summary>
            Represents the result of a query compilation no matter whether it was a successful compilation or not, unresolved yet to a code base.
            </summary>
            <remarks>
             A code query can reference some code elements through string like in <i>from m in Methods where m.IsUsing("System.String")</i>.<br />
             The resolving step aims at resolving these code elements from a code-base or a compare-context.<br />
             The reason for having <i>IQueryCompiledUnresolved</i> is performance. It takes much more time to compile a query than to resolve it to a code-base.<br />
             With <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" />, the result of a compilation can be re-used on several code-base if needed.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledUnresolved.OriginalQueryString">
            <summary>
            Gets the original code query string. 
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IQueryCompiledUnresolved.Resolve(NDepend.CodeModel.ICodeBase)">
            <summary>
            Resolve this code query to <paramref name="codeBase" />.
            </summary>
            <param name="codeBase">The code base on which to resolve code elements referenced by this query compiled.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IQueryCompiledUnresolved.Resolve(NDepend.CodeModel.ICompareContext)">
            <summary>
            Resolve this code query to <paramref name="compareContext" />.
            </summary>
            <param name="compareContext">The compare context on which to resolve code elements referenced by this query compiled.</param>
        </member>
        <member name="T:NDepend.CodeQuery.KindOfCompletionItem">
            <summary>
            Represents the various completion item kind possible.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.NoSuggestions">
            <summary>NoSuggestions</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.Property">
            <summary>Property</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.MethodWithoutParameter">
            <summary>MethodWithoutParameter</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.MethodWithParameter">
            <summary>MethodWithParameter</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.Keyword">
            <summary>Keyword</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.DomainField">
            <summary>DomainField</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.Variable">
            <summary>Variable</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.ProposedVariableName">
            <summary>ProposedVariableName</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.Operator">
            <summary>Operator</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.SeveralKeywords">
            <summary>SeveralKeywords</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeInterface">
            <summary>TypeInterface</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeEnumeration">
            <summary>TypeEnumeration</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeStructure">
            <summary>TypeStructure</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeStructureGeneric">
            <summary>TypeStructureGeneric</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeClass">
            <summary>TypeClass</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeClassGeneric">
            <summary>TypeClassGeneric</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeDelegate">
            <summary>TypeDelegate</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCompletionItem.TypeDelegateGeneric">
            <summary>TypeDelegateGeneric</summary>
        </member>
        <member name="T:NDepend.CodeQuery.ICompletionItem">
            <summary>
            Represents a completion item returned by the method <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GenerateCompletionItems(System.String,System.Int32)" />.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.ICompletionItem.GetImage``1">
            <summary>
            Gets this completion item image.
            </summary>
            <typeparam name="T">So far the GetImage&lt;T&gt;() parameter type T must be System.Drawing.Image. This requirement might evolve in future version when other UI framework will be supported.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.ICompletionItem.GetImage``2(``1)">
            <summary>
            Gets this completion item image
            </summary>
            <remarks>This overload is for internal usage only because it lets a chance to pass a a theme object to obtain a themed image.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.ICompletionItem.Text">
            <summary>
            Gets this completion item text.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.ICompletionItem.DocumentationXml">
            <summary>
            Gets this completion item documentation?
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.ICompletionItem.Kind">
            <summary>
            Gets the kind of this completion item.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.ICompletionItem.Overloads">
            <summary>
            If this completion item is a method, gets the eventually overload of the method.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.ExtensionMethodsQuery">
            <summary>
            Exposes base operations concerning code query strings, compile and execute.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICodeBase)">
            <summary>
            Compile this code query string against a code base.
            </summary>
            <param name="queryString">This code query string.</param>
            <param name="codeBase">The code base against which to compile.</param>
            <remarks><paramref name="codeBase" /> is needed because this code query might reference some code elements by name.</remarks>
            <returns>The code query compiled.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)">
            <summary>
            Compile this code query string against a <see cref="T:NDepend.CodeModel.ICompareContext" /> object. This overload of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICodeBase)" /> is required if the code query is meant to be executed in a comparison context.
            </summary>
            <param name="queryString">This code query string.</param>
            <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which to compile.</param>
            <remarks>
            The <see cref="T:NDepend.CodeModel.ICompareContext" /> object is needed because the code query might reference some code elements by name.<br />
            In such situation, code elements are resolved by name against the code base <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.<br />
            The property <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" /> is equal to true if a code query is meant to be executed in a comparison context.
            </remarks>
            <returns>This code query compiled.</returns>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICodeBase)">
            <summary>
            Compile against a code base, several code queries contained in this collection of string.
            </summary>
            <param name="queryStrings">This collection of code queries string.</param>
            <param name="codeBase">The code base against which to compile each query.</param>
            <remarks>
            The <paramref name="codeBase" /> is needed because a code query might reference some code elements by name.<br />
            To compile <i>N</i> CQLinq queries strings, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>.
            </remarks>
            <returns>A read-only list of code queries compiled, with a count equals to <paramref name="queryStrings" />.Count.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)">
            <summary>
            Compile several code queries contained in this collection of string, against a <see cref="T:NDepend.CodeModel.ICompareContext" /> object. This overload of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICodeBase)" /> is required if some code queries are meant to be executed in a comparison context.
            </summary>
            <param name="queryStrings">This collection of code queries string.</param>
            <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which to compile.</param>
            <remarks>
            The <see cref="T:NDepend.CodeModel.ICompareContext" /> object is needed because some code queries might reference some code elements by name.<br />
            In such situation, code elements are resolved by name against the code base ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.<br />
            To compile <i>N</i> CQLinq queries strings, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>.<br />
            The property <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" /> is equal to true if a code query is meant to be executed in a comparison context.
            </remarks>
            <returns>A read-only list of code queries compiled, with a count equals to <paramref name="queryStrings" />.Count.</returns>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQuery},NDepend.CodeModel.ICodeBase)">
            <summary>
            Compile against a code base, several code queries.
            </summary>
            <param name="queries">This collection of code queries.</param>
            <param name="codeBase">The code base against which to compile each query.</param>
            <remarks>
            The <paramref name="codeBase" /> is needed because a code query might reference some code elements by name.<br />
            To compile <i>N</i> CQLinq queries, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>. 
            </remarks>
            <returns>A dictionary where keys are <see cref="T:NDepend.CodeQuery.IQuery" /> objects, and values are <see cref="T:NDepend.CodeQuery.IQueryCompiled" /> objects.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQuery},NDepend.CodeModel.ICompareContext)">
            <summary>
            Compile several code queries, against a <see cref="T:NDepend.CodeModel.ICompareContext" /> object. This overload of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQuery},NDepend.CodeModel.ICodeBase)" /> is required if some code queries are meant to be executed in a comparison context.
            </summary>
            <param name="queries">This collection of code queries.</param>
            <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which to compile.</param>
            <remarks>
            The <see cref="T:NDepend.CodeModel.ICompareContext" /> object is needed because some code queries might reference some code elements by name.<br />
            In such situation, code elements are resolved by name against the code base ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.<br />
            To compile <i>N</i> CQLinq queries, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>.<br />
            The property <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" /> is equal to true if a code query is meant to be executed in a comparison context.
            </remarks>
            <returns>A dictionary where keys are <see cref="T:NDepend.CodeQuery.IQuery" /> objects, and values are <see cref="T:NDepend.CodeQuery.IQueryCompiled" /> objects.</returns>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileNoResolve(System.String)">
            <summary>
            Compile this code query string with no resolving of code elements referenced by the code query.
            </summary>
            <param name="queryString">This code query string.</param>
            <returns>The code query compiled but unresolved.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileManyNoResolve(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compile several code queries contained in this collection of string, with no resolving of code elements referenced by the code queries.
            </summary>
            <param name="queryStrings">This collection of code queries string.</param>
            <returns>A read-only list of code queries compiled but unresolved, with a count equals to <paramref name="queryStrings" />.Count.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileManyNoResolve(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQuery})">
            <summary>
            Compile several code queries contained in this collection of <see cref="T:NDepend.CodeQuery.IQuery" /> objects, with no resolving of code elements referenced by the code queries.
            </summary>
            <param name="queries">This collection of code queries.</param>
            <returns>A dictionary where keys are <see cref="T:NDepend.CodeQuery.IQuery" /> objects, and values are <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" /> objects.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ResolveMany(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQueryCompiledUnresolved},NDepend.CodeModel.ICodeBase)">
            <summary>
            Resolve all query compiled of <paramref name="queriesCompiledUnresolved" /> to <paramref name="codeBase" />, by calling for each query compiled object, <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" />.<see cref="M:NDepend.CodeQuery.IQueryCompiledUnresolved.Resolve(NDepend.CodeModel.ICodeBase)" />.
            </summary>
            <param name="queriesCompiledUnresolved">The sequence of <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" /> objects.</param>
            <param name="codeBase">The code base on which to resolve code elements referenced by each query compiled.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ResolveMany(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IQueryCompiledUnresolved},NDepend.CodeModel.ICompareContext)">
            <summary>
            Resolve all query compiled of <paramref name="queriesCompiledUnresolved" /> to <paramref name="compareContext" />, by calling for each query compiled object, <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" />.<see cref="M:NDepend.CodeQuery.IQueryCompiledUnresolved.Resolve(NDepend.CodeModel.ICodeBase)" />.
            </summary>
            <param name="queriesCompiledUnresolved">The sequence of <see cref="T:NDepend.CodeQuery.IQueryCompiledUnresolved" /> objects.</param>
            <param name="compareContext">The compare context on which to resolve code elements referenced by each query compiled.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess)">
            <summary>
            Execute a code query compiled successfully.
            </summary>
            <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.<br />
            With this overload of <i>Execute</i>, just-my-code is the <see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /> specified at compile time.
            </remarks>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
            <returns>The query execution result.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView)">
            <summary>
            Execute this code query compiled successfully, with <paramref name="justMyCode" /> defined.
            </summary>
            <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.
            </remarks>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
            <param name="justMyCode">The code base view representing just-my-code, typically obtained through <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />.</param>
            <returns>The query execution result.</returns>
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,System.TimeSpan)">
            <summary>
            Execute his code query compiled successfully, with a time-out precised.
            </summary>
            <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.<br />
            With this overload of <i>Execute</i>, just-my-code is the <see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /> specified at compile time.
            </remarks>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
            <param name="cqlinqQueryExecTimeOut">The time-out duration activated only for CQLinq queries, CQL queries being executed in a bounded short time.</param>
            <returns>The query execution result.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView,System.TimeSpan)">
            <summary>
            Execute this code query compiled successfully, with <paramref name="justMyCode" /> defined and with a time out precised.
            </summary>
            <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.
            </remarks>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
            <param name="justMyCode">The code base view representing just-my-code, typically obtained through <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />.</param>
            <param name="cqlinqQueryExecTimeOut">The time-out duration activated only for CQLinq queries, CQL queries being executed in a bounded short time.</param>
            <returns>The query execution result.</returns>
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeQuery.QueryExecutionContext)">
            <summary>
            Execute the <paramref name="queryCompiledSuccess" /> with the <paramref name="queryExecutionContext" />.
            </summary>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
            <param name="queryExecutionContext">The query execution context that hold execution parameters.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ConvertToCQLinq(NDepend.CodeQuery.IQueryCompiledSuccess)">
            <summary>
            Convert this code query compiled successfully to a <i>CQLinq</i> query string. This method is useful to convert a query from the <i>CQL</i> syntax to the <i>CQLinq</i> syntax.
            </summary>
            <returns>
            A string containing the query converted to <i>CQLinq</i> syntax, if <paramref name="queryCompiledSuccess" /> is a <i>CQL</i> query compiled.<br />
            <paramref name="queryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />, if <paramref name="queryCompiledSuccess" /> is a <i>CQLinq</i> query compiled.
            </returns>
            <param name="queryCompiledSuccess">This code query compiled successfully.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetKindOfCodeQuerySyntax(System.String)">
            <summary>
            Determines this code query syntax, <i>CQLinq</i> or <i>CQL</i>, of a code query string.
            </summary>
            <remarks>
            An heuristic is used that determines the code query syntax of a code query string, even if the query is not compilable.
            </remarks>
            <param name="queryString">This code query string.</param>
            <returns>The code query syntax.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)">
            <summary>
            Computes and returns the set of <i>just-my-code</i> code elements from this <paramref name="groupOfGroups" /> <i>CQLinq</i> queries with a <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQueryExpression" /> equals to <see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode" />.
            </summary>
            <param name="groupOfGroups">This set of code queries.</param>
            <param name="codeBase">The code base.</param>
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView)" />
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetQueryName(System.String,System.String@)">
            <summary>
            Try extract the query name from a query string.
            </summary>
            <remarks>The query name, if any, is enclosed between the tags <i>&lt;Name&gt;</i> and <i>&lt;/Name&gt;</i> in a comment line in the query string.</remarks>
            <param name="queryString">The query string.</param>
            <param name="queryName">The query name extracted</param>
            <returns><i>true</i> if the query name has been extracted, else returns <i>false</i>.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetQueryIdAndExplicitId(System.String,System.String@,System.String@)">
            <summary>
            Try extract the query id and explicit-id from a query string.
            </summary>
            <remarks>The query name, if any, is enclosed between the tags <i>&lt;Id&gt;</i> and <i>&lt;/Id&gt;</i> in a comment line in the query string.</remarks>
            <param name="queryString">The query string.</param>
            <param name="id">The query id extracted</param>
            <param name="explicitId">The query explicit-id extracted</param>
            <returns><i>true</i> if the id and explicit-id name has been extracted, else returns <i>false</i>.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetQueryDescription(System.String,NDepend.Helpers.StringFormattingKind,System.String@)">
            <summary>
            Try extract the query description from a query string.
            </summary>
            <remarks>The query description, if any, is enclosed between the tags <i>&lt;Desc&gt;</i> and <i>&lt;/Desc&gt;</i>, or <i>&lt;Description&gt;</i> and <i>&lt;/Description&gt;</i>, in one or several consecutive comment line(s) in the query string.</remarks>
            <param name="queryString">The query string.</param>
            <param name="stringFormattingKind">The string formatting kind of the output string.</param>
            <param name="queryDescription">The query description extracted.</param>
            <returns><i>true</i> if the query description has been extracted, else returns <i>false</i>.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetRuleHowToFix(System.String,NDepend.Helpers.StringFormattingKind,System.String@)">
            <summary>
            Try extract the how-to-fix-rule explanations from a rule string.
            </summary>
            <remarks>The how-to-fix-rule explanations, if any, is enclosed between the tags <i>&lt;HowToFix&gt;</i> and <i>&lt;/HowToFix&gt;</i>.</remarks>
            <param name="ruleString">The rule string.</param>
            <param name="stringFormattingKind">The string formatting kind of the output string.</param>
            <param name="ruleHowToFix">The how-to-fix-rule explanations extracted from the rule string.</param>
            <returns><i>true</i> if the how-to-fix-rule explanations has been extracted, else returns <i>false</i>.</returns>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.IsActiveAndAllParentGroupActive(NDepend.CodeQuery.IQuery)">
            <summary>
            Returns <i>true</i> if this <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> is <i>true</i>, and all its parents' groups (recursive) are also active.
            </summary>
            <remarks>A query is visible in the report only if it is active and all its parents groups are also active.</remarks>
            <param name="query">The query object</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.IsActiveAndAllParentGroupActive(NDepend.CodeQuery.IGroup)">
            <summary>
            Returns <i>true</i> if this <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> is <i>true</i>, and all its parents' groups (recursive) are also active.
            </summary>
            <param name="group">The group object</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetCQLinqExecutionTimeOut">
            <summary>
            Get the CQLinq rules and queries execution time-out defined in Tools &gt; Options &gt; CodeQuery &gt; Time-Out.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GenerateCompletionItems(System.String,System.Int32)">
            <summary>
            Compute a list of <see cref="T:NDepend.CodeQuery.ICompletionItem" /> objects, from <paramref name="queryString" /> and <paramref name="carretLocation" />.
            </summary>
            <param name="queryString">The query string.</param>
            <param name="carretLocation">The carret location.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetRule(NDepend.CodeQuery.IQuery)">
            <summary>
            Gets a <see cref="T:NDepend.Issue.IRule" /> object from a <see cref="T:NDepend.CodeQuery.IQuery" /> object.
            </summary>
            <remarks>
            The returned rule <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Provider" /> equals <see cref="T:NDepend.Issue.RuleProvider" />.<see cref="F:NDepend.Issue.RuleProvider.CodeQueryRule" /><br />
            The returned rule <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.IsCritical" /> equals <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IQuery.IsCriticalRule" />.<br />
            These <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" /> methods are used for <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Name" />, <see cref="T:NDepend.Issue.IRule" />.<see cref="M:NDepend.Issue.IRule.TryGetDescription(NDepend.Helpers.StringFormattingKind,System.String@)" /> and <see cref="T:NDepend.Issue.IRule" />.<see cref="M:NDepend.Issue.IRule.TryGetHowToFix(NDepend.Helpers.StringFormattingKind,System.String@)" />.<br />
            - <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetQueryName(System.String,System.String@)" /> (if fails, the gets the first 60 char of the code query string.<br />
            - <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetQueryDescription(System.String,NDepend.Helpers.StringFormattingKind,System.String@)" />.<br />
            - <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.TryGetRuleHowToFix(System.String,NDepend.Helpers.StringFormattingKind,System.String@)" />.<br />
            </remarks>
            <param name="query">The code query from which the rule object is inferred.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)">
            <summary>
            Gets issues of <paramref name="rule" /> from <paramref name="queryExecutionSuccessResult" />.
            </summary>
            <remarks>
            This overload doesn't take a collection of usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            As a consequence <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" /> won't be filled.
            <br />
            This methods calls <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord)" /> with the value <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.No" />.
            <br />
            A rule prefix can be <i>warnif count == 0</i> which means that the value of <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.IsRuleViolated" /> of the returned <see cref="T:NDepend.Issue.IRuleIssues" /> can be <i>true</i> even if <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty.
            However if <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> is <i>false</i>, <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty even if the rule has some match.<br />
            <br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object used to infer <i>default</i> values for debt and annual-interest (if these evalues are not provided by <paramref name="queryExecutionSuccessResult" />).
            and used to provide thresholds to compute <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Severity" />, is the <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object 
            that was set in <see cref="T:NDepend.CodeQuery.QueryExecutionContext" />.<see cref="P:NDepend.CodeQuery.QueryExecutionContext.DebtSettings" />.<br />
            </remarks>
            <param name="rule">The issues built rule, that can be obtained from <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Rule" />.</param>
            <param name="queryExecutionSuccessResult">The query execution success result from which issues are inferred.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord)">
            <summary>
            Gets issues of <paramref name="rule" /> from <paramref name="queryExecutionSuccessResult" />.
            </summary>
            <remarks>
            This overload doesn't take a collection of usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            As a consequence <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" /> won't be filled.
            <br />
            A rule prefix can be <i>warnif count == 0</i> which means that the value of <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.IsRuleViolated" /> of the returned <see cref="T:NDepend.Issue.IRuleIssues" /> can be <i>true</i> even if <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty.
            However if <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> is <i>false</i>, <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty even if the rule has some match.<br />
            <br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object used to infer <i>default</i> values for debt and annual-interest (if these evalues are not provided by <paramref name="queryExecutionSuccessResult" />).
            and used to provide thresholds to compute <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Severity" />, is the <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object 
            that was set in <see cref="T:NDepend.CodeQuery.QueryExecutionContext" />.<see cref="P:NDepend.CodeQuery.QueryExecutionContext.DebtSettings" />.<br />
            </remarks>
            <param name="rule">The issues built rule, that can be obtained from <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Rule" />.</param>
            <param name="queryExecutionSuccessResult">The query execution success result from which issues are inferred.</param>
            <param name="issueReferenceRecord">
            If this parameter value equals <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.Yes" />, 
            each issue in the returned <see cref="T:NDepend.Issue.IRuleIssues" /> object will reference 
            will reference its corresponding record in <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />,
            through <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Record" />.
            </param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,System.Collections.Generic.IDictionary{NDepend.Issue.RuleIdOrCategory,System.Collections.Generic.IReadOnlyList{NDepend.Issue.ISuppressMessage}})">
            <summary>
            Gets issues of <paramref name="rule" /> from <paramref name="queryExecutionSuccessResult" />.
            </summary>
            <remarks>
            This methods calls <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord)" /> with the value <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.No" />.
            <br />
            A rule prefix can be <i>warnif count == 0</i> which means that the value of <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.IsRuleViolated" /> of the returned <see cref="T:NDepend.Issue.IRuleIssues" /> can be <i>true</i> even if <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty.
            However if <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> is <i>false</i>, <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty even if the rule has some match.<br />
            <br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object used to infer <i>default</i> values for debt and annual-interest (if these evalues are not provided by <paramref name="queryExecutionSuccessResult" />).
            and used to provide thresholds to compute <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Severity" />, is the <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object 
            that was set in <see cref="T:NDepend.CodeQuery.QueryExecutionContext" />.<see cref="P:NDepend.CodeQuery.QueryExecutionContext.DebtSettings" />.<br />
            Calling this method might modify the <paramref name="queryExecutionSuccessResult" /> object because of suppressed issues.
            If some issues are suppressed, the following properties might return a different result after calling this method:
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" />,
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements" />,
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.
            In such case you can find the suppressed issues in the result <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" />.
            </remarks>
            <param name="rule">The issues built rule, that can be obtained from <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Rule" />.</param>
            <param name="queryExecutionSuccessResult">The query execution success result from which issues are inferred.</param>
            <param name="suppressedMessages">The usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> collection used to infer <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" /></param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord,System.Collections.Generic.IDictionary{NDepend.Issue.RuleIdOrCategory,System.Collections.Generic.IReadOnlyList{NDepend.Issue.ISuppressMessage}})">
            <summary>
            Gets issues of <paramref name="rule" /> from <paramref name="queryExecutionSuccessResult" />.
            </summary>
            <remarks>
            A rule prefix can be <i>warnif count == 0</i> which means that the value of <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.IsRuleViolated" /> of the returned <see cref="T:NDepend.Issue.IRuleIssues" /> can be <i>true</i> even if <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty.
            However if <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> is <i>false</i>, <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> is empty even if the rule has some match.<br />
            <br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object used to infer <i>default</i> values for debt and annual-interest (if these evalues are not provided by <paramref name="queryExecutionSuccessResult" />).
            and used to provide thresholds to compute <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Severity" />, is the <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object 
            that was set in <see cref="T:NDepend.CodeQuery.QueryExecutionContext" />.<see cref="P:NDepend.CodeQuery.QueryExecutionContext.DebtSettings" />.<br />
            Calling this method might modify the <paramref name="queryExecutionSuccessResult" /> object because of suppressed issues.
            If some issues are suppressed, the following properties might return a different result after calling this method:
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" />,
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements" />,
            <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.
            In such case you can find the suppressed issues in the result <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" />.
            </remarks>
            <param name="rule">The issues built rule, that can be obtained from <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Rule" />.</param>
            <param name="queryExecutionSuccessResult">The query execution success result from which issues are inferred.</param>
            <param name="issueReferenceRecord">
            If this parameter value equals <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.Yes" />, 
            each issue in the returned <see cref="T:NDepend.Issue.IRuleIssues" /> object will reference 
            will reference its corresponding record in <paramref name="queryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />,
            through <see cref="T:NDepend.Issue.IIssue" />.<see cref="P:NDepend.Issue.IIssue.Record" />.
            </param>
            <param name="suppressedMessages">The usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> collection used to infer <see cref="T:NDepend.Issue.IRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" /></param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetQualityGate(NDepend.CodeQuery.IQueryExecutionSuccessResult)">
            <summary>
            Gets a <see cref="T:NDepend.Issue.IQualityGate" /> object from <paramref name="queryExecutionSuccessResult" />.
            </summary>
            <param name="queryExecutionSuccessResult">The query execution success result from which the <see cref="T:NDepend.Issue.IQualityGate" /> obejct is inferred.</param>
        </member>
        <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ExportQueryResult(NDepend.CodeQuery.IQueryExecutionResult,NDepend.CodeQuery.QueryResultExportDocumentKind,NDepend.CodeQuery.QueryResultExportFlags,NDepend.CodeQuery.IQuery,NDepend.TechnicalDebt.IDebtFormatter,System.String)">
            <summary>
            Export this <paramref name="queryExecutionResult"/> to a document.
            </summary>
            <returns>The document content formatted as a string.</returns>
            <param name="queryExecutionResult">This result to export.</param>
            <param name="exportDocumentKind">The kind of document that will contain the exported result.</param>
            <param name="flags">Can be set to determine the query result export properties.</param>
            <param name="query">Optional: <i>null</i> or the original <see cref="T:NDepend.CodeQuery.IQuery">IQuery</see> object to refine the exported result with information like if it's a critical rule or not.</param>
            <param name="debtFormatter">Optional: <i>null</i> or can be set to format technical-debt values to human-readable object, like man-months string or money amount.</param>
            <param name="descriptionString">Optional: <i>null</i> or can be set to prefix the result with a description string.</param>
        </member>
        <member name="T:NDepend.CodeQuery.IControllerChild">
            <summary>
            All query related objects, <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" /> and <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />, are children of a <see cref="T:NDepend.CodeQuery.IController" /> object and implement this interface.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IControllerChild.Controller">
            <summary>
            Get the parent <see cref="T:NDepend.CodeQuery.IController" /> object.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryExecutionResult">
            <summary>
            Represents a code query execution result. To compile a code query string and then execute it, use a <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionResult.OriginalQueryString">
            <summary>
            Gets the query string compiled and then executed to obtain this execution result.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionResult.Status">
            <summary>
            Gets a value indicating the status of this query execution result, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Success" />, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Exception" /> if an exception was thrown by the query execution, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut" /> if the query execution timed out.
            </summary>
            <remarks>
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Success" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> is not <i>null</i> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> is <i>null</i>.<br />
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Exception" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> is <i>null</i> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> is not <i>null</i>.<br />
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> are both <i>null</i>.<br />
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult">
            <summary>
            Gets the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object if <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" /> is <i>true</i>, else gets <i>null</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionResult.Exception">
            <summary>
            Gets the exception object thrown by the query execution if any, else gets <i>null</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionResult.ExecutionDuration">
            <summary>
            Gets the query execution duration.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.QueryPersistenceKind">
            <summary>
            Represent how the queries are stored in XML project files and XML rule files.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryPersistenceKind.PersistOnlyQueryIdForUntouchedQueries">
            <summary>
            Persist only a query Id and retrieve the default query text for this Id at load time.
            </summary>
            <remarks>
            When a query text has been edited, the entire text is persisted to avoid losing any customization. <br />
            The advantage of this persistence kind is twofold:
            Not only project files and rule files are much smaller but also query gets updated with latest changes.
            </remarks>
        </member>
        <member name="F:NDepend.CodeQuery.QueryPersistenceKind.PersistAllQueriesAsPlainText">
            <summary>
            Persist query plain text, no matter if it corresponds to a default query or not.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryPersistenceKind.Default">
            <summary>
            The default value is PersistOnlyQueryId.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.QueryResultExportFlags">
            <summary>
            Flags to determine a query result export operation properties.
            </summary>
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ExportQueryResult(NDepend.CodeQuery.IQueryExecutionResult,NDepend.CodeQuery.QueryResultExportDocumentKind,NDepend.CodeQuery.QueryResultExportFlags,NDepend.CodeQuery.IQuery,NDepend.TechnicalDebt.IDebtFormatter,System.String)"/>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.None">
            <summary>
            The value with no flag set.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.UnfoldMultiItemsCell">
            <summary>
            When this flag is set, cells of the query result that contain several items, like several code elements or several issues, are unfold in the result document.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.PrefixCodeElementsName">
            <summary>
            Prefix code elements with A: for assemblies, N: for namespaces, T: for types, M: for methods and F: for fields.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.UnfoldTheFirstNItemsOnly">
            <summary>
            When this flag is set with the flag <see cref="F:NDepend.CodeQuery.QueryResultExportFlags.UnfoldMultiItemsCell"/> set as well, only the first 10 items are unfolded. This flag is used in when building the report to limit its size.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.AllowBreakLongLine">
            <summary>Allow breaking long lines</summary>
            <remarks>This flag is only used internally when building the report.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.ShowCodeQuery">
            <summary>
            When this flag is set, the query string is shown in the result document.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.ShowStatistics">
            <summary>
            When this flag is set, the query result statistics is shown after the result.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.LinkElementToSourceFile">
            <summary>
            When the source file declaration(s) of a code element has been resolved at analysis time, with this flag set it is possible to get a link to this declaration for each occurrence of the code element in the report.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.LinkElementToRelativeSourceFile">
            <summary>
            When this flag is set, links to source file declarations in the report are paths relative to the report file location.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.DontShowTooManyCodeRulesMatchedItems">
            <summary>
            This flag is used when exporting the query result to report. It is set when <see cref="T:NDepend.Project.ReportOptionsFlags" />.<see cref="F:NDepend.Project.ReportOptionsFlags.DontShowTooManyCodeRulesMatchedItems" /> is set.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.ShowRows">
            <summary>
            This flag is used when exporting the query result to report. It is set when <see cref="T:NDepend.CodeQuery.IQuery" />.<see cref="P:NDepend.CodeQuery.IQuery.DisplayListInReport" /> is set.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.RequiredForExport">
            <summary>
            Minimum set of flags required by the export feature.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportFlags.DefaultForExport">
            <summary>
            Default value for QueryResultExportFlags when exporting result.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.QueryResultExportDocumentKind">
            <summary>
            Define the kinds of document a query execution result can be exported to through the extension method <see name="ExtensionMethodsQuery.ExportQueryResult" />.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.HTML">
            <summary>Use this value to export a query execution result to an HTML document.</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.Excel">
            <summary>Use this value to export a query execution result to an Excel document.</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.XML">
            <summary>Use this value to export a query execution result to an XML document.</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.Text">
            <summary>Use this value to export a query execution result to a textual document.</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.CSV">
            <summary>Use this value to export a query execution result to a CSV document.</summary>
            <remarks>The resulting CSV document uses the comma character as a separator.
             Your system settings might specify the semicolon character for CSV separator.
             In such situation, the resulting CSV file can still be opened with Excel because its first line specifies the separator character this way:  sep=,  
            </remarks>
        </member>
        <member name="F:NDepend.CodeQuery.QueryResultExportDocumentKind.JSON">
            <summary>Use this value to export a query execution result to a JSON document.</summary>
        </member>
        <member name="T:NDepend.CodeQuery.QueryExecutionContext">
            <summary>
            This class hold the context to execute a code query.
            </summary>
            <remarks>
            The minimal context to provide to execute a code query is the <see cref="P:NDepend.CodeQuery.QueryExecutionContext.CodeBase" />.<br />
            Others parameters of the context are optional.<br />
            An instance of <see cref="T:NDepend.CodeQuery.QueryExecutionContext" /> is meant to be used with the extension method <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeQuery.QueryExecutionContext)" />.
            </remarks>
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeQuery.QueryExecutionContext)" />
        </member>
        <member name="M:NDepend.CodeQuery.QueryExecutionContext.#ctor(NDepend.CodeModel.ICodeBase)">
            <summary>
            The constructor of this class, with the unique mandatory parameter that is the code base on which the query will be executed.
            </summary>
            <param name="codeBase"></param>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.CodeBase">
            <summary>
            The <see cref="T:NDepend.CodeModel.ICodeBase" /> object, against which the code query(ies) will be executed.
            </summary>
            <remarks>
            This code-base parameter is set in the constructor and is then immutable.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.JustMyCode">
            <summary>
            Get or set the code-base-view representing just-my-code, typically obtained through <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />.
            </summary>
            <remarks>
            If the code-base-view representing just-my-code is not set through the setter, this.<see name="QueryExecutionContext.CodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /> is returned by the getter.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.IssuesSet">
            <summary>
            Get or set the <seealso cref="T:NDepend.Issue.IIssuesSet" /> object used by code query that <seealso cref="T:NDepend.CodeQuery.QueryRelyOn" />.<seealso cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSet" />.
            </summary>
            <remarks>
            By default, an empty <seealso cref="T:NDepend.Issue.IIssuesSet" /> object bound to this <seealso cref="P:NDepend.CodeQuery.QueryExecutionContext.CodeBase" /> is returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.IssuesSetDiff">
            <summary>
            Get or set the <seealso cref="T:NDepend.Issue.IIssuesSetDiff" /> object used by code query that <seealso cref="T:NDepend.CodeQuery.QueryRelyOn" />.<seealso cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSetDiff" />.
            </summary>
            <remarks>
            By default, an empty <seealso cref="T:NDepend.Issue.IIssuesSetDiff" /> object bound to this <seealso cref="P:NDepend.CodeQuery.QueryExecutionContext.CodeBase" /> is returned.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.CQLinqQueryExecTimeOut">
            <summary>
            Get or set the time-out duration activated only for CQLinq queries, CQL queries being executed in a bounded short time
            </summary>
            <remarks>
            A null value for this property means that no time-out will be applied.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.QueryExecutionContext.DebtSettings">
            <summary>
            Get or set the debt-settings that will be applied to query-execution.
            </summary>
            <remarks>
            <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> parameters that will be used are: <br />
            - <see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtFactor" /><br />
            - <see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtDefault" /><br />
            - <see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestFactor" /><br />
            - <see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestDefault" /><br />
            These parameters are only used in case the code query is a code rule.
            </remarks>
        </member>
        <member name="T:NDepend.CodeQuery.QueryExecutionResultException">
            <summary>
            This exception is used in rare situations where the code query result cannot be handled properly.
            </summary>
            <remarks>
            So far such exception is onyl raised when a code query matches a <seealso cref="T:NDepend.CodeModel.ICodeBase" /> object because this case is not handled.
            </remarks>
        </member>
        <member name="T:NDepend.CodeQuery.QueryExecutionStatus">
            <summary>
            Define the <see cref="T:NDepend.CodeQuery.IQueryExecutionResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" />.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryExecutionStatus.Success">
            <summary>Success</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryExecutionStatus.Exception">
            <summary>Exception</summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut">
            <summary>TimeOut</summary>
        </member>
        <member name="T:NDepend.CodeQuery.QueryRelyOn">
            <summary>
            Represents various artifacts on which a code query can rely on.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.Nothing">
            <summary>
            Indicates that the query doesn't rely on any artifact.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.CompareContext">
            <summary>
            Indicates whether the code query relies on a <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.CodeCoverage">
            <summary>
            Indicates whether this code query relies on the code coverage data.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.JustMyCode">
            <summary>
            Indicates whether this code query relies on the <i>JustMyCode</i> set.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnJustMyCode" />
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.IssuesSet">
            <summary>
            Indicates whether this code query relies on <see cref="T:NDepend.Issue.IIssuesSet" />.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnIssuesSet" />
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.IssuesSetDiff">
            <summary>
            Indicates whether this code query relies on <see cref="T:NDepend.Issue.IIssuesSetDiff" />.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnIssuesSetDiff" />
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.QualityGates">
            <summary>
            Indicates whether this code query relies on quality gate any-way.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnQualityGates" /> 
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.Diff">
            <summary>
            Indicates whether this code query relies on <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.CompareContext" /> or on <see cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSetDiff" />.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.QueryRelyOn.Issues">
            <summary>
            Indicates whether this code query relies on <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSet" /> or on <see cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSetDiff" />.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IController">
            <summary>
            Changes to a hierarchy of code query objects are made through an instance of <see cref="T:NDepend.CodeQuery.IController" />.
            </summary>
            <remarks>
            The interfaces <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" /> and <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> implement the interface <see cref="T:NDepend.CodeQuery.IControllerChild" />, because they all depend from a <see cref="T:NDepend.CodeQuery.IController" /> object.<br />
            A hierarchy of queries can be gathered from <see cref="T:NDepend.Project.IProjectCodeQueries" />.<see cref="P:NDepend.Project.IProjectCodeQueries.CodeQueriesSet" /> or <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IController.RootParent">
            <summary>
            Gets the root parent on which the controller does changes.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CreateQuery(System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create a new query object.
            </summary>
            <param name="isActive">The new query activation.</param>
            <param name="queryString">The query string.</param>
            <param name="displayStatInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements are listed into the report.</param>
            <param name="displayListInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements statistics are shown into the report.</param>
            <param name="displaySelectionViewInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.</param>
            <param name="isCriticalRule">A boolean value that indicates whether the code rule is critical or not.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CreateGroup(System.String,System.Boolean,System.Boolean,System.Collections.Generic.ICollection{NDepend.CodeQuery.IQuery},System.Collections.Generic.ICollection{NDepend.CodeQuery.IGroup})">
            <summary>
            Creates a new group object.
            </summary>
            <param name="name">The group name.</param>
            <param name="isActive">The group activation.</param>
            <param name="shownInReport">A boolean value that indicates whether all child rules and queries of this group are shown in report. In Queries Explorer panel, such group is highlighted in a orange box.</param>
            <param name="childQueries">A collection of child queries.</param>
            <param name="childGroups">A collection of child groups.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanChangeGroupName(NDepend.CodeQuery.IGroup,System.String@)">
            <summary>Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.Name" /> can be changed.</summary>
            <param name="group">The group on which to change the name.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its name cannot be changed.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanSetGroupName(NDepend.CodeQuery.IGroup,System.String,System.String@)">
            <summary>Gets a value indicating whether <paramref name="group" /> name can be changed to <paramref name="newName" />.</summary>
            <param name="group">The group on which to change the name.</param>
            <param name="newName">The new name to assign to the group.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>
            An empty <paramref name="newName" /> is not accepted and if another group already has the name <paramref name="newName" />, it is not accepted neither.
            </remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoChangeGroupName(NDepend.CodeQuery.IGroup,System.String)">
            <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.Name" /> to <paramref name="newName" />.</summary>
            <param name="group">The group on which to change the name.</param>
            <param name="newName">The new name to assign to the group.</param>
            <returns>The new group object with the new name.</returns>
            <exception cref="T:System.ArgumentException">
            Can't perform the group renaming operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanSetGroupName(NDepend.CodeQuery.IGroup,System.String,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanChangeGroupActivation(NDepend.CodeQuery.IGroup,System.String@)">
            <summary>
            Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> can be changed.
            </summary>
            <param name="group">The group on which to change the activation.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its activation cannot be changed.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoChangeGroupActivation(NDepend.CodeQuery.IGroup,System.Boolean)">
            <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" />  to <paramref name="active" />.</summary>
            <param name="group">The group on which to change the name.</param>
            <param name="active">The new activation boolean state of the group.</param>
            <returns>The new group object with the activation boolean state.</returns>
            <exception cref="T:System.ArgumentException">
            Can't perform the group activation changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeGroupActivation(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.String@)">
            <summary>
            Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> can be changed.
            </summary>
            <param name="group">The group on which to change the flag <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" />.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its value <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> cannot be changed.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.Boolean)">
            <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> to <paramref name="shownInReport" />.</summary>
            <param name="group">The group on which to change the flag <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" />.</param>
            <param name="shownInReport">The new <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> boolean state of the group.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the group flag changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanChangeQueryActivation(NDepend.CodeQuery.IQuery,System.String@)">
            <summary>
            Gets a value indicating whether <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> can be changed.
            </summary>
            <param name="query">The query on which to change the activation.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If query.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its activation cannot be changed.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoChangeQueryActivation(NDepend.CodeQuery.IQuery,System.Boolean)">
            <summary>Change <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> to <paramref name="active" />.</summary>
            <param name="query">The query on which to change the name.</param>
            <param name="active">The new activation boolean state of the query.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the query activation changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeQueryActivation(NDepend.CodeQuery.IQuery,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoUpdateQueryObject(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IQuery)">
            <summary>Update <paramref name="oldQuery" /> object with <paramref name="newQuery" /> object.</summary>
            <param name="oldQuery">The old object representing the query.</param>
            <param name="newQuery">The new object representing the query.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the query update operation on these arguments.<br />
            The exception message contains a plain-english description of the problem.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)">
            <summary>
            Gets a value indicating whether a group can be inserted under <paramref name="setParent" />.
            </summary>
            <param name="setParent">The parent set under which a group might be inserted.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If setParent.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> a group cannot be inserted under it.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoInsertGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroupOfGroups,System.Int32)">
            <summary>Insert <paramref name="groupToInsert" /> under <paramref name="oldSetParent" />.</summary>
            <param name="groupToInsert">The group to insert.</param>
            <param name="oldSetParent">The parent set under which the group is inserted.</param>
            <param name="index">The index in <paramref name="oldSetParent" /> children groups, at which <paramref name="groupToInsert" /> is inserted.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="oldSetParent" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)" /> before calling this method.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> must be a positive or zero integer, lower or equals to <paramref name="oldSetParent" />.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoAddGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroupOfGroups)">
            <summary>Add <paramref name="groupToAdd" /> under <paramref name="oldSetParent" />.</summary>
            <param name="groupToAdd">The group to add.</param>
            <param name="oldSetParent">The parent set under which the group is added.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="oldSetParent" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)" /> before calling this method.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="oldSetParent" /> doesn't have <i>this</i> as controller.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanDeleteGroup(NDepend.CodeQuery.IGroup,System.String@)">
            <summary>Gets a value indicating whether <paramref name="groupToDelete" /> can be deleted.</summary>
            <param name="groupToDelete">The group to delete.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If groupToDelete.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" />, the group cannot be deleted.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.AskUserForGroupDeletion(NDepend.CodeQuery.IGroup,System.IntPtr,NDepend.Helpers.SoundPlayerState)">
             <summary>Ask the user through a dialog, if he really wishes to delete <paramref name="groupToDelete" />.</summary>
             <returns>true if the user wishes to delete the group, otherwise returns false.</returns>
             <param name="groupToDelete">The group to delete.</param>
             <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="soundPlayerState">Determine if a ding is played when showing the dialog.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoDeleteGroup(NDepend.CodeQuery.IGroup)">
            <summary>Do delete <paramref name="groupToDelete" />.</summary>
            <param name="groupToDelete">The group to delete.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the deletion operation on these arguments.<br />
            Please check <paramref name="groupToDelete" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanDeleteGroup(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanDeleteQuery(NDepend.CodeQuery.IQuery,System.String@)">
            <summary>Gets a value indicating whether <paramref name="queryToDelete" /> can be deleted.</summary>
            <param name="queryToDelete">The query to delete.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If queryToDelete.<see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />, the query cannot be deleted.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.AskUserForQueryDeletion(NDepend.CodeQuery.IQuery,System.IntPtr,NDepend.Helpers.SoundPlayerState)">
            <summary>Ask the user through a dialog, if he really wishes to delete <paramref name="queryToDelete" />.</summary>
            <returns>true if the user wishes to delete the query, otherwise returns false.</returns>
            <param name="queryToDelete">The query to delete.</param>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="soundPlayerState">Determine if a ding is played when showing the dialog.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoDeleteQuery(NDepend.CodeQuery.IQuery)">
            <summary>Do delete <paramref name="queryToDelete" />.</summary>
            <param name="queryToDelete">The query to delete.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the deletion operation on these arguments.<br />
            Please check <paramref name="queryToDelete" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanDeleteQuery(NDepend.CodeQuery.IQuery,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)">
            <summary>
            Gets a value indicating whether a query can be inserted under <paramref name="groupParent" />.
            </summary>
            <param name="groupParent">The parent group under which a query might be inserted.</param>
            <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
            <remarks>If <paramref name="groupParent" />.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> a query cannot be inserted under it.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoInsertQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IGroup,System.Int32)">
            <summary>Insert <paramref name="queryToInsert" /> under <paramref name="groupParentOldObj" />.</summary>
            <param name="queryToInsert">The query to insert.</param>
            <param name="groupParentOldObj">The parent group under which the query is inserted.</param>
            <param name="index">The index in <paramref name="groupParentOldObj" /> children queries, at which <paramref name="queryToInsert" /> is inserted.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="queryToInsert" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> must be a positive or zero integer, lower or equals to <paramref name="groupParentOldObj" />.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IController.DoAddQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IGroup)">
            <summary>Add <paramref name="queryToAdd" /> under <paramref name="groupParentOldObj" />.</summary>
            <param name="queryToAdd">The query to add.</param>
            <param name="groupParentOldObj">The group under which the query is added.</param>
            <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="queryToAdd" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
        </member>
        <member name="T:NDepend.CodeQuery.IGroup">
            <summary>
            Represents a group of code queries and groups. A <see cref="T:NDepend.CodeQuery.IGroup" /> object can be created with the method <see cref="T:NDepend.CodeQuery.IController" />.<see cref="M:NDepend.CodeQuery.IController.CreateGroup(System.String,System.Boolean,System.Boolean,System.Collections.Generic.ICollection{NDepend.CodeQuery.IQuery},System.Collections.Generic.ICollection{NDepend.CodeQuery.IGroup})" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.Parent">
            <summary>
            Gets the parent group. Returns null if the group has no parent group.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.Name">
            <summary>
            Gets this group name.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.SetName(System.String)">
            <summary>Set the group name to <paramref name="newName" />.</summary>
            <param name="newName">The new group name.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.IsActive">
            <summary>
            Gets a value indicating whether this group is activated.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.SetIsActive(System.Boolean)">
            <summary>Set the group activation to <paramref name="newIsActive" />.</summary>
            <param name="newIsActive">The new group activation.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.ShownInReport">
            <summary>
            Gets a value indicating whether this group's child queries are shown in report, in a dedicated section.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.SetShownInReport(System.Boolean)">
            <summary>Set the group <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> state to <paramref name="newShownInReport" />.</summary>
            <param name="newShownInReport">The new group <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> state.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode">
            <summary>
            Gets a value indicating whether this group has been created for queries extracted from code, with the attribute <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
            <remarks>
            When this.IsExtractedFromCode is true, the group name is the namespace that contains the code elements tagged with <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.<br />
            For anonymous namespace,  the group name is the parent assembly name that contains the code elements tagged with <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </remarks>
            <seealso cref="T:NDepend.Attributes.CodeRuleAttribute" />
            <see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.ChildQueries">
            <summary>Gets a cloned read-only list of child queries.</summary>
            <remarks>The list returned is a clone. Hence it doesn't reflect any modification in the original collection.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroup.ChildQueriesCount">
            <summary>Gets the child queries count.</summary>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.ContainsQuery(NDepend.CodeQuery.IQuery)">
            <summary>Gets a value indicating whether this group contains <paramref name="query" />.</summary>
            <param name="query">The query to locate in this <see cref="T:NDepend.CodeQuery.IGroup" />.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.GetQueryAt(System.Int32)">
            <summary>
            Returns the query at the <paramref name="index" /> position in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.
            </summary>
            <param name="index">The index position.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> must be a positive or zero integer, strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.IndexOfQuery(NDepend.CodeQuery.IQuery)">
            <summary>
            Determines the index of a specific query in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.
            </summary>
            <remarks>If this group of groups doesn't contain <paramref name="query" />, the value -1 is returned.</remarks>
            <param name="query">The query to locate in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.AddQuery(NDepend.CodeQuery.IQuery)">
            <summary>
            Add <paramref name="queryToAdd" /> to this group child queries.
            </summary>
            <param name="queryToAdd">The query to add.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="queryToAdd" /> doesn't have <i>this</i> as controller.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.RemoveQuery(NDepend.CodeQuery.IQuery)">
            <summary>
            Remove <paramref name="queryToRemove" /> to this group child queries.
            </summary>
            <param name="queryToRemove">The query to remove.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
            <exception cref="T:System.ArgumentException">This group muts contain <paramref name="queryToRemove" />.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.ReplaceQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IQuery)">
            <summary>
            Replace <paramref name="queryToReplace" /> with <paramref name="newQuery" />.
            </summary>
            <param name="queryToReplace">The query to replace.</param>
            <param name="newQuery">The query that replaces <paramref name="queryToReplace" />.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="queryToReplace" /> must be a child query of this group and <paramref name="newQuery" /> must not be a child query of this group.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="newQuery" /> doesn't have <i>this</i> as controller.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.MoveQueryToIndex(System.Int32,NDepend.CodeQuery.IQuery)">
            <summary>
            Move <paramref name="queryToMove" /> to the position specified by <paramref name="index" />.
            </summary>
            <param name="index">The new <paramref name="queryToMove" /> position under this group child queries.</param>
            <param name="queryToMove">The query to move.</param>
            <returns>The new group object representing this group.</returns>
            <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> must be a positive or zero integer, and <paramref name="index" /> must be strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="queryToMove" /> must be a child query of this group.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroup.CloneDeep(NDepend.CodeQuery.IController)">
            <summary>
            Clone this group and all its child groups and child queries recursively, through <paramref name="controller" />.
            </summary>
            <param name="controller">The queries controller used for cloning.</param>
            <returns>This group cloned.</returns>
        </member>
        <member name="T:NDepend.CodeQuery.IGroupOfGroups">
            <summary>
            Represents a group of groups. <see cref="T:NDepend.CodeQuery.IGroup" /> implements <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> since it is both a group of groups and also, a group of queries.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.RootParent">
            <summary>
            Gets the root parent. Returns this if this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.IsRootParent" />. Returns null if the group of groups has no root parent. 
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.IsRootParent">
            <summary>Gets a value indicating whether this group of groups is a root parent.</summary>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups">
            <summary>Gets a read-only list of child groups.</summary>
            <remarks>The list returned is a clone. Hence it doesn't reflect any modification in the original collection.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount">
            <summary>Gets the child groups count.</summary>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.ContainsGroup(NDepend.CodeQuery.IGroup)">
            <summary>Gets a value indicating whether this group of groups contains <paramref name="group" />.</summary>
            <param name="group">The group to locate in this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.GetGroupAt(System.Int32)">
            <summary>
            Returns the group at the <paramref name="index" /> position in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.
            </summary>
            <param name="index">The index position.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> must be a positive or zero integer, strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.IndexOfGroup(NDepend.CodeQuery.IGroup)">
            <summary>
            Determines the index of a specific group in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.
            </summary>
            <remarks>If this group of groups doesn't contain <paramref name="group" />, the value -1 is returned.</remarks>
            <param name="group">The group to locate in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.</param>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.AllQueriesRecursive">
            <summary>
            Gets all queries under this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />, and also under child groups, recursively.
            </summary>
            <remarks>The list returned is a clone. Hence it doesn't reflect any modification in the original collection.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IGroupOfGroups.AllGroupsRecursive">
            <summary>
            Gets all groups under this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />, and also under child groups, recursively.
            </summary>
            <remarks>The list returned is a clone. Hence it doesn't reflect any modification in the original collection.</remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.AddGroup(NDepend.CodeQuery.IGroup)">
            <summary>
            Add <paramref name="groupToAdd" /> to this group of groups children.
            </summary>
            <param name="groupToAdd">The group to add.</param>
            <returns>The new group of groups object representing this group of groups.</returns>
            <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="groupToAdd" /> must be different than this group of groups, or doesn't have the same controller.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.RemoveGroup(NDepend.CodeQuery.IGroup)">
            <summary>
            Remove <paramref name="groupToRemove" /> from this group of groups children.
            </summary>
            <param name="groupToRemove">The group to remove.</param>
            <returns>The new group of groups object representing this group of groups.</returns>
            <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="groupToRemove" /> must be different than this group of groups.<br />
            Also, this group of groups must contain <paramref name="groupToRemove" />.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.ReplaceGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroup)">
            <summary>
            Replace <paramref name="groupToReplace" /> with <paramref name="newGroup" />.
            </summary>
            <param name="groupToReplace">The group to replace.</param>
            <param name="newGroup">The group that replaces <paramref name="groupToReplace" />.</param>
            <returns>The new group of groups object representing this group of groups.</returns>
            <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="groupToReplace" /> and <paramref name="newGroup" /> must both be different than this group of groups.<br />
            Also <paramref name="groupToReplace" /> must be a child group of this group of groups and <paramref name="newGroup" /> must not be a child group of this group of groups.<br />
            Also <paramref name="newGroup" /> must have the same controller as <i>this</i>.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.MoveGroupToIndex(System.Int32,NDepend.CodeQuery.IGroup)">
            <summary>
            Move <paramref name="groupToMove" /> to the position specified by <paramref name="index" />.
            </summary>
            <param name="index">The new <paramref name="groupToMove" /> position under this group of groups child groups.</param>
            <param name="groupToMove">The group to move.</param>
            <returns>The new group of groups object representing this group of groups.</returns>
            <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> must be a positive or zero integer, and <paramref name="index" /> must be strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="groupToMove" /> must be different than this group of groups.<br />
            Also <paramref name="groupToMove" /> must be a child group of this group of groups.
            </exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.AddRange(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IGroup})">
            <summary>
            Add a sequence of groups to this group of groups children.
            </summary>
            <param name="groups">The sequence of groups to add.</param>
            <returns>The new group of groups object representing this group of groups.</returns>
            <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
            <remarks>If <paramref name="groups" /> contains some group that already have this group of groups for parent, the algorithm don't add them a second time.</remarks>
            <exception cref="T:System.ArgumentException">A group in <paramref name="groups" /> doesn't have the same controller as <i>this</i>.</exception>
        </member>
        <member name="M:NDepend.CodeQuery.IGroupOfGroups.CloneDeep(NDepend.CodeQuery.IController)">
            <summary>
            Clone this group of groups and all its child groups and child queries recursively, through <paramref name="controller" />.
            </summary>
            <param name="controller">The queries controller used for cloning.</param>
            <returns>This group of groups cloned.</returns>
        </member>
        <member name="T:NDepend.CodeQuery.IQuery">
            <summary>
            Represents a code query. A <see cref="T:NDepend.CodeQuery.IQuery" /> object can be created with the method <see cref="T:NDepend.CodeQuery.IController" />.<see cref="M:NDepend.CodeQuery.IController.CreateQuery(System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.Parent">
            <summary>
            Gets the parent group. Returns null if the query has no parent group.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.RootParent">
            <summary>
            Gets the root parent. Returns null if the query has no root parent.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.IQuery.EqualsTo(NDepend.CodeQuery.IQuery)">
            <summary>
            Returns <i>true</i> if this query and <paramref name="queryToCompareWith" /> have same value for <see cref="P:NDepend.CodeQuery.IQuery.QueryString" />, <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayListInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayStatInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.IsCriticalRule" />.
            </summary>
            <remarks><see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" /> is not taken account for this equality operation.</remarks>
            <param name="queryToCompareWith">The query to compare with.</param>
        </member>
        <member name="M:NDepend.CodeQuery.IQuery.Clone(NDepend.CodeQuery.IController)">
            <summary>
            Returns a new query where values for <see cref="P:NDepend.CodeQuery.IQuery.QueryString" />, <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayListInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayStatInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.IsCriticalRule" /> have been cloned, through <paramref name="controller" />.
            </summary>
            <param name="controller">The queries controller used for cloning.</param>
            <remarks>The state <see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" /> is not cloned.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.IsActive">
            <summary>
            Gets a value that indicates whether the query is active.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:NDepend.CodeQuery.IQuery.SetIsActive(System.Boolean)">
            <summary>
            Returns a new <see cref="T:NDepend.CodeQuery.IQuery" /> object cloned from this object, where <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> value is set to <paramref name="isActive" />, if this value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> is different than <paramref name="isActive" />. Otherwise returns this <see cref="T:NDepend.CodeQuery.IQuery" />.
            </summary>
            <param name="isActive">The new value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />.</param>
            <remarks>
            The default value is true.<br /> 
            Since the queries hierarchy is an immutable hierarchical structure, this methods changes the hierarchy of objects if this value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> is different than <paramref name="isActive" />.
            </remarks>
            <returns>The new query object representing this query.</returns>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode">
            <summary>
            Gets a value that indicates whether the query has been extracted from code.
            </summary>
            <remarks>
            A code query can be extracted from code thanks to <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </remarks>
            <seealso cref="T:NDepend.Attributes.CodeRuleAttribute" />
            <see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" />
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.DisplayListInReport">
            <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements are listed into the report.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.DisplayStatInReport">
            <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements statistics are shown into the report.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport">
            <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.
            </summary>
            <remarks>
            The default value is false.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.IsCriticalRule">
            <summary>
            Gets a value that indicates whether the code rule is critical or not.
            </summary>
            <remarks>
            The default value is false.<br />
            A critical code rule is useful to break the build process once the rule is violated.<br />
            More information at: <a href="https://www.ndepend.com/docs/critical-cqlinq-rule">Critical Rules and Build Failure</a>
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQuery.QueryString">
            <summary>
            Gets the CQLinq or CQL code rule string or query string.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryCompilationError">
            <summary>
            Represents a query compilation error.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompilationError.Description">
            <summary>
            Gets the description of the error.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompilationError.SubStringStartPos">
            <summary>
            Gets the start position of the error highlight in the string <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompilationError.SubStringLength">
            <summary>
            Gets the length of the error highlight in the string <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryCompiled">
            <summary>
            Represents the result of a query compilation no matter whether it was a successful compilation or not.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString">
            <summary>
            Gets the original code query string. 
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQuerySyntax">
            <summary>
            Gets the kind of code query syntax.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQueryExpression">
            <summary>
            Gets the kind of code query expression.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.HasErrors">
            <summary>
            Gets a value indicating whether the code query has been compiled successfully or not.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.QueryCompiledSuccess">
            <summary>
            Gets this object casted as a <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" /> object if the code query has been compiled successfully, else gets null.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiled.QueryCompiledError">
            <summary>
            Gets this object casted as a <see cref="T:NDepend.CodeQuery.IQueryCompiledError" /> object if the code query hasn't been compiled successfully, else gets null.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryCompiledError">
            <summary>
            Represents the result of a query compilation that failed.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledError.Errors">
            <summary>
            Gets a cloned array of errors.
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryCompiledSuccess">
            <summary>
            Represents the result of a query that has been compiled successfully.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.CodeBaseOnWhichToExecute">
            <summary>
            Gets the code base on which the code query has been compiled against.
            </summary>
            <remarks>
            If the query has been compiled in a comparison context, the returned code base is ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.CompareContextOnWhichToExecute">
            <summary>
            Gets the <see cref="T:NDepend.CodeModel.ICompareContext" /> object on which the code query has been compiled against. Gets <i>null</i> if the code query has been compiled against a code base.
            </summary>
            <remarks>
            If the query has been compiled in a comparison context, the returned code base is ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext">
            <summary>
            Gets a value indicating whether this code query relies on a <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
            <remarks>
            The returned value is independant from the fact that <see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.CompareContextOnWhichToExecute" /> is null or not.<br />
            A code query that relies on a compare context and that is executed without a compare context won't return a useful result.<br />
            In such situation, at query runtime an empty <see cref="T:NDepend.CodeModel.ICompareContext" /> object is provided, that returns null or false for all properties.
            </remarks>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.CompareContext" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnJustMyCode">
            <summary>
            Gets a value indicating whether this code query relies on the <i>JustMyCode</i> set.
            </summary>
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.JustMyCode" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData">
            <summary>
            Gets a value indicating whether this code query relies on the code coverage data.
            </summary>
            <remarks>
            Code coverage data is deemed to be used if the query use any of this property getter: <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />, <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" /> or <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.CodeCoverage" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnIssuesSet">
            <summary>
            Gets a value indicating whether this code query relies on <see cref="T:NDepend.Issue.IIssuesSet" />.
            </summary>
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSet" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnIssuesSetDiff">
            <summary>
            Gets a value indicating whether this code query relies on <see cref="T:NDepend.Issue.IIssuesSetDiff" />.
            </summary>
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.IssuesSetDiff" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnQualityGates">
            <summary>
            Gets a value indicating whether this code query relies on quality gates.
            </summary>
            <seealso cref="F:NDepend.CodeQuery.QueryRelyOn.QualityGates" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOn">
            <summary>
            Gets a value that indicates on which artifacts this query relies on.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.KindOfMatch">
            <summary>
            Gets the kind of code element matched, 
            <see cref="F:NDepend.CodeQuery.RecordCellType.Method" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Field" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Type" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Namespace" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Assembly" />, 
            <see cref="F:NDepend.CodeQuery.RecordCellType.CodeElement" />, <see cref="F:NDepend.CodeQuery.RecordCellType.CodeElementParent" />, <see cref="F:NDepend.CodeQuery.RecordCellType.CodeContainer" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Member" />, 
            or <see cref="F:NDepend.CodeQuery.RecordCellType.NullableDouble" /> if the result will be a single scalar (<see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" />).
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.IQueryExecutionSuccessResult">
            <summary>
            Represents a code query successful execution result. Such an object is obtained from a <see cref="T:NDepend.CodeQuery.IQueryExecutionResult" /> with <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" /> equals to <i>true</i>.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.CodeBaseOnWhichQueryHasBeenExecuted">
            <summary>
            Gets the code base on which the code query has been executed.
            </summary>
            <remarks>
            If the query has been executed in a comparison context, the returned code base is <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.CompareContextOnWhichQueryHasBeenExecuted" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.CompareContextOnWhichQueryHasBeenExecuted">
            <summary>
            Gets the <see cref="T:NDepend.CodeModel.ICompareContext" /> object on which the code query has been executed, or <i>null</i> if the query hasen't been executed agains a compare context but only agains a code base.
            </summary>
            <remarks>
            Returns the same object than <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.CompareContextOnWhichToExecute" />, or <i>null</i> if this property returns <i>null</i>.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.OriginalQueryString">
            <summary>
            Gets the original code query string.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated">
            <summary>
            Gets a value indicating whether the code query is a rule and is violated.
            </summary>
             <remarks>
             <i>this</i>.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.KindOfCodeQueryExpression" /> returns <see cref="T:NDepend.CodeQuery.KindOfCodeQueryExpression" />.<see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.Rule" /> if this code query is a code rule.
             Notice that a <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object can be modified when calling 
             a <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" /> overload
             that takes a <i>suppressedMessage</i> set. In such condition if all issues are suppressed
             this property can return <i>false</i> although it was returning <i>true</i> before calling <i>GetIssues()</i>.
             </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.QualityGateStatus">
            <summary>
            If this code query is a Quality Gate gets the status, else returns <see cref="T:NDepend.Issue.QualityGateStatus" />.<see cref="F:NDepend.Issue.QualityGateStatus.Pass" />.
            </summary>
            <remarks>
            <i>this</i>.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.KindOfCodeQueryExpression" /> returns <see cref="T:NDepend.CodeQuery.KindOfCodeQueryExpression" />.<see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.QualityGate" /> if this code query is a quality gate.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.KindOfCodeQueryExpression">
            <summary>
            Gets the kind of code query expression.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records">
            <summary>
            Gets records result.
            </summary>
            <remarks>
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, the collection returned is empty.<br />
             Notice that a <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object can be modified when calling 
             a <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" /> overload
             that takes a <i>suppressedMessage</i> set. In such condition the list of records returned 
             can be different than the one returned before calling <i>GetIssues()</i>.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.KindOfMatch">
            <summary>
            Gets a <see cref="T:NDepend.CodeQuery.RecordCellType" /> that indicates which kind of code element is matched.
            </summary>
            <remarks>
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, the value <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.NullableDouble" /> is returned.
            Else the value return is in the range: 
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Assembly" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Namespace" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Type" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Method" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Field" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.Member" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.CodeElement" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.CodeElementParent" />
            <see cref="T:NDepend.CodeQuery.RecordCellType" />.<see cref="F:NDepend.CodeQuery.RecordCellType.CodeContainer" />
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult">
            <summary>
            Gets a value indicating whether the code query returned a single scalar result.
            </summary>
            <remarks>
            Only CQLinq queries can return a scalar result through aggregation operators like Count() or Sum().<br />
            In such case <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> is an empty collection.
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.SingleScalarValue">
            <summary>
            Gets the single scalar result returned by the query.
            </summary>
            <remarks>
            Only CQLinq queries can return a scalar result through aggregation operators like Count() or Sum().<br />
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is false, this property returns null.<br />
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, this property might returns null if the CQLinq aggregation operation returned null.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements">
            <summary>
            Gets code elements referenced in the query itself, like the code element named "XYZ" in "from t in Types where t.IsUsing("XYZ") select t".
            </summary>
            <remarks>
            If a wildcard match expression is used, like "X*YZ" instead of "XYZ", the returned collection contains all matched code elements.<br />
            Targets code elements can be matched by following extension methods declared in <see cref="N:NDepend.Reserved.CQLinq" />.<see cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency" />:<br />
             <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByAssembly(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByNamespace(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByType(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByMethod(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <br />
             <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingAssembly(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingNamespace(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingType(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingMethod(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingField(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />, <br />
             <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />, <br />
             <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />  
            </remarks>
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements">
            <summary>
            Gets a collection of code elements matched by the code query. If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is <i>true</i> or if the query is matching issues or rules, gets an empty collection.
            </summary>
            <remarks>
            This method is a facility to avoid extracting matched code elements from this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> first column.<br />
            This extension method has a <i>O(this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.Count)</i> time complexity.<br />
             Notice that a <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object can be modified when calling 
             a <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" /> overload
             that takes a <i>suppressedMessage</i> set. In such condition the list of code-elements returned 
             can be different than the one returned before calling <i>GetIssues()</i>.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedIssues">
            <summary>
            Gets a collection of <see cref="T:NDepend.Issue.IIssue" /> matched by the code query. If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is <i>true</i> or if the query is matching code elements or rules or quality gates, gets an empty collection.
            </summary>
            <remarks>
            This method is a facility to avoid extracting matched issues from this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> first column.<br />
            This extension method has a <i>O(this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedRules">
            <summary>
            Gets a collection of <see cref="T:NDepend.Issue.IRule" /> matched by the code query. If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is <i>true</i> or if the query is matching code elements or issues or quality gates, gets an empty collection.
            </summary>
            <remarks>
            This method is a facility to avoid extracting matched rules from this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> first column.<br />
            This extension method has a <i>O(this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedQualityGates">
            <summary>
            Gets a collection of <see cref="T:NDepend.Issue.IQualityGate" /> matched by the code query. If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is <i>true</i> or if the query is matching code elements or issues or rules, gets an empty collection.
            </summary>
            <remarks>
            This method is a facility to avoid extracting matched quality gates from this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> first column.<br />
            This extension method has a <i>O(this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.Count)</i> time complexity.
            </remarks>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.ColumnsNames">
            <summary>
            Returns columns' names of the result records.
            </summary>
            <remarks>
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, the returned array contains one string "Value".
            </remarks>
            <seealso cref="P:NDepend.Issue.IIssue.ColumnsNames" />
        </member>
        <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Description">
            <summary>
            Returns a brief description of the result, such as "12 methods matched" or "Single scalar result : 2 match".
            </summary>
        </member>
        <member name="T:NDepend.CodeQuery.KindOfCodeQueryExpression">
            <summary>
            Identifies the kind of code query expression.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.SyntaxError">
            <summary>SyntaxError</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.Query">
            <summary>Query</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.Rule">
            <summary>Rule</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode">
            <summary>NotMyCode</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.TrendMetric">
            <summary>TrendMetric</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.QualityGate">
            <summary>QualityGate</summary>
        </member>
        <member name="T:NDepend.CodeQuery.KindOfCodeQuerySyntax">
            <summary>
            Defines a code query syntax, CQLinq or CQL.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQuerySyntax.CQLinq">
            <summary>CQLinq</summary>
        </member>
        <member name="F:NDepend.CodeQuery.KindOfCodeQuerySyntax.CQL">
            <summary>CQL</summary>
        </member>
        <member name="T:NDepend.CodeQuery.RecordCellType">
            <summary>
            Represents the type of the object <see cref="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue" />.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Unknow">
            <summary>Unknow</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Method">
            <summary>Method</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Field">
            <summary>Field</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Type">
            <summary>Type</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Namespace">
            <summary>Namespace</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Assembly">
            <summary>Assembly</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Methods">
            <summary>Methods</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Fields">
            <summary>Fields</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Types">
            <summary>Types</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Namespaces">
            <summary>Namespaces</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Assemblies">
            <summary>Assemblies</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeElement">
            <summary>CodeElement</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeElementParent">
            <summary>CodeElementParent</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeContainer">
            <summary>CodeContainer</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Member">
            <summary>Member</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.AttributeTarget">
            <summary>AttributeTarget</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeElements">
            <summary>CodeElements</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeElementParents">
            <summary>CodeElementParents</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.CodeContainers">
            <summary>CodeContainers</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Members">
            <summary>Members</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.AttributeTargets">
            <summary>AttributeTargets</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Visibility">
            <summary>Visibility</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableVisibility">
            <summary>NullableVisibility</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Debt">
            <summary>Debt</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableDebt">
            <summary>NullableDebt</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.AnnualInterest">
            <summary>AnnualInterest</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableAnnualInterest">
            <summary>NullableAnnualInterest</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Severity">
            <summary>Severity</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableSeverity">
            <summary>NullableSeverity</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.DebtRating">
            <summary>DebtRating</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableDebtRating">
            <summary>NullableDebtRating</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.TrendIcon">
            <summary>TrendIcon</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableTrendIcon">
            <summary>TrendIconNullable</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Issue">
            <summary>Issue</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Issues">
            <summary>Issues</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Rule">
            <summary>Issue</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Rules">
            <summary>Issues</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.QualityGate">
            <summary>QualityGate</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.QualityGates">
            <summary>QualityGates</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.QualityGateStatus">
            <summary>QualityGateStatus</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableQualityGateStatus">
            <summary>NullableQualityGateStatus</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.String">
            <summary>String</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Version">
            <summary>Version</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.TimeSpan">
            <summary>TimeSpan</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableTimeSpan">
            <summary>NullableTimeSpan</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Bool">
            <summary>Bool</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableBool">
            <summary>NullableBool</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Byte">
            <summary>Byte</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableByte">
            <summary>NullableByte</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.SByte">
            <summary>SByte</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableSByte">
            <summary>NullableSByte</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Short">
            <summary>Short</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableShort">
            <summary>NullableShort</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.UShort">
            <summary>UShort</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableUShort">
            <summary>NullableUShort</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Int">
            <summary>Int</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableInt">
            <summary>NullableInt</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.UInt">
            <summary>UInt</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableUInt">
            <summary>NullableUInt</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Long">
            <summary>Long</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableLong">
            <summary>NullableLong</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.ULong">
            <summary>ULong</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableULong">
            <summary>NullableULong</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Float">
            <summary>Float</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableFloat">
            <summary>NullableFloat</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Double">
            <summary>Double</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableDouble">
            <summary>NullableDouble</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.Decimal">
            <summary>Decimal</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.NullableDecimal">
            <summary>NullableDecimal</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.IAbsoluteFilePath">
            <summary>IAbsoluteFilePath</summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellType.IAbsoluteDirectoryPath">
            <summary>IAbsoluteDirectoryPath</summary>
        </member>
        <member name="T:NDepend.CodeQuery.RecordCellValue">
            <summary>
            Represents a code query result record cell value.
            </summary>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue">
            <summary>
            This read-only field represents an untyped object that must be down-casted in order to be used.
            </summary>
            <remarks>
            This field has no property getter for optimization reason.
            </remarks>
        </member>
        <member name="F:NDepend.CodeQuery.RecordCellValue.m_RecordCellType">
            <summary>
            This read-only field represents the type of the object <see cref="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue" />, through the enumeration <see cref="T:NDepend.CodeQuery.RecordCellType" />.
            </summary>
            <remarks>
            This field has no property getter for optimization reason.
            </remarks>
        </member>
        <member name="T:NDepend.CodeQuery.RecordBase">
            <summary>
            The base class for all records classes. A code query result is represented through a sequence of record objects.
            </summary>
            <remarks>
            Having a base class for all records classes is convenient since a code query result is made of a IEnumerable$gt;<see cref="T:NDepend.CodeQuery.RecordBase" />$lt;
            </remarks>
        </member>
        <member name="F:NDepend.CodeQuery.RecordBase.MAX_ARITY">
            <summary>
            Maximum record arity is fixed to 16, meaning a code query cannot returns records with more than 16 cells.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.RecordBase.RecordArity">
            <summary>
            Returns this record class number of cells, from one to 16 cells, this limit is defined by <see cref="F:NDepend.CodeQuery.RecordBase.MAX_ARITY" />.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.RecordBase.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, this.<see cref="P:NDepend.CodeQuery.RecordBase.RecordArity" /> - 1]</exception>
        </member>
        <member name="M:NDepend.CodeQuery.RecordBase.CreateBrotherInstance(System.Object[])">
            <summary>
            Create a new instance of the same record class as this record, initialized from the array <paramref name="parameters" />.
            </summary>
            <remarks>
            The method <see cref="M:NDepend.CodeQuery.RecordBase.CreateBrotherInstance(System.Object[])" /> is faster than using System.Activator.CreateInstance(T, parameters).
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameters" /> is a null array reference.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="parameters" />.Length is not equals to this.<see cref="P:NDepend.CodeQuery.RecordBase.RecordArity" />.</exception>
            <exception cref="T:System.InvalidCastException"><paramref name="parameters" /> has one or several elements not typed exactly as this record class <see cref="F:NDepend.CodeQuery.RecordBase.MAX_ARITY" /> generic parameters types.</exception>
        </member>
        <member name="F:NDepend.CodeQuery.RecordBase.RecordTypes">
            <summary>
            This read-only field contains <see cref="F:NDepend.CodeQuery.RecordBase.MAX_ARITY" /> System.Type objects representing the <see cref="F:NDepend.CodeQuery.RecordBase.MAX_ARITY" /> record generic classes.
            </summary>
        </member>
        <member name="M:NDepend.CodeQuery.RecordBase.AlreadyAccessed(System.Int32)">
            <summary>
            Don't use this method, it is a private implementation detail.
            </summary>
            <param name="index">Private implementation detail.</param>
        </member>
        <member name="T:NDepend.CodeQuery.Record`1">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 1 cell each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`1.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`1" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`1.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`1.RecordArity">
            <summary>
            Returns this record class number of cells, which is 1.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`1.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 0]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`2">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 2 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`2.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`2" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`2.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`2.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`2.RecordArity">
            <summary>
            Returns this record class number of cells, which is 2.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`2.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 1]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`3">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 3 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`3.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`3" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`3.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`3.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`3.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`3.RecordArity">
            <summary>
            Returns this record class number of cells, which is 3.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`3.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 2]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`4">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 4 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`4.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`4" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`4.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`4.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`4.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`4.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`4.RecordArity">
            <summary>
            Returns this record class number of cells, which is 4.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`4.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 3]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`5">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 5 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`5.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`5" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`5.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`5.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`5.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`5.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`5.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`5.RecordArity">
            <summary>
            Returns this record class number of cells, which is 5.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`5.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 4]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`6">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 6 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`6.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`6" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`6.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`6.RecordArity">
            <summary>
            Returns this record class number of cells, which is 6.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`6.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 5]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`7">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 7 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`7.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`7" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`7.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`7.RecordArity">
            <summary>
            Returns this record class number of cells, which is 7.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`7.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 6]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`8">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 8 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`8.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`8" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`8.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`8.RecordArity">
            <summary>
            Returns this record class number of cells, which is 8.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`8.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 7]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`9">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 9 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`9.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`9" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`9.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`9.RecordArity">
            <summary>
            Returns this record class number of cells, which is 9.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`9.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 8]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`10">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 10 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`10.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`10" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`10.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`10.RecordArity">
            <summary>
            Returns this record class number of cells, which is 10.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`10.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 9]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`11">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 11 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`11.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`11" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`11.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`11.RecordArity">
            <summary>
            Returns this record class number of cells, which is 11.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`11.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 10]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`12">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 12 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
            <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`12.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`12" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`12.m_P11">
            <summary>This represents the record' cell' value of at index 11.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`12.RecordArity">
            <summary>
            Returns this record class number of cells, which is 12.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`12.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 11]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`13">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 13 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
            <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
            <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`13.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`13" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P11">
            <summary>This represents the record' cell' value of at index 11.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`13.m_P12">
            <summary>This represents the record' cell' value of at index 12.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`13.RecordArity">
            <summary>
            Returns this record class number of cells, which is 13.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`13.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 12]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`14">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 14 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
            <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
            <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
            <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`14.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`14" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P11">
            <summary>This represents the record' cell' value of at index 11.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P12">
            <summary>This represents the record' cell' value of at index 12.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`14.m_P13">
            <summary>This represents the record' cell' value of at index 13.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`14.RecordArity">
            <summary>
            Returns this record class number of cells, which is 14.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`14.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 13]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`15">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 15 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
            <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
            <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
            <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
            <typeparam name="T14">The type parameter of the cell at index 14.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`15.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`15" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P11">
            <summary>This represents the record' cell' value of at index 11.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P12">
            <summary>This represents the record' cell' value of at index 12.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P13">
            <summary>This represents the record' cell' value of at index 13.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`15.m_P14">
            <summary>This represents the record' cell' value of at index 14.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`15.RecordArity">
            <summary>
            Returns this record class number of cells, which is 15.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`15.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 14]</exception>
        </member>
        <member name="T:NDepend.CodeQuery.Record`16">
            <summary>
            The record generic class used for code query results made of sequence of records objects with 16 cells each.
            </summary>
            <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
            <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
            <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
            <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
            <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
            <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
            <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
            <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
            <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
            <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
            <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
            <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
            <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
            <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
            <typeparam name="T14">The type parameter of the cell at index 14.</typeparam>
            <typeparam name="T15">The type parameter of the cell at index 15.</typeparam>
        </member>
        <member name="M:NDepend.CodeQuery.Record`16.#ctor">
            <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`16" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P0">
            <summary>This read-only field represents the record' cell' value of at index 0.</summary> <remarks>This field has no property getter for optimization reason.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P1">
            <summary>This represents the record' cell' value of at index 1.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P2">
            <summary>This represents the record' cell' value of at index 2.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P3">
            <summary>This represents the record' cell' value of at index 3.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P4">
            <summary>This represents the record' cell' value of at index 4.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P5">
            <summary>This represents the record' cell' value of at index 5.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P6">
            <summary>This represents the record' cell' value of at index 6.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P7">
            <summary>This represents the record' cell' value of at index 7.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P8">
            <summary>This represents the record' cell' value of at index 8.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P9">
            <summary>This represents the record' cell' value of at index 9.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P10">
            <summary>This represents the record' cell' value of at index 10.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P11">
            <summary>This represents the record' cell' value of at index 11.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P12">
            <summary>This represents the record' cell' value of at index 12.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P13">
            <summary>This represents the record' cell' value of at index 13.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P14">
            <summary>This represents the record' cell' value of at index 14.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="F:NDepend.CodeQuery.Record`16.m_P15">
            <summary>This represents the record' cell' value of at index 15.</summary> 
            <remarks>This field has no property getter for optimization reason.<br />It is not read-only because when accessing it through <see cref="T:NDepend.CodeQuery.RecordCellValue" />, a sequence is getting transformed into an array and the array is assigned to this field.</remarks>
        </member>
        <member name="P:NDepend.CodeQuery.Record`16.RecordArity">
            <summary>
            Returns this record class number of cells, which is 16.
            </summary>
        </member>
        <member name="P:NDepend.CodeQuery.Record`16.Item(System.Int32)">
            <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is not in the range [0, 15]</exception>
        </member>
        <member name="T:NDepend.DotNet.DotNetRuntimeKind">
            <summary>
            Enumeration to describe actual .NET Runtime Kind
            </summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetRuntimeKind.NetFx">
            <summary>
            .NET Framework v4.x on Windows
            </summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetRuntimeKind.NetCore">
            <summary>
            .NET Core, .NET 5, .NET 6... on Windows, Linux or Mac OS
            </summary>
        </member>
        <member name="T:NDepend.DotNet.DotNetRuntime">
            <summary>
            This class let access the current .NET runtime kind.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.DotNetRuntime.Kind">
            <summary>
            The current .NET runtime kind.
            </summary>
        </member>
        <member name="M:NDepend.DotNet.DotNetRuntime.IsNetFx(NDepend.DotNet.DotNetRuntimeKind)">
            <summary>
            This extension method returns true if <paramref name="kind" /> is .NET Framework.
            </summary>
            <param name="kind">the kind of .NET runtime.</param>
        </member>
        <member name="M:NDepend.DotNet.DotNetRuntime.IsNetCore(NDepend.DotNet.DotNetRuntimeKind)">
            <summary>
            This extension method returns true if <paramref name="kind" /> is .NET Core or .NET 5/6....
            </summary>
            <param name="kind">the kind of .NET runtime.</param>
        </member>
        <member name="T:NDepend.DotNet.IDEKind">
            <summary>
            Represent .NET IDEs (Integrated Development Environments)
            </summary>
        </member>
        <member name="F:NDepend.DotNet.IDEKind.Default">
            <summary>
            Default .NET IDE which is Microsoft Visual Studio
            </summary>
        </member>
        <member name="F:NDepend.DotNet.IDEKind.VisualStudio">
            <summary>
            .NET IDE Microsoft Visual Studio
            </summary>
        </member>
        <member name="F:NDepend.DotNet.IDEKind.Rider">
            <summary>
            .NET IDE Jetbrains Rider
            </summary>
        </member>
        <member name="F:NDepend.DotNet.IDEKind.VSCode">
            <summary>
            .NET IDE Microsoft Visual Studio Code
            </summary>
        </member>
        <member name="F:NDepend.DotNet.IDEKind.None">
            <summary>
            No .NET IDE value
            </summary>
        </member>
        <member name="T:NDepend.DotNet.DotNetProfile">
            <summary>
            Represents a .NET Framework profile.
            </summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.DotNetFramework">
            <summary>DotNetFramework</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.WinRT">
            <summary>WinRT</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.Silverlight">
            <summary>Silverlight</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.AspNetMvc">
            <summary>AspNetMvc</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.DotNetCore">
            <summary>DotNetCore</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.DotNet">
            <summary>DotNet</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.UWP">
            <summary>WinRT</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.Unity">
            <summary>Unity</summary>
        </member>
        <member name="F:NDepend.DotNet.DotNetProfile.Xamarin">
            <summary>Xamarin</summary>
        </member>
        <member name="T:NDepend.DotNet.IAssemblyInfo">
            <summary>
            Represents information about the assembly that is defined by its main module file path <see cref="P:NDepend.DotNet.IAssemblyInfo.FilePath" />.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.FileNameWithoutExtension">
            <summary>
            Gets the assembly main module file name without the ".dll" or ".exe" extension.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.FilePath">
            <summary>
            Gets the assembly main module file path.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.Version">
            <summary>
            Gets the assembly version, the version specified with the System.Reflection.AssemblyVersionAttribute attribute.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.IsStrongNamed">
            <summary>
            Gets a value indicating whether this assembly is strong named or not.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.PDBAvailable">
            <summary>
            Gets a value indicating whether this assembly corresponding PDB file is available or not.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.TargetFrameworkName">
            <summary>
             Gets the target framework name (TFM) of the assembly.
            </summary>
            <remarks>
             Returns a string such as 'net5.0', 'net5.0-windows', 'netcoreapp3.1', 'netstandard2.0', 'net462', 'net4x'.<br />
             Related documentation: https://github.com/dotnet/designs/blob/main/accepted/2020/net5/net5.md
            </remarks>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.TargetRuntime">
            <summary>
            Gets the assembly target runtime version.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.PlatformTarget">
            <summary>
            Gets the assembly platform target value.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyInfo.AssembliesReferences">
            <summary>
            Gets a read-only list of assemblies references, representing assemblies referenced by this assembly.
            </summary>
        </member>
        <member name="T:NDepend.DotNet.IAssemblyReference">
            <summary>
            Represents an assembly reference, extracted from an <see cref="T:NDepend.DotNet.IAssemblyInfo" /> object referencing others assemblies through <see cref="P:NDepend.DotNet.IAssemblyInfo.AssembliesReferences" />.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyReference.FileNameWithoutExtension">
            <summary>
            Gets this assembly reference name.
            </summary>
        </member>
        <member name="P:NDepend.DotNet.IAssemblyReference.Version">
            <summary>
            Gets this assembly reference version.
            </summary>
        </member>
        <member name="T:NDepend.DotNet.IDotNetManager">
            <summary>
            Exposes base operations concerning the .NET platforms versions installed, including getting .NET Fx installation directories. An instance of IDotNetManager can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.DotNetManager" />.
            </summary>
        </member>
        <member name="M:NDepend.DotNet.IDotNetManager.IsInstalled(NDepend.DotNet.DotNetProfile,System.Version)">
            <summary>
            Returns true if the .NET profile version specified is installed on the current machine, otherwise returns false.
            </summary>
            <param name="dotNetProfile">The .NET profile target.</param>
            <param name="version">The version demanded, only the version major and minor numbers are taken account.</param>
        </member>
        <member name="M:NDepend.DotNet.IDotNetManager.GetDotNetProfileVersionsInstalled(NDepend.DotNet.DotNetProfile)">
            <summary>
            Gets the versions installed on the machine, for the specified .NET profile.<br />
            </summary>
            <returns>
            A sequence a versions of the profile supported on the current machine.<br />
            An empty sequence if no version of <paramref name="dotNetProfile" /> is installed on the current machine.
            </returns>
            <remarks>
            Versions are returned in decreased order, higher version installed first. <br />
            Notes that NDepend needs at least .NET framework v4.0 to run, so the returned version for the <see cref="F:NDepend.DotNet.DotNetProfile.DotNetFramework" /> profile must include v4.0 or above. <br />
            Only the version major and minor numbers are taken account.
            </remarks>
            <param name="dotNetProfile">The .NET profile target.</param>
        </member>
        <member name="M:NDepend.DotNet.IDotNetManager.GetDotNetProfileDirectories(NDepend.DotNet.DotNetProfile,System.Version)">
            <summary>
            Gets a sequence of directory paths containing assemblies of the <paramref name="dotNetProfile" />, specified <paramref name="version" />.
            </summary>
            <returns>
            Directory paths containing assemblies of the <paramref name="dotNetProfile" />, specified <paramref name="version" />.<br />
            An empty sequence if <paramref name="version" /> is not supported.<br />
            Some directories paths are returned even if <paramref name="version" /> of <paramref name="dotNetProfile" /> is not installed. In such case these directories doesn't exist.
            </returns>
            <remarks>
            Only the version major and minor numbers are taken account.<br />
            Returns an empty set of directories if the <paramref name="version" /> is not a valid version.
            </remarks>
            <param name="dotNetProfile">The .NET profile target.</param>
            <param name="version">The version demanded, only the version major and minor numbers are taken account.</param>
        </member>
        <member name="M:NDepend.DotNet.IDotNetManager.IsAssembly(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns true if the file specified is a main module of a .NET assembly.
            </summary>
            <param name="filePath">The path to the file to test whether it is a main module assembly.</param>
        </member>
        <member name="M:NDepend.DotNet.IDotNetManager.GetAssemblyInfo(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns assembly information if the file specified is a main module of a .NET assembly, otherwise returns null.
            </summary>
            <param name="filePath">The path to the main module file of a .NET assembly.</param>
        </member>
        <member name="T:NDepend.DotNet.PlatformTarget">
            <summary>
            Represents the platform target option for a .NET assembly.
            </summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.Unknow">
            <summary>Unknow</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.AnyCPU">
            <summary>AnyCPU</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.x86">
            <summary>x86</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.Itanium">
            <summary>Itanium</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.x64">
            <summary>x64</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.ARMv7">
            <summary>ARMv7</summary>
        </member>
        <member name="F:NDepend.DotNet.PlatformTarget.ARM">
            <summary>ARM</summary>
        </member>
        <member name="T:NDepend.DotNet.VisualStudio.IVisualStudioManager">
            <summary>
            Exposes base operations concerning Visual Studio files, including getting debug assemblies built from a VS solution. A IVisualStudioManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.VisualStudioManager" />.
            </summary>
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.GetAssembliesFromVisualStudioSolutionOrProject(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Returns a read-only list of assemblies file paths compiled in Debug mode, from the Visual Studio solution or project file path.
            </summary>
            <param name="visualStudioSolutionOrProjectFilePath">The path to the Visual Studio solution or project file path.</param>
            <exception cref="T:System.IO.FileNotFoundException"><paramref name="visualStudioSolutionOrProjectFilePath" /> doesn't refer to an existing file.</exception>
             
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.GetMostRecentlyUsedVisualStudioSolutionOrProject(NDepend.DotNet.VisualStudio.VisualStudioVersion)">
            <summary>
            Returns a read-only list of most recently used Visual Studio solutions or projects file paths, for the specified <paramref name="visualStudioVersion" />.
            </summary>
            <remarks>
            This list is stored in the registry and is used by the Start Page of Visual Studio.
            Returns an empty collection if the specified Visual Studio version is not installed.<br />
            This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <param name="visualStudioVersion">The Visual Studio version.</param>
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.IsVisualStudioVersionInstalled(NDepend.DotNet.VisualStudio.VisualStudioVersion)">
            <summary>
            Returns <i>true</i> if the specified Visual Studio version is installed on the current machine.
            </summary>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <param name="visualStudioVersion">The Visual Studio version.</param>
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
            <summary>
            Shows a dialog that lets the user select one or several Visual Studio solutions or projects files.
            </summary>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="visualStudioSolutionsOrProjectsFilePaths">Visual Studio solutions or projects file paths choosen.</param>
            <returns>True if the user clicked OK, False if the user clicked Cancel</returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(System.IntPtr,NDepend.Project.IProject@)" />
            <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(System.IntPtr,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.TryGetNDependProjectFilePathAttachedToVisualStudioSolution(NDepend.Path.IAbsoluteFilePath,NDepend.Path.IAbsoluteFilePath@)">
            <summary>
            Returns <i>true</i> if the <paramref name="visualStudioSolutionFilePath" /> exists, and contains a <paramref name="ndependProjectFilePath" /> that can be resolved to an absolute path.
            </summary>
            <remarks>
            If project attachment is done through the VS solutionn user options file (.suo) this method won't be able to retrieve the project attached.
            This method only deal with VS solution files (.sln).  
            </remarks>
            <param name="visualStudioSolutionFilePath">The path to the Visual Studio solution file.</param>
            <param name="ndependProjectFilePath">The path to the NDepend project file.</param>
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.TryGetNDependProjectFilePathAttachedToVisualStudioSolution(NDepend.Path.IAbsoluteFilePath,NDepend.Path.IAbsoluteFilePath@,System.String@)">
            <summary>
            Returns <i>true</i> if the <paramref name="visualStudioSolutionFilePath" /> exists, and contains a <paramref name="ndependProjectFilePath" /> that can be resolved to an absolute path.
            </summary>
            <remarks>
            If project attachment is done through the VS solutionn user options file (.suo) this method won't be able to retrieve the project attached.
            This method only deal with VS solution files (.sln).  
            </remarks>
            <param name="visualStudioSolutionFilePath">The path to the Visual Studio solution file.</param>
            <param name="ndependProjectFilePath">The path to the NDepend project file.</param>
            <param name="failureReason">If this method returns <i>false</i>, this string contains a plain-english description of the reason why a NDepend project file path cannot be resolved.</param>
        </member>
        <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.GetVisualStudioInstallPaths">
             <summary>
             Return Visual Studio 2017 and upper install paths.
             </summary>
             <returns>
             For example it can return a list of path like these ones, depending on the Visual Studio 2017 and upper instances on the current machine.
             C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise
             C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview
             C:\Program Files (x86)\Microsoft Visual Studio\2019\Community
             C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise
             </returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
        </member>
        <member name="T:NDepend.DotNet.VisualStudio.VisualStudioVersion">
            <summary>
            Represents a Visual Studio version.
            </summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V7_2003">
            <summary>V7_2003</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V8_2005">
            <summary>V8_2005</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V9_2008">
            <summary>V9_2008</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V10_2010">
            <summary>V10_2010</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V11_2012">
            <summary>V11_2012</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V12_2013">
            <summary>V12_2013</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V14_2015">
            <summary>V14_2015</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V15_2017">
            <summary>V15_2017</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V16_2019">
            <summary>V15_2019</summary>
        </member>
        <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V17_2022">
            <summary>V17_2022</summary>
        </member>
        <member name="T:NDepend.Github.GithubAccount">
            <summary>
            Hold the string of a GitHub account.
            </summary>
        </member>
        <member name="M:NDepend.Github.GithubAccount.#ctor(System.String)">
            <summary>
            Build a GitHub account object.
            </summary>
            <param name="val">The GitHub account name</param>
            <exception cref="T:System.ArgumentException">val doesn't satisfies <see cref="M:NDepend.Github.GithubAccount.IsValidVal(System.String)"/></exception>
        </member>
        <member name="P:NDepend.Github.GithubAccount.Val">
            <summary>
            Returns the name of the account.
            </summary>
        </member>
        <member name="M:NDepend.Github.GithubAccount.IsValidVal(System.String)">
            <summary>
            Returns <i>true</i> if val is a valid value for a account name.
            </summary>
            <param name="val">The account name.</param>
        </member>
        <member name="T:NDepend.Github.GithubRepo">
            <summary>
            Hold the string of a GitHub repository.
            </summary>
        </member>
        <member name="M:NDepend.Github.GithubRepo.#ctor(System.String)">
            <summary>
            Build a GitHub repository object.
            </summary>
            <param name="val">The GitHub repository name</param>
            <exception cref="T:System.ArgumentException">val doesn't satisfies <see cref="M:NDepend.Github.GithubRepo.IsValidVal(System.String)"/></exception>
        </member>
        <member name="P:NDepend.Github.GithubRepo.Val">
            <summary>
            Returns the name of the repository.
            </summary>
        </member>
        <member name="M:NDepend.Github.GithubRepo.IsValidVal(System.String)">
            <summary>
            Returns <i>true</i> if val is a valid value for a repository name.
            </summary>
            <param name="val">The repository name.</param>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsMath">
            <summary>
            Provides a set of extension methods to do some simple math.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Single,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.Single},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.Int32},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.UInt32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.UInt32},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Int64,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.Int64},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.UInt64,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.UInt64},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Int16,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.Int16},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.UInt16,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMath.Linear(System.Nullable{System.UInt16},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns linear value for <paramref name="x" /> between the points (<paramref name="x1" />, <paramref name="y1" />) and (<paramref name="x2" />, <paramref name="y2" />).
            </summary>
            <remarks>
            If <paramref name="x" /> is lower than <paramref name="x1" /> returns <paramref name="y1" />.<br />
            If <paramref name="x" /> is higher than <paramref name="x2" /> returns <paramref name="y2" />.<br />
            If <paramref name="x" /> is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="x">This value.</param>
            <param name="x1">x coordinate 1</param>
            <param name="y1">y coordinate 1</param>
            <param name="x2">x coordinate 2</param>
            <param name="y2">y coordinate 2</param>
            <returns></returns>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsMisc">
            <summary>
            Presents miscellaneous helpers extension methods.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.EqualsAny``1(``0,``0,``0)">
            <summary>
            Returns <i>true</i> if <i>this</i> <paramref name="item" /> equals <paramref name="item1" /> or <paramref name="item2" />.
            </summary>
            <typeparam name="T">The generic parameter value type of items.</typeparam>
            <param name="item"><i>this</i> items.</param>
            <param name="item1">First item to compare to.</param>
            <param name="item2">Second item to compare to.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.EqualsAny``1(``0,``0,``0,``0)">
            <summary>
            Returns <i>true</i> if <i>this</i> <paramref name="item" /> equals <paramref name="item1" />, <paramref name="item2" /> or <paramref name="item3" />.
            </summary>
            <typeparam name="T">The generic parameter value type of items.</typeparam>
            <param name="item"><i>this</i> items.</param>
            <param name="item1">First item to compare to.</param>
            <param name="item2">Second item to compare to.</param>
            <param name="item3">Third item to compare to.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.EqualsAny``1(``0,``0,``0,``0,``0)">
            <summary>
            Returns <i>true</i> if <i>this</i> <paramref name="item" /> equals <paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" /> or <paramref name="item4" />.
            </summary>
            <typeparam name="T">The generic parameter value type of items.</typeparam>
            <param name="item"><i>this</i> items.</param>
            <param name="item1">First item to compare to.</param>
            <param name="item2">Second item to compare to.</param>
            <param name="item3">Third item to compare to.</param>
            <param name="item4">Fourth item to compare to.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.EqualsAny``1(``0,``0[])">
            <summary>
            Returns <i>true</i> if <i>this</i> <paramref name="item" /> equals any item in <paramref name="items" />.
            </summary>
            <typeparam name="T">The generic parameter value type of items.</typeparam>
            <param name="item"><i>this</i> items.</param>
            <param name="items">An array of items.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.ToNullableDouble(System.Object)">
            <summary>
            If <paramref name="obj" /> is a numeric primitive type, returns its value converted as double. else returns null.
            </summary>
            <param name="obj">The object</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsMisc.GetImage``1(NDepend.Helpers.TrendIcon)">
            <summary>
            Return the image corresponding to the trend icon value.
            </summary>
            <param name="trendIcon">The trend icon value</param>
        </member>
        <member name="T:NDepend.Helpers.IgnoreCase">
            <summary>
            An enumeration tha determine if string casing is ignored or taken account.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.IgnoreCase.Yes">
            <summary>
            String casing is ignored.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.IgnoreCase.No">
            <summary>
            String casing is taken account.
            </summary>
        </member>
        <member name="T:NDepend.Helpers.IMyAsyncResult`1">
            <summary>
            Reserved for internal uses.
            </summary>
            <typeparam name="TResult">Reserved for internal uses.</typeparam>
        </member>
        <member name="M:NDepend.Helpers.IMyAsyncResult`1.TryEndInvoke(`0@,System.Exception@)">
            <summary>
            Reserved for internal uses.
            </summary>
            <param name="result">Reserved for internal uses.</param>
            <param name="exception">Reserved for internal uses.</param>
        </member>
        <member name="T:NDepend.Helpers.NdpColor">
            <summary>
            The NDepend API uses this type to return some color value. Such a value can be easily converted to any UI framework color value.
            </summary>
            <remarks>
            Since the NDepend API doesn't reference any UI framework it cannot return some System.Drawing.Color values for example.
            </remarks>
        </member>
        <member name="P:NDepend.Helpers.NdpColor.A">
            <summary>
            The Alpha channel value of the color.
            </summary>
        </member>
        <member name="P:NDepend.Helpers.NdpColor.R">
            <summary>
            The Red channel value of the color.
            </summary>
        </member>
        <member name="P:NDepend.Helpers.NdpColor.G">
            <summary>
            The Green channel value of the color.
            </summary>
        </member>
        <member name="P:NDepend.Helpers.NdpColor.B">
            <summary>
            The Blue channel value of the color.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a new Color value.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a new Color value.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a new Color value.
            </summary>
            <param name="alpha">The Alpha channel value of the color.</param>
            <param name="red">The Red channel value of the color.</param>
            <param name="green">The Green channel value of the color.</param>
            <param name="blue">The Blue channel value of the color.</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.FromArgb(System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a new Color value with Alpha channel set to 255.
            </summary>
            <param name="red">The Red channel value of the color.</param>
            <param name="green">The Green channel value of the color.</param>
            <param name="blue">The Blue channel value of the color.</param>
            <returns></returns>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.FromHexInit(System.Int32)">
            <summary>
            Create a new Color value with Alpha channel from a 32-bits ARGB value.
            </summary>
            <param name="value">The 32-bits ARGB value.</param>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.ToHexInt">
            <summary>Gets the 32-bit ARGB value of this <see cref="T:NDepend.Helpers.NdpColor" /> structure.</summary>
            <returns>The 32-bit ARGB value of this <see cref="T:NDepend.Helpers.NdpColor" />.</returns>
        </member>
        <member name="M:NDepend.Helpers.NdpColor.ColorEquals(NDepend.Helpers.NdpColor)">
            <summary>
            Returns true if this and <paramref name="other" /> color Alpha Red Green Blue values are equals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Black">
            <summary>
            Black color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.White">
            <summary>
            White color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Transparent">
            <summary>
            Transparent color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Red">
            <summary>
            Red color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Orange">
            <summary>
            Orange color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Green">
            <summary>
            Green color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Blue">
            <summary>
            Blue color constant.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.NdpColor.Gray">
            <summary>
            Gray color constant.
            </summary>
        </member>
        <member name="T:NDepend.Helpers.Range">
            <summary>
            This class define a numerical closed range. It is useful to make some code queries generated easier to read.
            </summary>
            <remarks>
            The range is closed in the sense that lower and upper numeric bounds are considered in the range.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new range.
            </summary>
            <remarks>
            <paramref name="min" /> and <paramref name="max" /> can be equal to test equality to a number.<br />
            If <paramref name="min" /> is greater than <paramref name="max" />, the value are swapped.
            </remarks>
            <param name="min">The lower bound of the range.</param>
            <param name="max">The upper bound of the range.</param>
        </member>
        <member name="F:NDepend.Helpers.Range.OneOrMore">
            <summary>
            Define a closed range in one and <see cref="T:System.Int32" />.<see cref="F:System.Int32.MaxValue" />.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Nullable{System.UInt16}[])">
            <summary>
            Returns <b>true</b> if any of the non-null value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The nullable values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Nullable{System.UInt16})">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is not null and is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Nullable{System.UInt32}[])">
            <summary>
            Returns <b>true</b> if any of the non-null value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The nullable values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Nullable{System.UInt32})">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is not null and is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Nullable{System.Int16}[])">
            <summary>
            Returns <b>true</b> if any of the non-null value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The nullable values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Nullable{System.Int16})">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is not null and is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Nullable{System.Int32}[])">
            <summary>
            Returns <b>true</b> if any of the non-null value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The nullable values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Nullable{System.Int32})">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is not null and is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.UInt16[])">
            <summary>
            Returns <b>true</b> if any of the value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.UInt16)">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.UInt32[])">
            <summary>
            Returns <b>true</b> if any of the value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.UInt32)">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Int16[])">
            <summary>
            Returns <b>true</b> if any of the value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Int16)">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.ContainsAny(System.Int32[])">
            <summary>
            Returns <b>true</b> if any of the value in <paramref name="values" /> is in this closed range.
            </summary>
            <param name="values">The values to test.</param>
        </member>
        <member name="M:NDepend.Helpers.Range.Contains(System.Int32)">
            <summary>
            Returns <b>true</b> if <paramref name="value" /> is in this closed range.
            </summary>
            <param name="value">The nullable value to test.</param>
        </member>
        <member name="T:NDepend.Helpers.SoundPlayerState">
            <summary>
            Determine if a ding is played when showing a form.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.SoundPlayerState.On">
            <summary>
            Play a ding when showing a form.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.SoundPlayerState.Off">
            <summary>
            Don't play a ding when showing a form.
            </summary>
        </member>
        <member name="T:NDepend.Helpers.StringFilter">
            <summary>
            This class is used to obtain filters from a string and apply these filters on components name.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.StringFilter.#ctor(System.String,NDepend.Helpers.IgnoreCase)">
            <summary>
            Build an instance of <see cref="T:NDepend.Helpers.StringFilter" />
            </summary>
            <remarks>
            Zero, one or several positive or negative filters can be provided.<br />
            Filter(s) are space separated.<br />
            Negative filter(s) are prefixed with the minus '-' character can be used to filter out.
            </remarks>
            <param name="filters">The filter string that can contain positive and negative filters, separated by space characters</param>
            <param name="ignoreCase">Decide if the filters are applied case-sensitive or case-insensitive</param>
            <seealso cref="P:NDepend.Project.IDEFile.Filters" />
        </member>
        <member name="M:NDepend.Helpers.StringFilter.Match(System.String)">
            <summary>
            Returns a value indicate if the string <paramref name="str" /> matches all positive filters and no negative filter.
            </summary>
            <param name="str">The string on which filters are applied.</param>
        </member>
        <member name="T:NDepend.Helpers.SubStringLocation">
            <summary>
            Simple structure used for some private implementations.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.SubStringLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Build an instance of <see cref="T:NDepend.Helpers.SubStringLocation" />.
            </summary>
            <param name="position">The beginning position of the substring in a string</param>
            <param name="length">The length of the substring</param>
        </member>
        <member name="P:NDepend.Helpers.SubStringLocation.Position">
            <summary>
            The beginning position of the substring in a string
            </summary>
        </member>
        <member name="P:NDepend.Helpers.SubStringLocation.Length">
            <summary>
            The length of the substring
            </summary>
        </member>
        <member name="T:NDepend.Helpers.TrendIcon">
            <summary>
            Value of this enumeration can be used in code query result to show a trend image that conveys meaning for both [Up,Down] and [Red,Green] indications.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.RedUp">
            <summary>RedUp</summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.RedDown">
            <summary>RedDown</summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.GreenUp">
            <summary>GreenUp</summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.GreenDown">
            <summary>GreenDown</summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.Constant">
            <summary>Constant</summary>
        </member>
        <member name="F:NDepend.Helpers.TrendIcon.None">
            <summary>Constant</summary>
        </member>
        <member name="T:NDepend.Helpers.BeforeAfter">
            <summary>
            Define a location, left or right.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.BeforeAfter.After">
            <summary>Left</summary>
        </member>
        <member name="F:NDepend.Helpers.BeforeAfter.Before">
            <summary>Right</summary>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsFailure">
            <summary>
            Presents helpers to deal with exceptions.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsFailure.GetExceptionAndInnerExceptionTypeMessageAndStackTrace(System.Exception)">
            <summary>
            Get a multi-lines string containing the <paramref name="exception" /> type, message and stacktrace, and if it has an inner-exception, its type, message and stacktrace are also shown.
            </summary>
            <remarks>The frames in the stack trace will contains IL instructions offset.</remarks>
            <param name="exception">The exception</param>
            <returns>The multi-lines string.</returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsFailure.GetExceptionAndInnerExceptionTypeAndMessage(System.Exception)">
            <summary>
            Get a multi-lines string containing the <paramref name="exception" /> type and message, and if it has an inner-exception, its type and message are also shown.
            </summary>
            <param name="exception">The exception</param>
            <returns>The multi-lines string.</returns>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsEnumerable">
            <summary>
            Provides a set of extension methods dedicated to enumerables. 
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns distinct elements from a sequence <paramref name="seq" />  by using the default equality comparer of the type <typeparamref name="TKey" />, on which items are projected through <paramref name="funcProjection" />.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
             <typeparam name="TKey">The type on which elements of <paramref name="seq" /> are projected.</typeparam>
             <param name="seq">The source sequence that contains elements.</param>
             <param name="funcProjection">The projection function to obtain an instance of type <typeparamref name="TKey" /> from an instance of type <typeparamref name="T" />.</param>
             <returns>The sequence of distinct items.</returns>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ContainsNullElement``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <i>true</i> if the sequence <paramref name="seq" /> contains a <i>null</i> element.
            </summary>
            <param name="seq">The sequence that contains items tested for nullity.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToEnumerable``1(``0)">
            <summary>
            Gets an enumerable object that contains only the single element <paramref name="element" />.
            </summary>
            <typeparam name="TElement">The type of <paramref name="element" />.</typeparam>
            <param name="element">The single element in the returned enumerable.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Concat``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets an enumerable object that contains first <paramref name="element" /> and then elements of <paramref name="elements" />, in this order.
            </summary>
            <typeparam name="TElement">The type of <paramref name="element" />.</typeparam>
            <param name="element">The first element in the returned enumerable.</param>
            <param name="elements">The last elements in the returned enumerable.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Gets an enumerable object that contains the elements of <paramref name="elements" /> and then <paramref name="element" />, in this order.
            </summary>
            <typeparam name="TElement">The type of <paramref name="element" />.</typeparam>
            <param name="elements">The first elements in the returned enumerable.</param>
            <param name="element">The last element in the returned enumerable.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToMultiKeyLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function. <b>The funtion can return zero, one or several keys for an element.</b>.
            </summary>
            <remarks>
            The difference with <seealso cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> is that an element can have zero, one or several keys.<br />
            Hence an element can be contained in several groups, if it has several keys.
            </remarks>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
            <typeparam name="TKey">The type of the keys in the result <see cref="T:System.Linq.Lookup`2" />.</typeparam>
            <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
            <param name="func">A function to extract a sequence of keys from each element.</param>
            <returns>An hashset that contains the elements from the input sequence.</returns>
            <seealso cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Add a pair of <paramref name="key" /> and <paramref name="value" /> to <paramref name="dico" />, only if <paramref name="dico" /> doesn't already contain the <paramref name="key" />.
            </summary>
            <returns><i>false</i> if the <paramref name="dico" /> already contains the <paramref name="key" />. Else add the pair <paramref name="key" /> and <paramref name="value" /> and returns <i>true</i>.</returns>
            <param name="dico">This dictionary.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Produces the set <paramref name="seq" /> excluding <paramref name="elementExcluded" />. The equality test relies on the <i>Equals()</i> method.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="seq">A sequence of elements.</param>
            <param name="elementExcluded">The element excluded.</param>
            <returns>A sequence that contains the set difference of the elements of <paramref name="seq" /> minus <paramref name="elementExcluded" />.</returns>
            <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Append <paramref name="element" /> at the end of <paramref name="seq" />.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="seq">A sequence of elements.</param>
            <param name="element">The element to append.</param>
            <remarks>This extension method has a <i>constant</i> time complexity.<br />
             Before v2021.2 this method used to be an extension method but with v2021.2 NDepend compiles to net472.<br />
             Thus this method collided with the Enumerable.Append() introduced within net471.<br />
             Some default rules used this method in a non-extension way so we made it as a non-extension method.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
            <summary>
            Append <paramref name="element1" /> and <paramref name="element1" /> at the end of <paramref name="seq" />.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="seq">A sequence of elements.</param>
            <param name="element1">The element to append first.</param>
            <param name="element2">The element to append after <paramref name="element1" />.</param>
            <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0,``0,``0)">
            <summary>
            Append <paramref name="element1" />, <paramref name="element2" /> and <paramref name="element3" /> at the end of <paramref name="seq" />.
            </summary>
            <remarks>To append more than 3 elements to <paramref name="seq" />, use the <i>.Concat(new [] { a, b, c, d ... } )</i> syntax.</remarks>
            <typeparam name="T">The element type.</typeparam>
            <param name="seq">A sequence of elements.</param>
            <param name="element1">The element to append first.</param>
            <param name="element2">The element to append after <paramref name="element1" />.</param>
            <param name="element3">The element to append after <paramref name="element2" />.</param>
            <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToReadOnlyWrappedCollection``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> wrapper collection around <paramref name="collection" />. 
            </summary>
            <typeparam name="T">The type parameter of the items in the collection.</typeparam>
            <param name="collection">A collection object.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToReadOnlyClonedCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> cloned collection around <paramref name="sequence" />. 
            </summary>
            <typeparam name="T">The type parameter of the items in the collection.</typeparam>
            <param name="sequence">A collection object.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToReadOnlyWrappedList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> wrapper collection around <paramref name="list" />. 
            </summary>
            <typeparam name="T">The type parameter of the items in the list.</typeparam>
            <param name="list">A list object.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToReadOnlyClonedList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.IReadOnlyCollection`1" /> cloned collection around <paramref name="sequence" />. 
            </summary>
            <typeparam name="T">The type parameter of the items in the list.</typeparam>
            <param name="sequence">A list object.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.IndexOf``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>
            Determines the index of a specific item in <paramref name="readOnlyList" />.
            </summary>
            <typeparam name="T">The type parameter of the items in the read-only list.</typeparam>
            <param name="readOnlyList"></param>
            <param name="value">The object to locate in <paramref name="readOnlyList" />.</param>
            <returns>The index of value if found in the list; otherwise, -1.</returns>
            <remarks>This method uses the EqualityComparer$lt;T&gt;.Default.Equals() method on <paramref name="value" /> to determine whether item exists</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ContainsAll``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Determine if <paramref name="superset" /> contains all elements of <paramref name="subset" />.
             </summary>
            <typeparam name="T">The type parameter of the items in the sets.</typeparam>
             <param name="superset">This set that might contains the subset.</param>
             <param name="subset">The set to test if contained in superset.</param>
             <remarks>
             <b>true</b> is returned if <paramref name="subset" /> is empty.<br />
             <b>true</b> is returned if both <paramref name="subset" /> and <paramref name="superset" /> are empty.<br />
             <b>false</b> is returned if <paramref name="superset" /> is empty and <paramref name="subset" /> is not empty.
             </remarks>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsSet">
            <summary>
            Provides a set of extension methods to optimize enumerables operations on set.
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an hashset from a <i>IEnumerable&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
            <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
            <returns>An hashset that contains the elements from the input sequence.</returns>
            <remarks>
            The .NET Fx v4.7.2 introduces a <i>ToHashSet()</i> extension method with the same signature. 
            As a consequence this method has been marked as obsolete since NDepend v2018.1.1 and it is advised to use <see cref="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSetEx``1(System.Collections.Generic.IEnumerable{``0})" />
            instead, to avoid ambiguous call error emitted by the compiler.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an hashset from a <i>IEnumerable&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
            <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
            <param name="equalityComparer">The equality comparer on elements.</param>
            <returns>An hashset that contains the elements from the input sequence.</returns>
            <remarks>
            The .NET Fx v4.7.2 introduces a <i>ToHashSet()</i> extension method with the same signature. 
            As a consequence this method has been marked as obsolete since NDepend v2018.1.1 and it is advised to use <see cref="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSetEx``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
            instead, to avoid ambiguous call error emitted by the compiler.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSetEx``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an hashset from a <i>IEnumerable&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
            <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
            <returns>An hashset that contains the elements from the input sequence.</returns>
            <remarks>
            This method exists since NDepend v2018.1.1 because the .NET Fx v4.7.2 introduces a <i>ToHashSet()</i> extension method with the same signature as the one in the NDepend.API.
            As a consequence ambiguous call errors are emitted by the compiler when using <i>ToHashSet()</i> in a .NET fx v4.7.2 (or upper) environment.
            <i>ToHashSet()</i> can still be used as a static method <i>ExtensionMethodsSet.ToHashSet(...)</i>.
            To avoid any problem, a straightforward solution is to replace "ToHashSet()" with "ToHashSetEx()"
            in all your <i>.ndproj</i> and <i>.ndrules</i> textual files that contain your code queries and rules.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSetEx``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an hashset from a <i>IEnumerable&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
            <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
            <param name="equalityComparer">The equality comparer on elements.</param>
            <returns>An hashset that contains the elements from the input sequence.</returns>
            <remarks>
            This method exists since NDepend v2018.1.1 because the .NET Fx v4.7.2 introduces a <i>ToHashSet()</i> extension method with the same signature as the one in the NDepend.API.
            As a consequence ambiguous call errors are emitted by the compiler when using <i>ToHashSet()</i> in a .NET fx v4.7.2 (or upper) environment.
            <i>ToHashSet()</i> can still be used as a static method <i>ExtensionMethodsSet.ToHashSet(...)</i>.
            To avoid any problem, a straightforward solution is to replace "ToHashSet()" with "ToHashSetEx()"
            in all your <i>.ndproj</i> and <i>.ndrules</i> textual files that contain your code queries and rules.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set of elements, intersection of this <paramref name="hashset" /> and <paramref name="seq" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="seq" /> will be returned.</param>
            <param name="seq">A sequence of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
            <returns>A sequence that contains the elements that form the set intersection of the hashset and the sequence.</returns>
            <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Produces the set of elements, intersection of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="seq" /> will be returned.</param>
            <param name="seq">A sequence of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
            <returns>A sequence that contains the elements that form the set intersection of the hashset and the sequence.</returns>
            <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Produces the set of elements, intersection of this <paramref name="hashset" /> and <paramref name="otherHashset" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="otherHashset" /> will be returned.</param>
            <param name="otherHashset">An hashset of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
            <returns>A sequence that contains the elements that form the set intersection of both hashsets.</returns>
            <remarks>This extension method has a <i>O(<paramref name="otherHashset" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set of elements, union of this <paramref name="hashset" /> and <paramref name="seq" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="hashset">An hashset of elements whose distinct elements form the first set for the union.</param>
            <param name="seq">A sequence of elements whose distinct elements form the second set for the union.</param>
            <returns>A sequence that contains the elements that form the set union of the hashset and the sequence, excluding duplicates.</returns>
            <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Produces the set of elements, union of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="hashset">An hashset of elements whose distinct elements form the first set for the union.</param>
            <param name="seq">A sequence of elements whose distinct elements form the second set for the union.</param>
            <returns>A sequence that contains the elements that form the set union of the sequence and the hashset, excluding duplicates.</returns>
            <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Produces the set of elements, union of this <paramref name="thisHashset" /> and <paramref name="otherHashset" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
            <param name="thisHashset">A sequence of elements whose distinct elements form the first set for the union.</param>
            <param name="otherHashset">An hashset of elements whose distinct elements form the second set for the union.</param>
            <returns>A sequence that contains the elements that form the set union of both hashsets, excluding duplicates.</returns>
            <remarks>This extension method has a <i>O(<paramref name="otherHashset" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsSet.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Produces the set difference of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Except&lt;T&gt;</i>.
            </summary>
            <typeparam name="T">The element type of the elements of the hashset and the sequence.</typeparam>
            <param name="seq">A sequence of elements whose elements that are not also in <paramref name="hashset" /> will be returned.</param>
            <param name="hashset">An hashset of elements whose elements that also occur in <paramref name="seq" /> will cause those elements to be removed from the returned sequence.</param>
            <returns>A sequence that contains the set difference of the elements of <paramref name="seq" /> and <paramref name="hashset" />.</returns>
            <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsString">
            <summary>
            Provides a set of extension methods dedicated to strings. 
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible value for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible value for <paramref name="thisString" />.</param>
            <param name="array">An array containing possible values for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String[])">
            <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="array">An array containing possible values for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.Collections.Generic.HashSet{System.String})">
            <summary>Gets a value indicating whether <paramref name="hashset" /> contains the string <paramref name="thisString" />.</summary>
            <remarks>This <see cref="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String)" /> overload can be used to check the value of <paramref name="thisString" /> against a large number of strings, in a constant time.</remarks>
            <param name="thisString">This string.</param>
            <param name="hashset">An hashset containing possible values for this <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.ContainsAny(System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string contains any <i>case sensitive</i> of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str1">One of the string that might be contained by <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.ContainsAny(System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string contains any <i>case sensitive</i> of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str1">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str2">One of the string that might be contained by <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.ContainsAny(System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string contains any <i>case sensitive</i> of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str1">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str2">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str3">One of the string that might be contained by <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.ContainsAny(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string contains any <i>case sensitive</i> of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str1">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str2">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str3">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str4">One of the string that might be contained by <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.ContainsAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>Gets a value indicating whether this string contains any <i>case sensitive</i> of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str1">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str2">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str3">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="str4">One of the string that might be contained by <paramref name="thisString" />.</param>
            <param name="array">An array of possible strings contained by <paramref name="thisString" />.</param>
            <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible start string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible start string for <paramref name="thisString" />.</param>
            <param name="array">An array containing possible start strings for <paramref name="thisString" />.</param>
            <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String[])">
            <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> any of the strings in <paramref name="array" />.</summary>
            <param name="thisString">This string.</param>
            <param name="array">An array containing possible start strings for <paramref name="thisString" />.</param>
            <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible end string for <paramref name="thisString" />.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings specified.</summary>
            <param name="thisString">This string.</param>
            <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="str4">One of the possible end string for <paramref name="thisString" />.</param>
            <param name="array">An array containing possible end strings for <paramref name="thisString" />.</param>
            <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String[])">
            <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> any of the strings in <paramref name="array" />.</summary>
            <param name="thisString">This string.</param>
            <param name="array">An array containing possible end strings for <paramref name="thisString" />.</param>
            <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.Aggregate(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Aggregate string in this <paramref name="seq" />, with the string <paramref name="separator" /> between each strings.
            </summary>
            <param name="seq">The sequence of strings to aggregate.</param>
            <param name="separator">The separator string in between each string aggregated.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.Get4BytesHashCodeFast(System.String)">
            <summary>
            Get a 4 bytes string hash code, case-sensitive.
            </summary>
            <param name="thisString">The string to get hash code for.</param>
            <remarks>
            This method is about 4 times more performant than <i>StringComparer.OrdinalIgnoreCase.GetHashCode(str)</i>.<br />
            It processes characters two by two by using pointers.
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.Get8BytesHashCodeFast(System.String)">
            <summary>
            Get a 8 bytes string hash code, case-sensitive.
            </summary>
            <param name="thisString">The string to get hash code for.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.IsNullOrEmpty(System.String)">
            <summary>
            Returns <i>true</i> if <paramref name="str" /> is a null reference or an empty string.
            </summary>
            <remarks>
            An alternative to <i>string.IsNullOrEmpty()</i> with less characters.
            </remarks>
            <param name="str">The string reference.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.GetNullOrEmptyDescElseGetString(System.String)">
            <summary>
            If <paramref name="str" /> is null, returns the string "null".<br />
            If <paramref name="str" /> is empty, returns the string "empty".<br />
            Else return <paramref name="str" />.
            </summary>
            <param name="str">The string reference.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.GetWords(System.String)">
            <summary>
            Get the words in a code <paramref name="identifier" />.
            </summary>
            <param name="identifier">The code <paramref name="identifier" /></param> to extract words from.
            <remarks>
            Typically the <paramref name="identifier" /> is the <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" />.<br />
            For a complete behavior description, see this method source code and tests here: https://stackoverflow.com/a/48185710/27194
            </remarks>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsString.FirstCharToUpper(System.String)">
            <summary>
            Return <paramref name="word" /> with first char as upper case.
            </summary>
            <param name="word">The word to get first char as upper case.</param>
            <returns></returns>
        </member>
        <member name="T:NDepend.Helpers.ExtensionMethodsTimeSpan">
            <summary>
            Provides a set of extension methods dedicated to TimeSpan. 
            </summary>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.SByte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.SByte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.SByte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.SByte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.SByte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.TotalYears(System.TimeSpan)">
            <summary>
            Gets <paramref name="duration" />.<see cref="P:System.TimeSpan.TotalDays" /> divided by 365 days.
            </summary>
            <param name="duration">The duration to convert in number of years.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.TotalMonths(System.TimeSpan)">
            <summary>
            Gets <paramref name="duration" />.<see cref="M:NDepend.Helpers.ExtensionMethodsTimeSpan.TotalYears(System.TimeSpan)" /> multiplied by 12 months.
            </summary>
            <param name="duration">The duration to convert in number of years.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.SByte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.SByte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.SByte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.SByte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.SByte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Byte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Byte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Byte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Byte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Byte)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Byte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Byte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Byte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Byte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Byte})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Int16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Int16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Int16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Int16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Int16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Int16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Int16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Int16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Int16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Int16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.UInt16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.UInt16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.UInt16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.UInt16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.UInt16)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.UInt16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.UInt16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.UInt16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.UInt16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.UInt16})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Int32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Int32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Int32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Int32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Int32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Int32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Int32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Int32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Int32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Int32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.UInt32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.UInt32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.UInt32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.UInt32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.UInt32)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.UInt32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.UInt32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.UInt32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.UInt32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.UInt32})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Int64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Int64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Int64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Int64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Int64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.UInt64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nbMilliseconds" />.
            </summary>
            <param name="nbMilliseconds">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.UInt64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nbSeconds" />.
            </summary>
            <param name="nbSeconds">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.UInt64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nbMinutes" />.
            </summary>
            <param name="nbMinutes">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.UInt64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nbHours" />.
            </summary>
            <param name="nbHours">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.UInt64)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nbDays" />.
            </summary>
            <param name="nbDays">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.UInt64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of milli-seconds equals to <paramref name="nullableNbMilliseconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbMilliseconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMilliseconds">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.UInt64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of seconds equals to <paramref name="nullableNbSeconds" />.
            </summary>
            <remarks>if <paramref name="nullableNbSeconds" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSeconds">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.UInt64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of minutes equals to <paramref name="nullableNbMinutes" />.
            <remarks>if <paramref name="nullableNbMinutes" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            </summary>
            <param name="nullableNbMinutes">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.UInt64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of hours equals to <paramref name="nullableNbHours" />.
            </summary>
            <remarks>if <paramref name="nullableNbHours" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHours">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.UInt64})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total number of days equals to <paramref name="nullableNbDays" />.
            </summary>
            <remarks>if <paramref name="nullableNbDays" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDays">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Single)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of milli-seconds equals to floating value <paramref name="nbMillisecondsFloat" />.
            </summary>
            <param name="nbMillisecondsFloat">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Single)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of seconds equals to floating value <paramref name="nbSecondsFloat" />.
            </summary>
            <param name="nbSecondsFloat">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Single)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of minutes equals to floating value <paramref name="nbMinutesFloat" />.
            </summary>
            <param name="nbMinutesFloat">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Single)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of hours equals to floating value <paramref name="nbHoursFloat" />.
            </summary>
            <param name="nbHoursFloat">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Single)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of days equals to floating value <paramref name="nbDaysFloat" />.
            </summary>
            <param name="nbDaysFloat">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Single})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of milli-seconds equals to floating value <paramref name="nullableNbMillisecondsFloat" />.
            </summary>
            <remarks>if <paramref name="nullableNbMillisecondsFloat" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMillisecondsFloat">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Single})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of seconds equals to floating value <paramref name="nullableNbSecondsFloat" />.
            </summary>
            <remarks>if <paramref name="nullableNbSecondsFloat" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSecondsFloat">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Single})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of minutes equals to floating value <paramref name="nullableNbMinutesFloat" />.
            </summary>
            <remarks>if <paramref name="nullableNbMinutesFloat" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMinutesFloat">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Single})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of hours equals to floating value <paramref name="nullableNbHoursFloat" />.
            </summary>
            <remarks>if <paramref name="nullableNbHoursFloat" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHoursFloat">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Single})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of days equals to floating value <paramref name="nullableNbDaysFloat" />.
            </summary>
            <remarks>if <paramref name="nullableNbDaysFloat" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDaysFloat">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Decimal)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of milli-seconds equals to floating value <paramref name="nbMillisecondsDecimal" />.
            </summary>
            <param name="nbMillisecondsDecimal">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Decimal)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of seconds equals to floating value <paramref name="nbSecondsDecimal" />.
            </summary>
            <param name="nbSecondsDecimal">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Decimal)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of minutes equals to floating value <paramref name="nbMinutesDecimal" />.
            </summary>
            <param name="nbMinutesDecimal">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Decimal)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of hours equals to floating value <paramref name="nbHoursDecimal" />.
            </summary>
            <param name="nbHoursDecimal">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Decimal)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of days equals to floating value <paramref name="nbDaysDecimal" />.
            </summary>
            <param name="nbDaysDecimal">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Decimal})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of milli-seconds equals to floating value <paramref name="nullableNbMillisecondsDecimal" />.
            </summary>
            <remarks>if <paramref name="nullableNbMillisecondsDecimal" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMillisecondsDecimal">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Decimal})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of seconds equals to floating value <paramref name="nullableNbSecondsDecimal" />.
            </summary>
            <remarks>if <paramref name="nullableNbSecondsDecimal" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSecondsDecimal">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Decimal})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of minutes equals to floating value <paramref name="nullableNbMinutesDecimal" />.
            </summary>
            <remarks>if <paramref name="nullableNbMinutesDecimal" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMinutesDecimal">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Decimal})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of hours equals to floating value <paramref name="nullableNbHoursDecimal" />.
            </summary>
            <remarks>if <paramref name="nullableNbHoursDecimal" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHoursDecimal">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Decimal})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of days equals to floating value <paramref name="nullableNbDaysDecimal" />.
            </summary>
            <remarks>if <paramref name="nullableNbDaysDecimal" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDaysDecimal">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total double number of milli-seconds equals to double value <paramref name="nbMillisecondsDouble" />.
            </summary>
            <param name="nbMillisecondsDouble">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total double number of seconds equals to double value <paramref name="nbSecondsDouble" />.
            </summary>
            <param name="nbSecondsDouble">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total double number of minutes equals to double value <paramref name="nbMinutesDouble" />.
            </summary>
            <param name="nbMinutesDouble">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total double number of hours equals to double value <paramref name="nbHoursDouble" />.
            </summary>
            <param name="nbHoursDouble">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total double number of days equals to double value <paramref name="nbDaysDouble" />.
            </summary>
            <param name="nbDaysDouble">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMilliseconds(System.Nullable{System.Double})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of milli-seconds equals to floating value <paramref name="nullableNbMillisecondsDouble" />.
            </summary>
            <remarks>if <paramref name="nullableNbMillisecondsDouble" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMillisecondsDouble">The number of milli-seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToSeconds(System.Nullable{System.Double})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of seconds equals to floating value <paramref name="nullableNbSecondsDouble" />.
            </summary>
            <remarks>if <paramref name="nullableNbSecondsDouble" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbSecondsDouble">The number of seconds.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToMinutes(System.Nullable{System.Double})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of minutes equals to floating value <paramref name="nullableNbMinutesDouble" />.
            </summary>
            <remarks>if <paramref name="nullableNbMinutesDouble" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbMinutesDouble">The number of minutes.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Nullable{System.Double})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of hours equals to floating value <paramref name="nullableNbHoursDouble" />.
            </summary>
            <remarks>if <paramref name="nullableNbHoursDouble" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbHoursDouble">The number of hours.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToDays(System.Nullable{System.Double})">
            <summary>
            Gets a <see cref="T:System.TimeSpan" /> value, with total floating number of days equals to floating value <paramref name="nullableNbDaysDouble" />.
            </summary>
            <remarks>if <paramref name="nullableNbDaysDouble" /> is <i>null</i>, <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" /> is returned.</remarks>
            <param name="nullableNbDaysDouble">The number of days.</param>
            <exception cref="T:System.OverflowException">This exception is thrown if the expected time span is greater than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or lower than <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />.</exception>
        </member>
        <member name="T:NDepend.Helpers.StringFormattingKind">
            <summary>
            Define a string format, useful when extracting rule description from rule string for example.
            </summary>
        </member>
        <member name="F:NDepend.Helpers.StringFormattingKind.Raw">
            <summary>Raw</summary>
        </member>
        <member name="F:NDepend.Helpers.StringFormattingKind.Readable">
            <summary>Readable</summary>
        </member>
        <member name="F:NDepend.Helpers.StringFormattingKind.Html">
            <summary>Html</summary>
        </member>
        <member name="F:NDepend.Helpers.StringFormattingKind.Rtf">
            <summary>Rtf</summary>
        </member>
        <member name="T:NDepend.Issue.ISuppressMessage">
            <summary>
            Represents a valid usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> in source code with the category "NDepend".
            </summary>
            <remarks>
            Instances of this interfaces are produced at analysis time.<br />
            They can be obtained from <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.SuppressedMessages" />.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.ISuppressMessage.RuleIdOrCategory">
            <summary>
            Gets the rule-id or rule category that the corresponding usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> is relying on.
            </summary>
        </member>
        <member name="P:NDepend.Issue.ISuppressMessage.Scope">
            <summary>
            The scope of code element(s) on which to suppress issues.
            </summary>
            <remarks>
            If the returned value is <see cref="T:NDepend.Issue.SuppressMessageScope" />.<see cref="F:NDepend.Issue.SuppressMessageScope.ThisOnly" />, issues are suppressed only for <see cref="T:NDepend.Issue.ISuppressMessage" />.<see cref="P:NDepend.Issue.ISuppressMessage.CodeElement" /> and not for any of its child code element.<br />
            Else issues are suppressed eventually for <see cref="T:NDepend.Issue.ISuppressMessage" />.<see cref="P:NDepend.Issue.ISuppressMessage.CodeElement" /> (if it is matched by the scope value) and the child elements defined by the scope.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.ISuppressMessage.CodeElement">
            <summary>
            The code element on which to suppress issues.
            </summary>
            <remarks>
            Depending on the value of <see cref="P:NDepend.Issue.ISuppressMessage.Scope" />, issues can be suppressed only for this code-element, or for child of this code-element.
            </remarks>
        </member>
        <member name="T:NDepend.Issue.QualityGateStatus">
            <summary>
            Enumerate possible quality gate status.
            </summary>
        </member>
        <member name="F:NDepend.Issue.QualityGateStatus.Pass">
            <summary>Quality gate is passing, warn or fail conditions are not fulfilled.</summary>
        </member>
        <member name="F:NDepend.Issue.QualityGateStatus.Warn">
            <summary>Quality gate warn condition is fulfilled but fail condition is not fulfilled.</summary>
        </member>
        <member name="F:NDepend.Issue.QualityGateStatus.Fail">
            <summary>Quality gate fail condition is fulfilled.</summary>
        </member>
        <member name="T:NDepend.Issue.IIssuesSet">
            <summary>
            An issues-set hold all data about <see cref="P:NDepend.Issue.IIssuesSet.AllIssues" /> of <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" /> and makes convenient to browse issues, rule and code elements.
            </summary>
            <remarks>
            An issues-set can be created through <see cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSet(NDepend.CodeModel.ICodeBase,NDepend.TechnicalDebt.IDebtFormatter)" /> or <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)" />.<br />
            An issues-set gets filled through methods of <see cref="T:NDepend.Issue.IIssuesSetBuilder" /> available through <see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<br />
            An issues-set is not thread-safe. It is safe to call <see cref="T:NDepend.Issue.IIssuesSet" /> read-only methods concurrently from several threads
            but it is not safe to call these methods and <see cref="T:NDepend.Issue.IIssuesSetBuilder" /> methods concurrently from several threads, this would provoke corrupted state and exceptions.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.CodeBase">
            <summary>
            Gets the code base on which issues are computed.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.DebtFormatter">
            <summary>
            Gets the debt formatter that is used only in methods relative to debt-rating and debt-ratio.
            </summary>
            <remarks>
            Methods relative to debt-rating and debt-ratio that relies on this debt formatter are: <see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" />, <see cref="M:NDepend.Issue.IIssuesSet.CostToReachRating(NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)" />, <see cref="M:NDepend.Issue.IIssuesSet.CostToReachBetterRating(NDepend.CodeModel.ICodeElement)" />, <see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.Builder">
            <summary>
            Gets the issues-set builder, the only way to modify this issues-set.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllQualityGates">
            <summary>
            Gets all quality gates through <see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddQualityGate(NDepend.Issue.IQualityGate)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllRules">
            <summary>
            Gets all rules added through <see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllIssues">
            <summary>
            Gets all issues of all rules added through <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)" />.
            </summary>
            <remarks>
            The returned collection is lazy-computed and it is reset each time a rule is added or removed through <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllSuppressedIssues">
            <summary>
            Gets all issues of all rules suppressed through the usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            </summary>
            <seealso cref="P:NDepend.Issue.IRuleIssues.SuppressedIssues" />
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllIssuesCount">
            <summary>
            Gets the count all issues of all rules added through <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)" />.
            </summary>
            <remarks>This property getter has a constant time complexity.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllDebt">
            <summary>
            Gets the summed debt of all issues of all rules added through <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)" />.
            </summary>
            <remarks>This property getter has a constant time complexity.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllAnnualInterest">
            <summary>
            Gets the summed annual-interest of all issues of all rules added through <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />.<see cref="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)" />.
            </summary>
            <remarks>This property getter has a constant time complexity.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllBreakingPoint">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="P:NDepend.Issue.IIssuesSet.AllDebt" />,<see cref="P:NDepend.Issue.IIssuesSet.AllAnnualInterest" />).
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSet.AllAnnualInterestPercent">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="P:NDepend.Issue.IIssuesSet.AllDebt" />,<see cref="P:NDepend.Issue.IIssuesSet.AllAnnualInterest" />).
            </summary>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.Issues(NDepend.Issue.IRule)">
            <summary>
            Gets all issues of <paramref name="rule" />.
            </summary>
            <param name="rule">The rule on which to get the issues.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.SuppressedIssues(NDepend.Issue.IRule)">
            <summary>
            Gets all suppressed issues of <paramref name="rule" />.
            </summary>
            <param name="rule">The rule on which to get the suppressed issues.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)">
            <summary>
            Gets the summed debt of all issues of <paramref name="rule" />.
            </summary>
            <param name="rule">The rule on which to get the issues.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)">
            <summary>
            Gets the summed annual-interest of all issues of <paramref name="rule" />.
            </summary>
            <param name="rule">The rule on which to get the issues.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.IsViolated(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if the <paramref name="rule" /> is violated in the context of this issues-set.
            </summary>
            <remarks>
            The returned value is the value of <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> of the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object used when calling the method <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.<br />
            This property getter has a constant time complexity.
            </remarks>
            <param name="rule">The rule on which to get the is-violated value.</param>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.BreakingPoint(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" />).
            </summary>
            <param name="rule">The rule on which to get the is-violated value.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AnnualInterestPercent(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" />).
            </summary>
            <param name="rule">The rule on which to get the is-violated value.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if this issue set doesn't contain the <paramref name="rule" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.HasIssue(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value indicating whether the <paramref name="codeElement" /> has issues or not.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.HasDebt(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value indicating whether the <paramref name="codeElement" /> has debt or not.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            If <paramref name="codeElement" /> has only issues with <see cref="P:NDepend.Issue.IIssue.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" />, this getter returns <i>false</i>.
            This property getter has a constant time complexity.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.HasAnnualInterest(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value indicating whether the <paramref name="codeElement" /> has annual-interest or not.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            If <paramref name="codeElement" /> has only issues with <see cref="P:NDepend.Issue.IIssue.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" />, this getter returns <i>false</i>.
            This property getter has a constant time complexity.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.Issues(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets all issues relative to <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the summed debt of all issues relative to <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the summed annual-interest of all issues relative to <paramref name="codeElement" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.BreakingPoint(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AnnualInterestPercent(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllIssuesCountIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the count of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllIssuesIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets all issues relative to <paramref name="codeElement" />, and relative to all its child code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This property getter has a <i>O(</i><paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />.<see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" /><i>)</i> time complexity.<br />
            If <paramref name="codeElement" /> is <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" /> this method is equivalent to <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.AllIssues" />.<br />
            If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Issue.IIssuesSet.Issues(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the summed debt of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This property getter has a constant time complexity.<br />
            If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the summed annual-interest of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>
            This property getter has a constant time complexity.<br />
            If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllBreakingPointIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllAnnualInterestPercentIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <param name="codeElement">The code element.</param>
            <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets the debt rating of <paramref name="codeElement" /> in the range <see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> (very good) to <see cref="F:NDepend.TechnicalDebt.DebtRating.E" /> (very bad).
            </summary>
            <remarks>
            The debt to infer the rating is obtained through <see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).<br />
            This method implementation calls <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />.<br />
            This method returns <i>null</i> if <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
            </remarks>
            <param name="codeElement">The code element on which we infer the rating.</param>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.CostToReachRating(NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)">
            <summary>
            Returns the estimated effort to reach <paramref name="ratingToReach" />, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).
            </summary>
            <remarks>
            If the actual rating of <see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) is equals or better than <paramref name="ratingToReach" />, this method returns a zero duration <see cref="T:NDepend.TechnicalDebt.Debt" /> value.<br />
            This method implementation calls <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)" />.<br />
            This method returns <i>null</i> if <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
            </remarks>
            <param name="codeElement">The code element on which we infer the cost to reach <paramref name="ratingToReach" />.</param>
            <param name="ratingToReach">The rating to reach for <paramref name="codeElement" /></param>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.CostToReachBetterRating(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns the estimated cost, to reach a better rating, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).
            </summary>
            <remarks>
            <i>Better rating</i> means the rating just better than the actual one.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.D" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.C" />.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.B" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />, this method returns <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" />.<br />
            This method implementation calls <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachBetterRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />.<br />
            This method returns <i>null</i> if <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
            </remarks>
            <param name="codeElement">The code element on which we infer the cost to reach a better rating.</param>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)">
            <summary>
            Estimate the ratio of technical debt, measured through <see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />). 
            This ratio is expressed in percentage, of estimated debt, compared to the estimated time it would take to rewrite <paramref name="codeElement" /> from scratch. 
            </summary>
            <remarks>
            This method implementation calls <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSet.DebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
            and returns <i>null</i> if <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>,
            which happens when the PDB file is not found for the assembly containing <paramref name="codeElement" />,
            which means that <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>.
            </remarks>
            <param name="codeElement">The code element on which we infer the percentage of debt.</param>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="codeElement" /> doesn't belong to <see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllDebtIn(System.String)">
            <summary>
            Gets the summed debt of all issues of all rules with <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Category" /> equals to <paramref name="ruleCategory" />.
            </summary>
            <param name="ruleCategory">The rule category.</param>
            <remarks>
            This property getter has a time complexity of O(<see cref="P:NDepend.Issue.IIssuesSet.AllRules" />.Count()).
            </remarks>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(System.String)">
            <summary>
            Gets the summed annual-interest of all issues of all rules with <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Category" /> equals to <paramref name="ruleCategory" />.
            </summary>
            <param name="ruleCategory">The rule category.</param>
            <remarks>
            This property getter has a time complexity of O(<see cref="P:NDepend.Issue.IIssuesSet.AllRules" />.Count()).
            </remarks>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllBreakingPointIn(System.String)">
            <summary>
            Gets the breaking point of all issues of all rules with <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Category" /> equals to <paramref name="ruleCategory" />.
            </summary>
            <param name="ruleCategory">The rule category.</param>
            <remarks>
            This property getter has a time complexity of O(<see cref="P:NDepend.Issue.IIssuesSet.AllRules" />.Count()).
            </remarks>
        </member>
        <member name="M:NDepend.Issue.IIssuesSet.AllAnnualInterestPercentIn(System.String)">
            <summary>
            Gets the annual-interest-percent of all issues of all rules with <see cref="T:NDepend.Issue.IRule" />.<see cref="P:NDepend.Issue.IRule.Category" /> equals to <paramref name="ruleCategory" />.
            </summary>
            <param name="ruleCategory">The rule category.</param>
            <remarks>
            This property getter has a time complexity of O(<see cref="P:NDepend.Issue.IIssuesSet.AllRules" />.Count()).
            </remarks>
        </member>
        <member name="T:NDepend.Issue.IIssuesSetDiff">
            <summary>
            An issues-set-diff compares its <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> objects
            and makes convenient to browse diff information about issues, rule and code elements of these two issues sets.
            </summary>
            <remarks>
            An issues-set-diff can be created through <see cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSetDiff(NDepend.CodeModel.ICompareContext,NDepend.Issue.IIssuesSet,NDepend.Issue.IIssuesSet)" /> or <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)" />.<br />
            An issues-set-diff gets filled through methods of <see cref="T:NDepend.Issue.IIssuesSetDiffBuilder" /> available through <see cref="P:NDepend.Issue.IIssuesSetDiff.Builder" />.<br />
            An issues-set-diff is not thread-safe. It is safe to call <see cref="T:NDepend.Issue.IIssuesSetDiff" /> read-only methods concurrently from several threads
            but it is not safe to call these methods and <see cref="T:NDepend.Issue.IIssuesSetBuilder" /> methods concurrently from several threads, this would provoke corrupted state and exceptions.<br />
            When an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object compares two <see cref="T:NDepend.Issue.IIssuesSet" /> objects, the <see cref="T:NDepend.Issue.IIssuesSet" /> objects are not modified nor aware they are compared.
            As a consequence an <see cref="T:NDepend.Issue.IIssuesSet" /> object can be compared in several <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object. 
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet">
            <summary>
            Gets the newer issues set of this issues-set-diff.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet">
            <summary>
            Gets the older issues set of this issues-set-diff.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.CompareContext">
            <summary>
            Gets the <see cref="T:NDepend.CodeModel.ICompareContext" /> object used to compare <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.Builder">
            <summary>
            Gets the issues set builder, the only way to modify this issues set.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllDebtDiff">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllDebt" /> minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllDebt" />.
            </summary>
            <remarks>The result can be a positive, zero or negative <see cref="T:NDepend.TechnicalDebt.Debt" /> value.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiff">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllAnnualInterest" /> minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllAnnualInterest" />.
            </summary>
            <remarks>The result can be a positive, zero or negative <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllBreakingPointDiff">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="P:NDepend.Issue.IIssuesSetDiff.AllDebtDiff" />,<see cref="P:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiff" />).
            </summary>
            <remarks>The result can be a positive, zero or negative <see cref="T:System.TimeSpan" /> value.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestPercentDiff">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="P:NDepend.Issue.IIssuesSetDiff.AllDebtDiff" />,<see cref="P:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiff" />).
            </summary>
            <remarks>The result can be a positive, zero or negative value.</remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllIssuesAdded">
            <summary>
            Gets all issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. These issues are considered as added.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiff.AllIssuesFixed">
            <summary>
            Gets all issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. These issues are considered as added.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.
            </remarks>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)">
            <summary>
            Gets the <paramref name="qualityGate" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="qualityGate" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <remarks>If <paramref name="qualityGate" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
            <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)">
            <summary>
            Gets the <paramref name="qualityGate" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="qualityGate" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <remarks>If <paramref name="qualityGate" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
            <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IQualityGate)">
            <summary>
            Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IQualityGate)">
            <summary>
            Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IQualityGate)">
            <summary>
            Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
            </summary>
            <param name="qualityGate">The quality gate object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of the same qualityGate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.ValueDiff(NDepend.Issue.IQualityGate)">
            <summary>
            Gets the <see cref="P:NDepend.Issue.IQualityGate.Value" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> of <paramref name="qualityGate" />, 
            minus the <see cref="P:NDepend.Issue.IQualityGate.Value" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of <paramref name="qualityGate" />.
            </summary>
            <remarks>
            If the older or newer value is <i>null</i> returns <i>null</i>.
            </remarks>
            <param name="qualityGate">The quality gate object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of the same quality gate.</param>
            <exception cref="T:System.ArgumentException"><paramref name="qualityGate" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)">
            <summary>
            Gets the <paramref name="rule" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="rule" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <remarks>If <paramref name="rule" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
            <param name="rule">The rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)">
            <summary>
            Gets the <paramref name="rule" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="rule" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <remarks>If <paramref name="rule" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
            <param name="rule">The rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <param name="rule">The rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <param name="rule">The rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
            </summary>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsNotViolatedAnymore(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if <paramref name="rule" /> is present in both <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and is violated in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and not in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>,
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.WasNotViolatedAndIsViolated(NDepend.Issue.IRule)">
            <summary>
            Gets a value that indicates if <paramref name="rule" /> is present in both <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and is violated in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and not in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>,
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IssuesAdded(NDepend.Issue.IRule)">
            <summary>
            Gets all issues of <paramref name="rule" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. These issues are considered as added.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, all issues of <paramref name="rule" /> are returned.
            </remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IssuesFixed(NDepend.Issue.IRule)">
            <summary>
            Gets all issues of <paramref name="rule" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. These issues are considered as fixed.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, all issues of <paramref name="rule" /> are returned.
            </remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
            </remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
            </remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)" />).
            </summary>
            <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IRule)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)" />).
            </summary>
            <remarks>The returned value can be positive, zero or negative.</remarks>
            <param name="rule">The rule object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.ArgumentException"><paramref name="rule" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)">
            <summary>
            Gets the <paramref name="issue" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="issue" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <remarks>If <paramref name="issue" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
            <param name="issue">The issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)">
            <summary>
            Gets the <paramref name="issue" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="issue" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <remarks>If <paramref name="issue" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
            <param name="issue">The issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <param name="issue">The issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <param name="issue">The issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
            </summary>
            <remarks>
            if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.IsSuppressed" /> is <i>true</i>, this method returns <i>false</i>.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.WasAdded(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" /> is present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. It is then considered as an issue added.
            </summary>
            <remarks>
            If <paramref name="issue" /> is the <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the issue, this method returns <i>false</i>.
            <br />
            If <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.IsSuppressed" /> is <i>true</i>, this method returns <i>false</i>.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.WasFixed(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" /> is present in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. It is then considered as a fixed issue.
            </summary>
            <remarks>
            If <paramref name="issue" /> is the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> of the issue, this method returns <i>false</i>.
            <br />
            If <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.IsSuppressed" /> is <i>true</i>, this method returns <i>false</i>.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)">
            <summary>
            Gets <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.Debt" /> of <paramref name="issue" />, 
            minus  <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.Debt" /> of <paramref name="issue" />, 
            </summary>
            <remarks>
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)">
            <summary>
            Gets <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> of <paramref name="issue" />, 
            minus  <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> of <paramref name="issue" />, 
            </summary>
            <remarks>
            If <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IIssue)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)" />).
            </summary>
            <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IIssue)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)" />).
            </summary>
            <remarks>The returned value can be positive, zero or negative.</remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.SeverityChanged(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> is different for <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.SeverityDecreased(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> has decreased between <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.<br />
            Severity decrease means for example that <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" /> is considered <i>less</i> severe than <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" />.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.SeverityIncreased(NDepend.Issue.IIssue)">
            <summary>
            Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> has increased between <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.<br />
            Severity increase means for example that <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" /> is considered <i>more</i> severe than <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" />.
            </remarks>
            <param name="issue">The issue object can be the <see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="issue" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IssuesAdded(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets all issues on <paramref name="codeElement" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. These issues are considered as added.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
            If <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, all issues on <paramref name="codeElement" /> are returned.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.IssuesFixed(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets all issues on <paramref name="codeElement" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. These issues are considered as fixed.
            </summary>
            <remarks>
            The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, all issues on <paramref name="codeElement" /> are returned.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <remarks>The returned value can be positive, zero or negative.</remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AllDebtDiffIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiffIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
            The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>        
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AllBreakingPointDiffIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.AllDebtDiffIn(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiffIn(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestPercentDiffIn(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Issue.IIssuesSetDiff.AllDebtDiffIn(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiffIn(NDepend.CodeModel.ICodeElement)" />).
            </summary>
            <remarks>The returned value can be positive, zero or negative.</remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtRatioDiff(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, this method returns <i>null</i>.<br />
            <br />
            If <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
            or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />
            is <i>null</i>, this method returns <i>null</i>.<br />
            <br />
            The returned value can be <i>null</i> or else, positive, zero or negative.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtRatingChanged(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is different for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> and <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
            If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
            <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtRatingImproved(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is better for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> than for <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
            If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
            <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiff.DebtRatingWorsened(NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is better for <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> than for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />.
            </summary>
            <remarks>
            This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
            If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
            <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
            </remarks>
            <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.ArgumentException"><paramref name="codeElement" /> is not present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</exception>
        </member>
        <member name="T:NDepend.Issue.IIssuesSetBuilder">
            <summary>
            An issues-set-builder lets add and remove rules and issues in <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.
            </summary>
            <remarks>
            An issues-set can be created through <see cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSet(NDepend.CodeModel.ICodeBase,NDepend.TechnicalDebt.IDebtFormatter)" /> or <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)" />.<br />
            <br />
            When an <see cref="T:NDepend.Issue.IIssuesSet" /> is referenced by an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object, 
            the <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.Builder" /> must not be used to add an remove rules and issues, 
            the <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.Builder" /> object must be used instead.<br />
            <br />
            An issues-set is not thread-safe. It is safe to call <see cref="T:NDepend.Issue.IIssuesSet" /> methods concurrently from several threads
            but it is not safe to call these methods and <see cref="T:NDepend.Issue.IIssuesSetBuilder" /> methods concurrently from several threads, this would provoke corrupted state and exceptions.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet">
            <summary>
            The issues-set that is modified by this builder.
            </summary>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetBuilder.AddRule(NDepend.Issue.IRuleIssues)">
            <summary>
            Add a <paramref name="ruleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" /> and its <paramref name="ruleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> to <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Issue.IRuleIssues" /> object can be obtained from <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.<br />
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed. Hence the quality gates that rely on issues or debt might have a dirty state.
            </remarks>
            <param name="ruleIssues">The rule and issues to add.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" /> already contains the <paramref name="ruleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" />.<br />
            Also thrown if an issue of <paramref name="ruleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> have a <see cref="P:NDepend.Issue.IIssue.CodeElement" /> that doesn't belong to <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetBuilder.RemoveRule(NDepend.Issue.IRule)">
            <summary>
            Remove the <paramref name="rule" /> and its issues from <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.
            </summary>
            <param name="rule">The rule to remove.</param>
            <remarks>
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed and those that relies on issues and debt might have a dirty state.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" /> doesn't contain the <paramref name="rule" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetBuilder.AddQualityGate(NDepend.Issue.IQualityGate)">
            <summary>
            Add <paramref name="qualityGate" /> to <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.
            </summary>
            <param name="qualityGate">The quality gate to add.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" /> already contains <paramref name="qualityGate" />.<br />
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetBuilder.RemoveQualityGate(NDepend.Issue.IQualityGate)">
            <summary>
            Remove <paramref name="qualityGate" /> from <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" />.
            </summary>
            <param name="qualityGate">The quality gate to remove.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetBuilder.IssuesSet" /> doesn't contains <paramref name="qualityGate" />.<br />
            </exception>
        </member>
        <member name="T:NDepend.Issue.IIssuesSetDiffBuilder">
            <summary>
            An issues-set-diff-builder lets add and remove rules and issues in an <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.
            </summary>
            <remarks>
            An issues-set-diff can be created through <see cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSetDiff(NDepend.CodeModel.ICompareContext,NDepend.Issue.IIssuesSet,NDepend.Issue.IIssuesSet)" /> or <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)" />.<br />
            <br />
            When an <see cref="T:NDepend.Issue.IIssuesSet" /> is referenced by an <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object, 
            the <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.Builder" /> must not be used to add an remove rules and issues, 
            the <see cref="T:NDepend.Issue.IIssuesSetDiffBuilder" /> object must be used instead.<br />
            <br />
            An issues-set-diff is not thread-safe. It is safe to call <see cref="T:NDepend.Issue.IIssuesSetDiff" /> methods concurrently from several threads
            but it is not safe to call these methods and <see cref="T:NDepend.Issue.IIssuesSetDiffBuilder" /> methods concurrently from several threads, this would provoke corrupted state and exceptions.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff">
            <summary>
            The issues-set-diff that is modified by this builder.
            </summary>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddRule(NDepend.Issue.IRuleIssues,NDepend.Issue.IRuleIssues)">
            <summary>
            Add a <see cref="P:NDepend.Issue.IRuleIssues.Rule" /> and its <see cref="P:NDepend.Issue.IRuleIssues.Issues" /> to both <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <remarks>
            <paramref name="newerRuleIssues" /> and <paramref name="olderRuleIssues" /> are then compared in the <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<br />
            A <see cref="T:NDepend.Issue.IRuleIssues" /> object can be obtained from <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.<br />
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, <see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed. Hence the quality gates that rely on issues or debt might have a dirty state.
            </remarks>
            <param name="newerRuleIssues">The rule and issues to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.</param>
            <param name="olderRuleIssues">The rule and issues to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> already contains the <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" />
            or if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> already contains the <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" />.<br />
            <br />
            Also thrown if an issue of <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> have a <see cref="P:NDepend.Issue.IIssue.CodeElement" /> that doesn't belong to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />
            or if an issue of <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> have a <see cref="P:NDepend.Issue.IIssue.CodeElement" /> that doesn't belong to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddRuleInNewerIssuesSetOnly(NDepend.Issue.IRuleIssues)">
            <summary>
            Add a <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" /> and its <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> only.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Issue.IRuleIssues" /> object can be obtained from <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.<br />
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, <see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed. Hence the quality gates that rely on issues or debt might have a dirty state.
            </remarks>
            <param name="newerRuleIssues">The rule and issues to add.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> already contains the <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" />.<br />
            Also thrown if an issue of <paramref name="newerRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> have a <see cref="P:NDepend.Issue.IIssue.CodeElement" /> that doesn't belong to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddRuleInOlderIssuesSetOnly(NDepend.Issue.IRuleIssues)">
            <summary>
            Add a <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" /> and its <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> only.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Issue.IRuleIssues" /> object can be obtained from <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.<br />
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, <see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed. Hence the quality gates that rely on issues or debt might have a dirty state.
            </remarks>
            <param name="olderRuleIssues">The rule and issues to add.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> already contains the <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Rule" />.<br />
            Also thrown if an issue of <paramref name="olderRuleIssues" />.<see cref="P:NDepend.Issue.IRuleIssues.Issues" /> have a <see cref="P:NDepend.Issue.IIssue.CodeElement" /> that doesn't belong to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.RemoveRule(NDepend.Issue.IRule)">
            <summary>
            Remove the <paramref name="rule" /> and its issues from both <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <remarks>
            When a rule is added or removed <i>this</i>.<see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, <see cref="P:NDepend.Issue.IIssuesSet.AllQualityGates" /> are not recomputed. Hence the quality gates that rely on issues or debt might have a dirty state.
            </remarks>
            <param name="rule">The rule to remove. It can be defined in <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> contain the <paramref name="rule" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddQualityGate(NDepend.Issue.IQualityGate,NDepend.Issue.IQualityGate)">
            <summary>
            Add a <see cref="T:NDepend.Issue.IQualityGate" /> to both <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <param name="newerQualityGate">The quality gate to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.</param>
            <param name="olderQualityGate">The quality gate to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> already contains <paramref name="newerQualityGate" />,<br />
            or if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> already contains <paramref name="olderQualityGate" />
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddQualityGateInNewerIssuesSetOnly(NDepend.Issue.IQualityGate)">
            <summary>
            Add a <see cref="T:NDepend.Issue.IQualityGate" /> to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> only.
            </summary>
            <param name="newerQualityGate">The quality gate to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> already contains <paramref name="newerQualityGate" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.AddQualityGateInOlderIssuesSetOnly(NDepend.Issue.IQualityGate)">
            <summary>
            Add a <see cref="T:NDepend.Issue.IQualityGate" /> to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> only.
            </summary>
            <param name="olderQualityGate">The quality gate to add to <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> already contains <paramref name="olderQualityGate" />.
            </exception>
        </member>
        <member name="M:NDepend.Issue.IIssuesSetDiffBuilder.RemoveQualityGate(NDepend.Issue.IQualityGate)">
            <summary>
            Remove the <paramref name="qualityGate" /> from both <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
            </summary>
            <param name="qualityGate">The quality gate to remove. It can be defined in <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> nor <see cref="P:NDepend.Issue.IIssuesSetDiffBuilder.IssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> contain the <paramref name="qualityGate" />.
            </exception>
        </member>
        <member name="T:NDepend.Issue.IQualityGate">
            <summary>
            Represents a quality gate.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Name">
            <summary>
            The quality gate name.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Unit">
            <summary>
            The quality gate unit string.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.QueryString">
            <summary>
            The quality gate code query string.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Status">
            <summary>
            The quality gate status <see cref="F:NDepend.Issue.QualityGateStatus.Pass" />, <see cref="F:NDepend.Issue.QualityGateStatus.Warn" /> or <see cref="F:NDepend.Issue.QualityGateStatus.Fail" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Pass">
            <summary>
            Returns <i>true</i> if the quality gate is not satisfying its <i>warn</i> nor <i>fail</i> conditions.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Warn">
            <summary>
            Returns <i>true</i> if the quality gate is satisfying its <i>warn</i> conditions.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Fail">
            <summary>
            Returns <i>true</i> if the quality gate is satisfying its <i>fail</i> conditions.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.Value">
            <summary>
            Return the quality gate value.
            </summary>
            <remarks>
            A quality gate with a <i>null</i> value always pass.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.ValueString">
            <summary>
            Return the quality gate value string formatted with unit.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.MoreIsBad">
            <summary>
            Returns <i>true</i> if when the value of the quality gate is increasing, th quality is considered worst.
            </summary>
            <remarks>
            <i>MoreIsBad</i> is inferred from the <i>fail</i> if condition comparison operator.<br />
            If the comparison operator is higher or equals the threshold, then <i>MoreIsBad</i> is considered <i>true</i>.<br />
            If the comparison operator is lower the threshold, then <i>MoreIsBad</i> is considered <i>false</i>.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.FailThreshold">
            <summary>
            Gets the quality gate fail threshold.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.FailThresholdString">
            <summary>
            Return the quality gate fail threshold string formatted (without unit).
            </summary>
        </member>
        <member name="P:NDepend.Issue.IQualityGate.WarnThreshold">
            <summary>
            Gets the quality gate warn threshold or <i>null</i> if the warn threshold is not defined.
            </summary>
        </member>
        <member name="T:NDepend.Issue.IRecord">
            <summary>
            The purpose of this interface is only to be downcasted to a <see cref="T:NDepend.CodeQuery.RecordBase" /> object.
            </summary>
            <remarks>
            This interface is needed because the namespace <i>NDepend.CodeQuery</i> is higher level than the namespace <i>NDepend.Issue</i>
            but an <seealso cref="T:NDepend.Issue.IIssue" /> object can reference a <seealso cref="T:NDepend.CodeQuery.RecordBase" /> object (defined in <i>NDepend.CodeQuery</i>) through <seealso cref="P:NDepend.Issue.IIssue.Record" />.
            </remarks>
        </member>
        <member name="T:NDepend.Issue.IRuleIssues">
            <summary>
            Represents the result of the method call <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRuleIssues.Rule">
            <summary>
            Gets the rule object used as a parameter of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRuleIssues.IsRuleViolated">
            <summary>
            Gets the value of <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> of the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object used as a parameter of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRuleIssues.Issues">
            <summary>
            Gets the list of issues computed from the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object used as a parameter of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRuleIssues.SuppressedIssues">
            <summary>
            Gets the list of issues suppressed through the usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            </summary>
        </member>
        <member name="T:NDepend.Issue.IssueReferenceRecord">
            <summary>
            This enumeration indicates if an <see cref="T:NDepend.Issue.IIssue" /> object is referencing the record or not.
            </summary>
        </member>
        <member name="F:NDepend.Issue.IssueReferenceRecord.No">
            <summary>
            The issue doesn't reference the record.
            </summary>
        </member>
        <member name="F:NDepend.Issue.IssueReferenceRecord.Yes">
            <summary>
            The issue does reference the record.
            </summary>
        </member>
        <member name="T:NDepend.Issue.RuleIdOrCategory">
            <summary>
            Represents the rule-id or the rule category defined in a usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            </summary>
            <remarks>
            Such object is returned by <see cref="T:NDepend.Issue.ISuppressMessage" />.<see cref="P:NDepend.Issue.ISuppressMessage.RuleIdOrCategory" />.<br />
            Only one property is returning <i>true</i> in <see cref="P:NDepend.Issue.RuleIdOrCategory.IsRuleId" />, <see cref="P:NDepend.Issue.RuleIdOrCategory.IsCategory" />, <see cref="P:NDepend.Issue.RuleIdOrCategory.SuppressAllIssues" />.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.RuleIdOrCategory.IsRuleId">
            <summary>
            Returns <i>true</i> if the corresponding usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> relies on a rule-id.
            </summary>
            <remarks>
            For example <i>[SuppressMessage("NDepend", "ND1001")]</i> relies on the NDepend rule-id "ND1001".
            </remarks>
        </member>
        <member name="P:NDepend.Issue.RuleIdOrCategory.IsCategory">
            <summary>
            Returns <i>true</i> if the corresponding usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> relies on a category.
            </summary>
            <remarks>
            For example <i>[SuppressMessage("NDepend.CodeSmells", "ND1001")]</i> relies on the NDepend category "CodeSmells".
            This category can be declared as the group name "Code Smells" in the rules-set since spaces are removed from group names to match categories.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.RuleIdOrCategory.SuppressAllIssues">
            <summary>
            Returns <i>true</i> if the corresponding usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> suppresses all issues.
            </summary>
            <remarks>
            For example <i>[SuppressMessage("NDepend", "")]</i> means that all NDepend issues are suppressed.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.RuleIdOrCategory.Value">
            <summary>
            Returns the rule-id or the rule category defined in a usage of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            </summary>
            <remarks>
            If an empty string is returned it means that we are in the <see cref="P:NDepend.Issue.RuleIdOrCategory.SuppressAllIssues" /> situation.
            </remarks>
        </member>
        <member name="M:NDepend.Issue.RuleIdOrCategory.GetHashCode">
            <summary>
            Overrides GetHashCode() since RuleIdOrCategory objects are used to index array of ISuppressMessage in dictionaries.
            </summary>
        </member>
        <member name="M:NDepend.Issue.RuleIdOrCategory.Equals(System.Object)">
            <summary>
            Overrides Equals() since RuleIdOrCategory objects are used to index array of ISuppressMessage in dictionaries.
            </summary>
        </member>
        <member name="T:NDepend.Issue.SuppressMessageScope">
            <summary>
            Scope on which a <see cref="T:NDepend.Issue.ISuppressMessage" /> object is applied.
            </summary>
            <remarks>
            Scope can be use to ignore issues of a rule on all methods and fields defined in a type or in a namespace.<br />
            Several scopes can be provided in the <b>SuppressMessageAttribute.Scope</b>, separated with a space like "assembly namespace type".<br />
            Notice the special Scope value "deep" that means this code element and all its child code element.<br />
            For an assembly, Scope value "deep" means <see cref="F:NDepend.Issue.SuppressMessageScope.Module" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Namespace" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Type" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Method" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Field" />.<br />
            For a namespace, Scope value "deep" means <see cref="F:NDepend.Issue.SuppressMessageScope.Namespace" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Type" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Method" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Field" />.<br />
            For a type, Scope value "deep" means <see cref="F:NDepend.Issue.SuppressMessageScope.Type" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Method" /> | <see cref="F:NDepend.Issue.SuppressMessageScope.Field" />.<br />
            For a method, Scope value "deep" means <see cref="F:NDepend.Issue.SuppressMessageScope.Method" /> only (no child code elements for a method).<br />
            For a field, Scope value "deep" means <see cref="F:NDepend.Issue.SuppressMessageScope.Field" /> only (no child code elements for a field).<br />
            </remarks>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.ThisOnly">
            <summary>
            Scope this-only means that corresponding issues are suppressed only for the <see cref="T:NDepend.Issue.ISuppressMessage" />.<see cref="P:NDepend.Issue.ISuppressMessage.CodeElement" />, and not for any of its child code element.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Module">
            <summary>
            Scope Module (which means assembly wide), use the string "module" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Namespace">
            <summary>
            Scope Namespace, use the string "namespace" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Type">
            <summary>
            Scope Type, use the string "type" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Method">
            <summary>
            Scope Method, use the string "method" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Field">
            <summary>
            Scope Field, use the string "Field" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
        </member>
        <member name="F:NDepend.Issue.SuppressMessageScope.Member">
            <summary>
            Scope Member, use the string "member" in the <b>SuppressMessageAttribute.Scope</b>.
            </summary>
            <remarks>
            Member means methods and fields.
            </remarks>
        </member>
        <member name="T:NDepend.Issue.ExtensionMethodsIssue">
            <summary>
            This static class provides various extension methods related to Issue objects.
            </summary> 
        </member>
        <member name="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSet(NDepend.CodeModel.ICodeBase,NDepend.TechnicalDebt.IDebtFormatter)">
            <summary>
            Create an issues-set object dedicated to hold issues on <paramref name="codeBase" />.
            </summary>
            <remarks>
            The returned issue set is empty, it doesn't contains any rule nor issue.<br />
            An <see cref="T:NDepend.Issue.IIssuesSetBuilder" /> instance can be obtained through <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.Builder" />
            to fill the returned issues-set with rules and issues.<br />
            This overload of the <b>CreateIssuesSet</b> method doesn't take a list of suppressed messages. No issue will be ignored because of the usage of usages of <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" /> in the returned issues-set.
            </remarks>
            <param name="codeBase">The code base.</param>
            <param name="debtFormatter">Debt rating and debat ratio values obtained through the returned issues-set will be formatted through this debt formatter.</param>
        </member>
        <member name="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSetDiff(NDepend.CodeModel.ICompareContext,NDepend.Issue.IIssuesSet,NDepend.Issue.IIssuesSet)">
            <summary>
            Create an issues-set-diff object dedicated compare <paramref name="newerIssuesSet" /> and <paramref name="olderIssuesSet" />
            and makes convenient to browse diff information about issues, rule and code elements of these two issues sets.
            </summary>
            <remarks>
            The returned issue-set-diff has already rules and issues of <paramref name="newerIssuesSet" /> and <paramref name="olderIssuesSet" /> compared, if these issues-set are not empty.<br />
            An <see cref="T:NDepend.Issue.IIssuesSetDiffBuilder" /> instance can be obtained through <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="P:NDepend.Issue.IIssuesSetDiff.Builder" />
            to fill the both issues-sets with rules and issues.<br />
            <br />
            After calling this methods, <paramref name="newerIssuesSet" /> and <paramref name="olderIssuesSet" /> <see cref="P:NDepend.Issue.IIssuesSet.Builder" /> must not be called anymore
            to changerules and issues of <paramref name="newerIssuesSet" /> and <paramref name="olderIssuesSet" />, else this will provoque corrupted states and exceptions.
            </remarks>
            <param name="compareContext">The compare context that compares both <paramref name="newerIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" /> and <paramref name="olderIssuesSet" />.<see cref="P:NDepend.Issue.IIssuesSet.CodeBase" />.</param>
            <param name="newerIssuesSet">The <see cref="T:NDepend.Issue.IIssuesSet" /> object that will play the role of the newer rules and issues snapshot from which to compare.</param>
            <param name="olderIssuesSet">The <see cref="T:NDepend.Issue.IIssuesSet" /> object that will play the role of the baseline on which to compare rules and issues.</param>
        </member>
        <member name="M:NDepend.Issue.ExtensionMethodsIssue.ComputeSuppressedMessagesOnBaseline(NDepend.CodeModel.ICompareContext,System.Collections.Generic.IDictionary{NDepend.Issue.RuleIdOrCategory,System.Collections.Generic.IReadOnlyList{NDepend.Issue.ISuppressMessage}})">
            <summary>
            Create a dictionary of suppressed messages indexed by <see cref="T:NDepend.Issue.RuleIdOrCategory" /> objects defined on <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />, 
            from a similar dictionary defined on <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </summary>
            <param name="compareContext">The compare context used to resolve baseline code elements from current code elements.</param>
            <param name="suppressedMessages">The dictionary of suppressed message indexed by <see cref="T:NDepend.Issue.RuleIdOrCategory" /> objects defined on <paramref name="compareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.</param>
            <remarks>If a baseline code element is not resolved, the <see cref="T:NDepend.Issue.ISuppressMessage" /> objects related to this code element won't be present in the returned dictionary of suppressed messages.</remarks>
        </member>
        <member name="M:NDepend.Issue.ExtensionMethodsIssue.GetImage``1(NDepend.Issue.QualityGateStatus)">
            <summary>
            Get the image that represents the <paramref name="qualityGateStatus" />.
            </summary>
            <param name="qualityGateStatus">The quality gate status</param>
            /// <typeparam name="T">So far the GetImage&lt;T&gt;() parameter type T must be System.Drawing.Image. This requirement might evolve in future version when other UI framework will be supported.</typeparam>
        </member>
        <member name="T:NDepend.Issue.IIssue">
            <summary>
            An instance of this class represents an issue.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssue.Rule">
            <summary>
            The rule from which the issue is inferred.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssue.CodeElement">
            <summary>
            Gets the code element that has the issue.
            </summary>
            <remarks>
            A code rule can rely on a <see cref="T:NDepend.CodeModel.ICompareContext" /> object to query the diff between 2 snapshots of a code base, the newer snapshot and the baseline snapshot. 
            For example rules to detect <i>API breaking changes</i> fall in this category.
            Such rule can match code elements in the baseline code base snapshot.<br />
            <br />
            However the issue code element returned by this property necessarily belongs to the newer code base snapshot.
            In such situation <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" /> is the matched code element declared in the baseline code base, 
            and the code element returned by this property is the most inner parent code element of <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" />,
            that has an equivalent in the newer code base snapshot.
            For example if a removed method is matched, and its parent type hasen't been removed, this property returns its parent type declared in the newer code base.<br />
            <br />
            Notice the particular case when the matched code element is an assembly removed or is a namespace/type/method/field declared in an assembly removed.
            In such situation there is no <i>most inner parent code element that has an equivalent in the newer code base snapshot</i>
            and this property returns the first application assembly of newer code base.
            <br />
            The reason an issue must be be declared in the newer code base snapshot, is because an <see cref="T:NDepend.Issue.IIssuesSet" /> object
            is related to a code base snapshot and not to the diff between 2 snapshots of a code base.
            It wouldn't make sense that an <see cref="T:NDepend.Issue.IIssuesSet" /> object contain some issues declared on elements of the baseline snapshot.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssue.CodeElementInBaseline">
            <summary>
            Gets the code element declared in the baseline code base snapshot, that has the issue, or <i>null</i>.
            </summary>
            <remarks>
            A code rule can rely on an <see cref="T:NDepend.CodeModel.ICompareContext" /> object to query the diff between 2 snapshots of a code base, the newer snapshot and the baseline snapshot. 
            For example rules to detect <i>API breaking changes</i> fall in this category.
            Such rule can match code elements in the baseline code base snapshot.<br />
            <br />
            However the issue code element returned by <see cref="T:NDepend.CodeModel.ICodeElement" /> necessarily belongs to the newer code base snapshot.
            In such situation this property returns the matched code element declared in the baseline code base, 
            and the code element returned by <see cref="P:NDepend.Issue.IIssue.CodeElement" /> is the most inner parent code element of <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" />,
            that has an equivalent in the newer code base snapshot.
            <br />
            If not in the situation, which means that the matched code element is declared in the newer code base snapshot,
            this property returns <i>null</i>.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssue.CodeElementInBaselineWasRemoved">
            <summary>
            Gets a value indicating whether the code element declared in the baseline code base snapshot has no equivalent in the newer code base snapshot and thus, can be considered as removed..
            </summary>
            <remarks>
            A code rule can rely on an <see cref="T:NDepend.CodeModel.ICompareContext" /> object to query the diff between 2 snapshots of a code base, the newer snapshot and the baseline snapshot. 
            For example rules to detect <i>API breaking changes</i> fall in this category.
            Such rule can match code elements in the baseline code base snapshot.<br />
            <br />
            In such situation <see cref="P:NDepend.Issue.IIssue.CodeElement" /> returns the matched code element declared in the newer code base,
            and <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" /> returns the matched code element declared in the baseline code base.
            However if <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" /> has been removed and thus, has no equivalent in the newer code base snapshot,
            the property <see cref="P:NDepend.Issue.IIssue.CodeElement" /> returns the most inner parent code element of <see cref="P:NDepend.Issue.IIssue.CodeElementInBaseline" />,
            that has an equivalent in the newer code base snapshot, and this property returns <i>true</i> to inform of this situation.
            If not in this situation, this property returns <i>false</i>.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssue.Debt">
            <summary>
            The estimated technical-debt generated by this issue, or in others words, the estimated effort to fix the issue.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssue.AnnualInterest">
            <summary>
            The estimated annual-interest generated by this issue, or in others words, the cost per year, to leave the issue unfixed.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssue.Severity">
            <summary>
            The estimated severity of the issue.
            </summary>
            <remarks>
            The severity of an issue is inferred from <see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> and thresholds in <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<br />
            The method <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToSeverity(NDepend.TechnicalDebt.AnnualInterest)" /> is used to obtain the severity.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IIssue.BreakingPoint">
            <summary>
            Gets the time point from now when the estimated cost-to-not-fix this issue will reach the estimated cost-to-fix this issue. This time point is named the <strong>breaking point</strong>.
            </summary>
            <remarks>
            The breaking point is the issue <see cref="P:NDepend.Issue.IIssue.Debt" /> divided by the issue <see cref="P:NDepend.Issue.IIssue.AnnualInterest" />.<br />
            For example if the estimated cost-to-fix the issue (this issue <see cref="P:NDepend.Issue.IIssue.Debt" />) is equal to 10 man-days, and the estimated cost-to-not-fix the issue is equal to 2 man-days per year 
            (this is this issue <see cref="P:NDepend.Issue.IIssue.AnnualInterest" />) then the issue breaking point is equal to 5 years from now.<br />
            Notice that a breaking point <i>lower than</i> a year means that during the next 12 monthes, it would be cheaper to fix the issue than not to fix it.<br />
            If this issue <see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> is equal to <see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" />, this getter returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            </remarks>
            <seealso cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />
        </member>
        <member name="P:NDepend.Issue.IIssue.AnnualInterestPercent">
            <summary>
            Gets this issue estimated annual interest percent, expressed in percent per year.
            </summary>
            <remarks>
            This issue annual interest percent is equal to 100 multiplied by this issue <see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> divided by this issue <see cref="P:NDepend.Issue.IIssue.Debt" />.<br />
            For example if the estimated cost-to-fix the issue (this issue <see cref="P:NDepend.Issue.IIssue.Debt" />) is equal to 10 man-days, and the estimated cost-to-not-fix the issue is equal to 2 man-days per year 
            (this is this issue <see cref="P:NDepend.Issue.IIssue.AnnualInterest" />) then the debt annual interest percent is 20% per year.<br />
            Notice that an annual interest percent <i>higher than</i> 100% means that during the next 12 monthes, it would be cheaper to fix the issue than not to fix it.<br />
            If this issue <see cref="P:NDepend.Issue.IIssue.Debt" /> is equal to <see cref="F:NDepend.TechnicalDebt.Debt.Zero" />, this getter returns <i>zero</i>.
            </remarks>
            <seealso cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />
        </member>
        <member name="P:NDepend.Issue.IIssue.ReferenceRecord">
            <summary>
            Gets a value indicating if the issues is referencing the record.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IIssue.Record">
            <summary>
            Gets the record of the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> corresponding to this issue.
            </summary>
            <returns>
            Returns record of the issue if <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord)" />
            has been called with the value <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.Yes" />,
            else returns <i>null</i>.
            </returns>
        </member>
        <member name="P:NDepend.Issue.IIssue.ColumnsNames">
            <summary>
            Gets the columns names corresponding to this issue <see cref="P:NDepend.Issue.IIssue.Record" />.
            </summary>
            <returns>
            Returns the column names if <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult,NDepend.Issue.IssueReferenceRecord)" />
            has been called with the value <see cref="T:NDepend.Issue.IssueReferenceRecord" />.<see cref="F:NDepend.Issue.IssueReferenceRecord.Yes" />,
            else returns <i>null</i>.<br />
            The columns names are the same than the ones obtained through <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.ColumnsNames" />.
            </returns>
            <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.ColumnsNames" />
        </member>
        <member name="P:NDepend.Issue.IIssue.SourceFileDeclAvailable">
            <summary>Gets a value indicating whether source file declaration of this issue is available.</summary>
            <remarks>
            So far only C# code is parsed and also, source file declarations for abstract methods and fields are not retreived.
            This situation will evolve in the future.
            </remarks>
            <returns>
            <b>true</b> if source file declaration is available for this code element.
            </returns>
            <seealso cref="P:NDepend.Issue.IIssue.SourceDecl" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="P:NDepend.Issue.IIssue.SourceDecl">
            <summary>
            Returns the source file declaration of this issue, or <i>null</i> if not <see cref="P:NDepend.Issue.IIssue.SourceFileDeclAvailable" />.
            </summary>
            <seealso cref="P:NDepend.Issue.IIssue.SourceFileDeclAvailable" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="P:NDepend.Issue.IIssue.IsSuppressed">
            <summary>
            Returns <i>true</i> is this issue has been suppresses by the usage of a <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute" />.
            </summary>
        </member>
        <member name="T:NDepend.Issue.IRule">
            <summary>
            Represents a rule from which <see cref="T:NDepend.Issue.IIssue" /> are inferred.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRule.Name">
            <summary>
            The rule name.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRule.Category">
            <summary>
            Get the rule category.
            </summary>
            <remarks>
            For a Code query rule, returns the name of the group that contains the rule.<br />
            If several groups are involved, returns groups names with " \ " as separator.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IRule.Id">
            <summary>
            The rule id like "ND1000" for example.
            </summary>
            <remarks>
            If the rule is defined with an explicit-id like "ND1000:AvoidTypesTooBig", the explicit-id is not returned here.<br />
            If the rule has no id, a string empty is returned.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IRule.ExplicitId">
            <summary>
            The rule explicit-id like "AvoidTypesTooBig" for example.
            </summary>
            <remarks>
            If the rule is defined like "ND1000:AvoidTypesTooBig", only explicit-id returned here.<br />
            If the rule has no explicit-id, a string empty is returned.
            </remarks>
        </member>
        <member name="P:NDepend.Issue.IRule.Provider">
            <summary>
            The rule provider.
            </summary>
        </member>
        <member name="P:NDepend.Issue.IRule.IsCritical">
            <summary>
            Is the rule considered critical or not.
            </summary>
        </member>
        <member name="M:NDepend.Issue.IRule.TryGetDescription(NDepend.Helpers.StringFormattingKind,System.String@)">
            <summary>
            Try get the rule description if available, formatted according to <paramref name="stringFormattingKind" />.
            </summary>
            <returns><i>true</i> if the rule description is available.</returns>
            <param name="stringFormattingKind">The formatting of the returned description.</param>
            <param name="ruleDescription">The rule description formatted.</param>
        </member>
        <member name="M:NDepend.Issue.IRule.TryGetHowToFix(NDepend.Helpers.StringFormattingKind,System.String@)">
            <summary>
            Try get how-to-fix-rule explanation if available, formatted according to <paramref name="stringFormattingKind" />.
            </summary>
            <returns><i>true</i> if the how-to-fix-rule explanation is available.</returns>
            <param name="stringFormattingKind">The formatting of the returned how-to-fix-rule explanation.</param>
            <param name="ruleHowToFix">The rule how-to-fix-rule explanations formatted.</param>
        </member>
        <member name="T:NDepend.Issue.RuleProvider">
            <summary>
            Enumerate the possible rule providers.
            </summary>
        </member>
        <member name="F:NDepend.Issue.RuleProvider.CodeQueryRule">
            <summary>
            Rule obtained from a NDepend code query prefixed with <i>warnif count</i>.
            </summary>
        </member>
        <member name="T:NDepend.Project.IDEFile">
            <summary>
            Define a reference to a Visual Studio solution or project file. From this Visual Studio file one or several application assemblies are inferred to be analyzed.
            </summary>
        </member>
        <member name="F:NDepend.Project.IDEFile.DEFAULT_FILTERS">
            <summary>
            In most scenarios it is not useful to analyze also test assemblies so they get filtered out per default.
            </summary>
        </member>
        <member name="M:NDepend.Project.IDEFile.#ctor(NDepend.Path.IFilePath,System.String,NDepend.Project.IDEFileRootDirResolvingInfo)">
            <summary>
            Build a Visual Studio file object.
            </summary>
            <param name="filePath">The file path</param>
            <param name="filters">The filters used to filter out some assemblies from analysis.</param>
            <param name="rootDirResolvingInfo">The information to eventually resolve components in a root folder.</param>
        </member>
        <member name="P:NDepend.Project.IDEFile.FilePath">
            <summary>
             Gets the Visual Studio solution or project file path.
            </summary>
        </member>
        <member name="P:NDepend.Project.IDEFile.Filters">
            <summary>
             Gets a set of '+' and '-' filters on assemblies names. Such filters are used to filter out some assemblies from analysis.
            </summary>
            <remarks>
             The filters are applied case insensitive.<br />
             Typically the filter "-Test" will filter out test assemblies.<br />
             The filters are processed with the <see cref="T:NDepend.Helpers.StringFilter" /> implementation.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IDEFile.Configuration">
            <summary>
             Gets the Visual Studio solution or project configuration to analyze. This property is not yet used and DEBUG assemblies are preferred.
            </summary>
            <remarks>
             This property might be used in future versions. For now its default value is "DEBUG|AnyCPU" but it is not used.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IDEFile.RootDirResolvingInfo">
            <summary>
            Gets the settings used to eventually resolve components in a root folder.
            </summary>
        </member>
        <member name="T:NDepend.Project.IDEFileRootDirResolvingInfo">
            <summary>
            Define the information to eventually resolve components of an <see cref="T:NDepend.Project.IDEFile" /> in a root folder.
            </summary>
        </member>
        <member name="F:NDepend.Project.IDEFileRootDirResolvingInfo.Default">
            <summary>
            Gets the default information.
            </summary>
        </member>
        <member name="P:NDepend.Project.IDEFileRootDirResolvingInfo.HintsDefaultValue">
            <summary>
            The default root folder resolving hints separated by the Vertical Bar | character.
            </summary>
            <remarks>
            The target framework monikers (TFM) hints netcoreapp* and netstandard* are not provided because the hint net* is more general.
            </remarks>
        </member>
        <member name="F:NDepend.Project.IDEFileRootDirResolvingInfo.HintsSeparatorChar">
            <summary>
            The Vertical Bar | character used to separate the hints in the <see cref="P:NDepend.Project.IDEFileRootDirResolvingInfo.VerticalBarSeparatedHints" />
            </summary>
            <remarks>
            The coma character , has not been chosen because a folder name can contain this character.<br />
            The colon : character has not been chosen because it is less visible than the vertical bar | character.
            </remarks>
        </member>
        <member name="F:NDepend.Project.IDEFileRootDirResolvingInfo.TimeOutInSecondsDefault">
            <summary>
            The default root folder resolving time-out value.
            </summary>
        </member>
        <member name="F:NDepend.Project.IDEFileRootDirResolvingInfo.TimeOutInSecondsMin">
            <summary>
            The minimum root folder resolving time-out value.
            </summary>
        </member>
        <member name="F:NDepend.Project.IDEFileRootDirResolvingInfo.TimeOutInSecondsMax">
            <summary>
            The maximum root folder resolving time-out value.
            </summary>
        </member>
        <member name="M:NDepend.Project.IDEFileRootDirResolvingInfo.#ctor(System.Boolean,NDepend.Path.IRelativeDirectoryPath,System.String,System.Int32)">
            <summary>
            Build a IDEFileRootDirResolvingInfo object.
            </summary>
            <param name="enabled">The a value indicating if the components resolving heuristic is based on resolving from the IDE file, or from searching recursively into the root folder.</param>
            <param name="rootDirRelativeToIDEFile">The path to the root directory, relative to the parent folder of the <see cref="T:NDepend.Project.IDEFile" />.<see cref="P:NDepend.Project.IDEFile.FilePath" />.</param>
            <param name="verticalBarSeparatedHints">The hints used by the root folder heuristic, separated by the vertical bar character |.</param>
            <param name="timeOutInSeconds">The timeout in seconds of the root folder heuristic execution.</param>
        </member>
        <member name="P:NDepend.Project.IDEFileRootDirResolvingInfo.Enabled">
            <summary>
            Gets a value indicating if the components resolving heuristic is based on resolving from the IDE file, or from searching recursively into the root folder.
            </summary>
        </member>
        <member name="P:NDepend.Project.IDEFileRootDirResolvingInfo.RootDirRelativeToIdeFile">
            <summary>
            Gets the path to the root directory, relative to the parent folder of the <see cref="T:NDepend.Project.IDEFile" />.<see cref="P:NDepend.Project.IDEFile.FilePath" />.
            </summary>
        </member>
        <member name="P:NDepend.Project.IDEFileRootDirResolvingInfo.VerticalBarSeparatedHints">
            <summary>
            Gets the hints used by the root folder heuristic, separated by the vertical bar character |.
            </summary>
        </member>
        <member name="P:NDepend.Project.IDEFileRootDirResolvingInfo.TimeOutInSeconds">
            <summary>
            Gets the timeout in seconds of the root folder heuristic execution.
            </summary>
        </member>
        <member name="T:NDepend.Project.IGraphFileRef">
            <summary>
             Represents a reference to a file that describes a dependency graph.
            </summary>
        </member>
        <member name="P:NDepend.Project.IGraphFileRef.Path">
            <summary>
             Gets the graph file path.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectGithub">
            <summary>
            Hold project settings related to GitHub.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectGithub.Repo">
            <summary>
            The GitHub repository, <i>null</i> is not defined.
            </summary>
            <remarks>
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Github_Repo" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectGithub.Account">
            <summary>
            The GitHub account, <i>null</i> is not defined.
            </summary>
                  /// <remarks>
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Github_Account" /> activated.
            </remarks>
        </member>
        <member name="T:NDepend.Project.IProjectGraphFiles">
            <summary>
            Represents the list of graph files referenced by this project.
            </summary>
            <seealso cref="N:NDepend.CodeQuery" />
        </member>
        <member name="P:NDepend.Project.IProjectGraphFiles.GraphFilesRef">
            <summary>
            Gets all graph files referenced by this project. 
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectGraphFiles.TryAdd(NDepend.Path.IFilePath)">
            <summary>
            Add a graph file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is already a graph file referenced by this project, with <see cref="T:NDepend.Project.IGraphFileRef" />.<see cref="P:NDepend.Project.IGraphFileRef.Path" /> equals to <paramref name="filePath" />
            else the graph file gets added and the method returns <i>true</i>.
            </returns>
            <remarks>
            If this method adds a graph file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.GraphFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePath">The graph file path.</param>
        </member>
        <member name="M:NDepend.Project.IProjectGraphFiles.TryChangeGraphFileRefPath(NDepend.Path.IFilePath,NDepend.Path.IFilePath)">
            <summary>
            Change the path of a graph file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is no graph file with <see cref="T:NDepend.Project.IGraphFileRef" />.<see cref="P:NDepend.Project.IGraphFileRef.Path" /> equals to <paramref name="filePathOld" />.
            </returns>
            <remarks>
            If there is a graph file with <see cref="T:NDepend.Project.IGraphFileRef" />.<see cref="P:NDepend.Project.IGraphFileRef.Path" /> equals to <paramref name="filePathOld" />, its path gets overridden by the value <paramref name="filePathNew" />.
            If this method modifies the path of a graph file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.GraphFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePathOld">The old path of the graph file to override.</param>
            <param name="filePathNew">The new path of the graph file.</param>
        </member>
        <member name="M:NDepend.Project.IProjectGraphFiles.TryRemove(NDepend.Path.IFilePath)">
            <summary>
            Remove a graph file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is no graph file with <see cref="T:NDepend.Project.IGraphFileRef" />.<see cref="P:NDepend.Project.IGraphFileRef.Path" /> equals to <paramref name="filePath" />, else returns <i>true</i>.
            </returns>
            <remarks>
            If this method removes a graph file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.GraphFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePath">The graph file path.</param>
        </member>
        <member name="T:NDepend.Project.ExtensionMethodsProject">
            <summary>
            Provides a set of extension methods to help working with NDepend project. 
            </summary>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.GetOutputDirectoryAbsolutePath(NDepend.Project.IProject)">
            <summary>
            Gets the output directory absolute path that is used during the analysis.
            </summary>
            <remarks>
            If the project output directory provided is not an absolute path and cannot be resolved, the absolute path returned is the one returned by <see cref="M:NDepend.Project.ExtensionMethodsProject.GetDefaultOutputDirectoryAbsolutePath(NDepend.Project.IProject)" />.
            </remarks>
            <param name="project">The project on which to get the output directory as absolute path.</param>
            <returns>The output directory absolute path that is used during the analysis.</returns>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.GetDefaultOutputDirectoryAbsolutePath(NDepend.Project.IProject)">
            <summary>
            Gets the output directory absolute path that is used during the analysis if the project output directory provided is not an absolute path and cannot be resolved.
            </summary>
            <remarks>
            This path is the directory named "NDependOut" under the project file path parent directory.
            </remarks>
            <param name="project">The project on which to get the default output directory.</param>
            <returns>The output directory absolute path that is used during the analysis if the project output directory provided is not an absolute path and cannot be resolved.</returns>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IFilePath,NDepend.Path.IAbsoluteFilePath@,System.String@)">
            <summary>This method attempts to resolve an absolute file path from a file path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="filePath" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="filePath" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="filePath" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="filePath">The file path to resolve as absolute.</param>
            <param name="absoluteFilePath">The result absolute file path if the resolving succeed.</param>
            <param name="failureReason">A plain english failure description if the resolving fails.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IFilePath,NDepend.Path.IAbsoluteFilePath@)">
            <summary>This method attempts to resolve an absolute file path from a file path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="filePath" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="filePath" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="filePath" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="filePath">The file path to resolve as absolute.</param>
            <param name="absoluteFilePath">The result absolute file path if the resolving succeed.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IDirectoryPath,NDepend.Path.IAbsoluteDirectoryPath@,System.String@)">
            <summary>This method attempts to resolve an absolute directory path from a directory path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="directoryPath" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="directoryPath" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="directoryPath" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="directoryPath">The directory path to resolve as absolute.</param>
            <param name="absoluteDirectoryPath">The result absolute directory path if the resolving succeed.</param>
            <param name="failureReason">A plain english failure description if the resolving fails.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IDirectoryPath,NDepend.Path.IAbsoluteDirectoryPath@)">
            <summary>This method attempts to resolve an absolute directory path from a directory path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="directoryPath" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="directoryPath" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="directoryPath" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="directoryPath">The directory path to resolve as absolute.</param>
            <param name="absoluteDirectoryPath">The result absolute directory path if the resolving succeed.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IPath,NDepend.Path.IAbsolutePath@)">
            <summary>This method attempts to resolve an absolute path from a path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="path" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="path" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="path" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="path">The path to resolve as absolute.</param>
            <param name="absolutePath">The result absolute path if the resolving succeed.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryResolveAbsolutePathFromProject(NDepend.Project.IProject,NDepend.Path.IPath,NDepend.Path.IAbsolutePath@,System.String@)">
            <summary>This method attempts to resolve an absolute path from a path</summary>
            <returns><i>true</i> if the absolute path resolving succeed, else returns <i>false</i>.</returns>
            <remarks>
            If <paramref name="path" /> is prefixed with an environment variable, <paramref name="project" /> is not used for resolving the absolute path.<br />
            If <paramref name="path" /> contains path variable(s), variables declared in <paramref name="project" />.<see cref="P:NDepend.Project.IProject.PathVariables" /> are used for resolving the absolute path.<br />
            If <paramref name="path" /> is relative to the project file, <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" /> is used for resolving the absolute path.
            </remarks>
            <param name="project">The project used for resolving the absolute path.</param>
            <param name="path">The path to resolve as absolute.</param>
            <param name="absolutePath">The result absolute path if the resolving succeed.</param>
            <param name="failureReason">A plain english failure description if the resolving fails.</param>
        </member>
        <member name="P:NDepend.Project.ExtensionMethodsProject.IDEFileRootDirResolvingInfoHintsDefaultValue">
            <summary>
            This string value is used to initialize <see cref="T:NDepend.Project.IDEFileRootDirResolvingInfo" />.<see cref="P:NDepend.Project.IDEFileRootDirResolvingInfo.HintsDefaultValue" />.
            </summary>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryLoadRuleFile(NDepend.Project.IProject,NDepend.Project.IRuleFileRef,NDepend.CodeQuery.IGroup@,System.String@)">
            <summary>
            Try load code rules and queries defined in the rule file defined by <paramref name="ruleFileRef" />.
            </summary>
            <returns><i>true</i> if the rules have been properly loaded from the rule file, else returns <i>false</i>.</returns>
            <param name="project">The NDepend project used to resolve rule file absolute path from <paramref name="ruleFileRef" /></param>
            <param name="ruleFileRef">The reference to the rule file.</param>
            <param name="group">The group of code queries and rules, not null only if this method returns <i>true</i>.</param>
            <param name="failureReason">If the method returns <i>false</i>, <paramref name="failureReason" /> is not null not empty, and explains in plain-english why the rule files' code queries and rules haven't been loaded.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TryLoadRuleFile(NDepend.Path.IAbsoluteFilePath,System.Boolean,NDepend.CodeQuery.IGroup@,System.String@)">
            <summary>
            Try load code rules and queries defined in the rule file defined by <paramref name="ruleFilePath" />.
            </summary>
            <returns><i>true</i> if the rules have been properly loaded from the rule file, else returns <i>false</i>.</returns>
            <param name="ruleFilePath">The absolute path to the rule file.</param>
            <param name="isActive">A value that indicates whether the loaded rule file is active or not.</param>
            <param name="group">The group of code queries and rules, not null only if this method returns <i>true</i>.</param>
            <param name="failureReason">If the method returns <i>false</i>, <paramref name="failureReason" /> is not null not empty, and explains in plain-english why the rule files' code queries and rules haven't been loaded.</param>
            <remarks><paramref name="isActive" /> is defined in the project file and can be obtained from <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.IsActive" />.</remarks>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TrySaveRuleFile(NDepend.Project.IProject,NDepend.Project.IRuleFileRef,NDepend.CodeQuery.IGroup,System.String@)">
            <summary>
            Try save code rules and queries defined in a rule file defined by <paramref name="ruleFileRef" />.
            </summary>
            <returns><i>true</i> if the rules have been properly saved to the rule file, else returns <i>false</i>.</returns>
            <param name="project">The NDepend project used to resolve rule file absolute path from <paramref name="ruleFileRef" /></param>
            <param name="ruleFileRef">The reference to the rule file.</param>
            <param name="group">The group of code queries and rules to save.</param>
            <param name="failureReason">If the method returns <i>false</i>, <paramref name="failureReason" /> is not null not empty, and explains in plain-english why code queries and rules haven't been saved to the rule file.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.TrySaveRuleFile(NDepend.Path.IAbsoluteFilePath,NDepend.CodeQuery.IGroup,NDepend.CodeQuery.QueryPersistenceKind,System.String@)">
            <summary>
            Try save code rules and queries defined in the rule file defined by <paramref name="ruleFilePath" />.
            </summary>
            <returns><i>true</i> if the rules have been properly saved to the rule file, else returns <i>false</i>.</returns>
            <param name="ruleFilePath">The absolute path to the rule file.</param>
            <param name="group">The group of code queries and rules, not null only if this method returns <i>true</i>.</param>
            <param name="queryPersistenceKind">The group of code queries and rules, not null only if this method returns <i>true</i>.</param>
            <param name="failureReason">If the method returns <i>false</i>, <paramref name="failureReason" /> is not null not empty, and explains in plain-english why code queries and rules haven't been saved to the rule file.</param>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.GetRulesInProjectFileAndInRuleFiles(NDepend.Project.IProject)">
            <summary>
            Try get rules and queries declared in the project file and in rule files referenced by the project.
            </summary>
            <returns>A controller object that can be used to read and update the hierarchy of rules and queries.</returns>
            <param name="project">The NDepend project.</param>
            <remarks>
            If some rules cannot be loaded, like rule in a rule file for example, a <see cref="T:NDepend.CodeQuery.IGroup" /> object will be present with a <see cref="P:NDepend.CodeQuery.IGroup.Name" /> 
            that will contains <i>Failed to load rule file: RuleFileName</i>.
            To get more information you can call the method <see cref="M:NDepend.Project.ExtensionMethodsProject.TryLoadRuleFile(NDepend.Project.IProject,NDepend.Project.IRuleFileRef,NDepend.CodeQuery.IGroup@,System.String@)" />
            and read the <i>out</i> parameter <i>failureReason</i>.
            </remarks>
        </member>
        <member name="M:NDepend.Project.ExtensionMethodsProject.GetRulesInProjectFileAndInRuleFilesAndDeclaredInSourceCode(NDepend.Project.IProject,NDepend.CodeQuery.IGroup)">
            <summary>
            Try get rules and queries declared in the project file, in rule files referenced by the project and in source code.
            </summary>
            <returns>A controller object that can be used to read and update the hierarchy of rules and queries.</returns>
            <param name="project">The NDepend project.</param>
            <param name="analysisResultRulesExtractedFromCode">The rules and queries extracted from source code obtained through <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />.</param>
            <remarks>
            If some rules cannot be loaded, like rule in a rule file for example, a <see cref="T:NDepend.CodeQuery.IGroup" /> object will be present with a <see cref="P:NDepend.CodeQuery.IGroup.Name" /> 
            that will contains <i>Failed to load rule file: RuleFileName</i>.
            To get more information you can call the method <see cref="M:NDepend.Project.ExtensionMethodsProject.TryLoadRuleFile(NDepend.Project.IProject,NDepend.Project.IRuleFileRef,NDepend.CodeQuery.IGroup@,System.String@)" />
            and read the <i>out</i> parameter <i>failureReason</i>.
            </remarks>
            <seealso cref="P:NDepend.Analysis.IAnalysisResult.RulesExtractedFromCode" />
        </member>
        <member name="T:NDepend.Project.IProjectHistoricAnalysisResult">
            <summary>
            Represents an NDepend project's settings relative to historic analysis results storage.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectHistoricAnalysisResult.PersistRecurrence">
            <summary>
            Gets or sets the frequency of when historic analysis results are stored.
            </summary>
            <remarks>
            When this property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.HistoricAnalysisResult_Settings" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectHistoricAnalysisResult.UseCustomHistoricAnalysisResultDirectory">
            <summary>
            Gets or sets a <i>boolean</i> that indicates if the value of <see cref="P:NDepend.Project.IProjectHistoricAnalysisResult.CustomHistoricAnalysisResultDirectory" /> is used to define the directory that stores Trend Metrics Values, or if the default path <i>$(NdProjectOutputDir)</i> is used instead..<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.HistoricAnalysisResult_Settings" /> activated.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectHistoricAnalysisResult.CustomHistoricAnalysisResultDirectory">
            <summary>
            Gets or sets the custom directory where historic analysis results are stored in a hierarchy of sub-directories.
            </summary>
            <remarks>
            This path is taken account only if <see cref="P:NDepend.Project.IProjectHistoricAnalysisResult.UseCustomHistoricAnalysisResultDirectory" /> is set to <i>true</i>.<br />
            Else the default path <i>$(NdProjectOutputDir)</i> is used to store History Analysis Results.<br />
            An empty value for this property is represented by a null reference..<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.HistoricAnalysisResult_CustomDirectoryPath" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectHistoricAnalysisResult.HistoricAnalysisResultDirectory">
            <summary>
            Gets the absolute path to the directory where historic analysis results are stored in a hierarchy of sub-directories.
            </summary>
            <remarks>
            The returned path takes account of the value of <see cref="P:NDepend.Project.IProjectHistoricAnalysisResult.UseCustomHistoricAnalysisResultDirectory" />.
            </remarks>
        </member>
        <member name="M:NDepend.Project.IProjectHistoricAnalysisResult.GetHistoricAnalysisResultSettingsDescription">
            <summary>
            Returns a plain english description of the historic analysis results storage settings.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectDebtSettings">
            <summary>
             Represents settings of an NDepend project concerning the debt.
            </summary>
            <remarks>
             To get or set the <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object from this interface
             use an extension method from <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebt" />.<br />
             This interface implements the <see cref="T:NDepend.Project.ISettingsStorage" /> to precise how debt settings are stored.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectDebtSettings.Values">
            <summary>
            Get or set the values encapsulated in a <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectPathVariables">
            <summary>
            Represents the project path variables that can be use to handle complex path redirection scenarios.
            </summary>
            <remarks>
            One or several Path Variables of a project can be overridden when starting <i>NDepend.Console.exe</i> with the command line argument switch <i>/PathVariables</i>.<br />
            The two path variables <i>$(NdProjectDir)</i> and <i>$(NdProjectOutputDir)</i> are automatically set and they are read-only.<br />
            <i>$(NdProjectDir)</i> is automatically set to project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<see cref="P:NDepend.Path.IPath.ParentDirectoryPath" />.<br />
            <i>$(NdProjectOutputDir)</i> is automatically set to project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectPathVariables.PathVariables">
            <summary>
            Gets all path variables defined for this project. 
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectPathVariables.TryGetPathVariableValue(System.String,System.String@)">
            <summary>
            Try obtain the value of a path variable value from its name.
            </summary>
            <remarks>Path variable naming match is case insensitive.</remarks>
            <param name="pathVariableName">The path variable name.</param>
            <param name="pathVariableValue">The path variable value found, if any path variable with <paramref name="pathVariableName" /> is found.</param>
            <returns><i>true</i> if a path variable with <paramref name="pathVariableName" /> is found.</returns>
        </member>
        <member name="M:NDepend.Project.IProjectPathVariables.TryAdd(System.String,System.String)">
            <summary>
            Try add a path variable to this project collection of path variables.
            </summary>
            <remarks>
            Returns <i>false</i> if <paramref name="pathVariableName" /> is <i>NdProjectDir</i> or <i>NdProjectOutputDir</i>.<br />
            Returns <i>false</i> if a variable with <paramref name="pathVariableName" /> already exists.<br />
            If this method modifies a state, this method returns <i>true</i> and the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.PathVariables" /> activated.
            </remarks>
            <param name="pathVariableName">The path variable name.</param>
            <param name="pathVariableValue">The path variable value.</param>
        </member>
        <member name="M:NDepend.Project.IProjectPathVariables.TryChangeName(System.String,System.String)">
            <summary>
            Try change the name of a path variable.
            </summary>
            <remarks>
            Returns <i>false</i> if <paramref name="oldPathVariableName" /> is <i>NdProjectDir</i> or <i>NdProjectOutputDir</i>.<br />
            Returns <i>false</i> if no variable with the name <paramref name="oldPathVariableName" /> exists.<br />
            If this method modifies a state, this method returns <i>true</i> and the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.PathVariables" /> activated.
            </remarks>
            <param name="oldPathVariableName">The old path variable name.</param>
            <param name="newPathVariableName">The new path variable value.</param>
        </member>
        <member name="M:NDepend.Project.IProjectPathVariables.TryChangeValue(System.String,System.String)">
            <summary>
            Try change the value of a path variable.
            </summary>
            <remarks>
            Returns <i>false</i> if <paramref name="pathVariableName" /> is <i>NdProjectDir</i> or <i>NdProjectOutputDir</i>.<br />
            Returns <i>false</i> if no variable with the name <paramref name="pathVariableName" /> exists.<br />
            If this method modifies a state, this method returns <i>true</i> and the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.PathVariables" /> activated.
            </remarks>
            <param name="pathVariableName">The path variable name.</param>
            <param name="newPathVariableValue">The new path variable value.</param>
        </member>
        <member name="M:NDepend.Project.IProjectPathVariables.TryRemove(System.String)">
            <summary>
            Try remove a path variable from this project collection of path variables.
            </summary>
            <remarks>
            Returns <i>false</i> if no path variable with <paramref name="pathVariableName" /> and read-write access right, is defined.<br />
            If this method modifies a state, this method returns <i>true</i> and the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.PathVariables" /> activated.
            </remarks>
            <param name="pathVariableName">The path variable to remove, name.</param>
        </member>
        <member name="T:NDepend.Project.IProjectRuleFiles">
            <summary>
            Represents the list of rule files referenced by this project.
            </summary>
            <seealso cref="N:NDepend.CodeQuery" />
        </member>
        <member name="P:NDepend.Project.IProjectRuleFiles.RuleFilesRef">
            <summary>
            Gets all rule files referenced by this project. 
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectRuleFiles.TryAdd(NDepend.Path.IFilePath,System.Boolean)">
            <summary>
            Add a rule file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is already a rule file referenced by this project, with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePath" />
            else the rule file gets added and the method returns <i>true</i>.
            </returns>
            <remarks>
            If this method adds a rule file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.RuleFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePath">The rule file path.</param>
            <param name="active">The rule file active status.</param>
        </member>
        <member name="M:NDepend.Project.IProjectRuleFiles.TryChangeRuleFileRefActivation(NDepend.Path.IFilePath,System.Boolean)">
            <summary>
            Change the activation of a rule file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is no rule file with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePath" />.
            </returns>
            <remarks>
            If there is a rule file with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePath" />, its value <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.IsActive" /> gets overridden by the value <paramref name="active" />.
            If this method modifies the <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.IsActive" /> status of a rule file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.RuleFilesRef_Activation" /> activated.
            </remarks>
            <param name="filePath">The rule file path.</param>
            <param name="active">The new rule file active status.</param>
        </member>
        <member name="M:NDepend.Project.IProjectRuleFiles.TryChangeRuleFileRefPath(NDepend.Path.IFilePath,NDepend.Path.IFilePath)">
            <summary>
            Change the path of a rule file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is no rule file with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePathOld" />.
            </returns>
            <remarks>
            If there is a rule file with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePathOld" />, its path gets overridden by the value <paramref name="filePathNew" />.
            If this method modifies the path of a rule file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.RuleFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePathOld">The old path of the rule file to override.</param>
            <param name="filePathNew">The new path of the rule file.</param>
        </member>
        <member name="M:NDepend.Project.IProjectRuleFiles.TryRemove(NDepend.Path.IFilePath)">
            <summary>
            Remove a rule file referenced by this project.
            </summary>
            <returns>
            <i>false</i> if there is no rule file with <see cref="T:NDepend.Project.IRuleFileRef" />.<see cref="P:NDepend.Project.IRuleFileRef.Path" /> equals to <paramref name="filePath" />, else returns <i>true</i>.
            </returns>
            <remarks>
            If this method removes a rule file, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.RuleFilesRef_Paths" /> activated.
            </remarks>
            <param name="filePath">The rule file path.</param>
        </member>
        <member name="T:NDepend.Project.IRuleFileRef">
            <summary>
            Represents a reference to a file containing extra code rules and queries.
            </summary>
            <returns>
            Rule files are especially useful to be shared amongst several NDepend projects.
            </returns>
        </member>
        <member name="P:NDepend.Project.IRuleFileRef.Path">
            <summary>
            Gets the rule file path.
            </summary>
        </member>
        <member name="P:NDepend.Project.IRuleFileRef.IsActive">
            <summary>
            Gets a value that indicates whether this rule file is active.
            </summary>
            <remarks>
            The default value is <i>true</i>.<br />
            If this value is <i>false</i>, all queries and rules in this file are not active.<br />
            If this value is <i>true</i>, queries and rules in this file might be activated or not, depending on their <see cref="T:NDepend.CodeQuery.IQuery" />.<see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> and <see cref="T:NDepend.CodeQuery.IQuery" />.<see cref="P:NDepend.CodeQuery.IQuery.Parent" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> status.
            </remarks>
        </member>
        <member name="T:NDepend.Project.ISettingsStorage">
            <summary>
             Represents how some project settings are stored.
            </summary>
            <remarks>
             Project settings can be stored in the project file or in a <i>.ndsettings</i> file.<br />
             This is why this interface only contains the read/write property <see cref="P:NDepend.Project.ISettingsStorage.SettingsFilePath" />.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.ISettingsStorage.SettingsFilePath">
            <summary>
             Gets or sets the path to the <i>.ndsettings</i> file that contains debt settings for this project. 
            </summary>
            <remarks>
             When this property value is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.DebtSettingsStorage" /> activated.<br />
             <i>null</i> value are acepted to reset this file path.
            </remarks>
        </member>
        <member name="P:NDepend.Project.ISettingsStorage.Storage">
            <summary>
             Gets or sets the location where the Debt settings are stored.
            </summary>
        </member>
        <member name="P:NDepend.Project.ISettingsStorage.ErrorLoadingFromSettingsFile">
            <summary>
            Gets a plain english string that describes the error when trying to load the Debt settings from the referenced settings file.
            </summary>
            <remarks>
            This property is set when loading the <see cref="T:NDepend.Project.IProject" /> from the project file.<br />
            If an error occurs while loading from settings file, the debt settings ae loaded from the project file.
            </remarks>
            <seealso cref="M:NDepend.Project.IProjectManager.LoadProject(NDepend.Path.IAbsoluteFilePath)" />
        </member>
        <member name="P:NDepend.Project.ISettingsStorage.ErrorSavingInSettingsFile">
            <summary>
            Gets a plain english string that describes the error when trying to save the Debt settings in the referenced settings file.
            </summary>
            <remarks>
            This property is set when saving the <see cref="T:NDepend.Project.IProject" /> from the project file.<br />
            If an error occurs while saving in settings file, the debt settings ae saved in the project file.
            </remarks>
            <seealso cref="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)" />
        </member>
        <member name="T:NDepend.Project.PathVariable">
            <summary>
            Define a path variable. 
            </summary>
        </member>
        <member name="M:NDepend.Project.PathVariable.#ctor(System.String,System.String,NDepend.Project.PathVariableAccess)">
            <summary>
            Build a path variable object. 
            </summary>
            <param name="name">The path variable name.</param>
            <param name="value">The path variable value.</param>
            <param name="access">The path variable access rights.</param>
        </member>
        <member name="P:NDepend.Project.PathVariable.Name">
            <summary>
            Gets the name of the path variable.
            </summary>
        </member>
        <member name="P:NDepend.Project.PathVariable.Value">
            <summary>
            Gets the value of the path variable.
            </summary>
        </member>
        <member name="P:NDepend.Project.PathVariable.Access">
            <summary>
            Gets the access-rights of the path variable.
            </summary>
        </member>
        <member name="T:NDepend.Project.PathVariableAccess">
            <summary>
            Define path variable access rights.
            </summary>
        </member>
        <member name="F:NDepend.Project.PathVariableAccess.ReadOnly">
            <summary>
            Path variable access rights read-only. This access right is used exclusively for the two path variables <i>$(NdProjectDir)</i> and <i>$(NdProjectOutputDir)</i>.
            </summary>
        </member>
        <member name="F:NDepend.Project.PathVariableAccess.ReadWrite">
            <summary>
            Path variable access rights read-only. All users path variables have this path access.
            </summary>
        </member>
        <member name="T:NDepend.Project.SettingsStorage">
            <summary>
            Enumeration about where the DebtSettings are stored.
            </summary>
        </member>
        <member name="F:NDepend.Project.SettingsStorage.Default">
            <summary>Default</summary>
        </member>
        <member name="F:NDepend.Project.SettingsStorage.ProjectFile">
            <summary>ProjectFile</summary>
        </member>
        <member name="F:NDepend.Project.SettingsStorage.SettingsFile">
            <summary>SettingsFile</summary>
        </member>
        <member name="T:NDepend.Project.IProjectTrend">
            <summary>
            Represents an NDepend project's settings relative to trend metrics log and diagrams displayed.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.UseCustomLogFrequencyAndLabelValues">
            <summary>
            Gets or sets a <i>boolean</i> that indicates if the values of <see cref="P:NDepend.Project.IProjectTrend.CustomLogRecurrence" /> and <see cref="P:NDepend.Project.IProjectTrend.CustomLogLabel" /> are used, or if the values defined in <i>Options - Trend Metrics</i> are used instead.<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Trend_Settings" /> activated.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.CustomLogRecurrence">
            <summary>
            Gets or sets the frequency of when trend metrics values are logged.
            </summary>
            <remarks>
            This value is taken account only if <see cref="P:NDepend.Project.IProjectTrend.UseCustomLogFrequencyAndLabelValues" /> is set to <i>true</i>.<br />
            Else the value defined in <i>Options - Trend Metrics</i> is used..<br />
            When this property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Trend_Settings" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.CustomLogLabel">
            <summary>
            Gets or sets the kind of label used to tag trend metrics logs.
            </summary>
            <remarks>
            This value is taken account only if <see cref="P:NDepend.Project.IProjectTrend.UseCustomLogFrequencyAndLabelValues" /> is set to <i>true</i>.<br />
            Else the value defined in <i>Options - Trend Metrics</i> is used..<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Trend_Settings" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.UseCustomTrendStoreDirectory">
            <summary>
            Gets or sets a <i>boolean</i> that indicates if the value of <see cref="P:NDepend.Project.IProjectTrend.CustomTrendStoreDirectory" /> is used to define the directory that stores Trend Metrics Values, or if the default path <i>$(NdProjectOutputDir)\TrendMetrics</i> is used instead..<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Trend_Settings" /> activated.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.CustomTrendStoreDirectory">
            <summary>
            Gets or sets the custom directory where Trend Metrics Values are stored.
            </summary>
            <remarks>
            This path is taken account only if <see cref="P:NDepend.Project.IProjectTrend.UseCustomTrendStoreDirectory" /> is set to <i>true</i>.<br />
            Else the default path <i>$(NdProjectOutputDir)\TrendMetrics</i> is used to store Trend Metrics Values.<br />
            An empty value for this property is represented by a null reference..<br />
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Trend_StoreCustomDirectoryPath" /> activated.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.TrendStoreDirectory">
            <summary>
            Gets the absolute path to the directory that stores Trend Metrics Values.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Trend.ITrendStore" /> object can be obtained from this path thought the extension methods <see cref="T:NDepend.Trend.ExtensionMethodsTrend" />.<see cref="M:NDepend.Trend.ExtensionMethodsTrend.GetTrendStoreFromDirectory(NDepend.Path.IAbsoluteDirectoryPath)" />.<br /> 
            The returned path takes account of the values of <see cref="P:NDepend.Project.IProjectTrend.UseCustomTrendStoreDirectory" /> and <see cref="P:NDepend.Project.IProjectTrend.CustomTrendStoreDirectory" />.
            </remarks>
        </member>
        <member name="M:NDepend.Project.IProjectTrend.GetTrendMetricsSettingsDescription(NDepend.Project.LogRecurrence,NDepend.Trend.TrendMetricsLogLabel)">
            <summary>
            Returns a plain english description of the trend metrics settings.
            </summary>
            <param name="defaultLogRecurrence">The log recurrence value defined in the options, used in case <see cref="P:NDepend.Project.IProjectTrend.UseCustomLogFrequencyAndLabelValues" /> is <i>false</i>.</param>
            <param name="defaultLogLabel">The log label value defined in the options, used in case <see cref="P:NDepend.Project.IProjectTrend.UseCustomLogFrequencyAndLabelValues" /> is <i>false</i>.</param>
        </member>
        <member name="P:NDepend.Project.IProjectTrend.ChartsSettings">
            <summary>
            Gets or sets the set of trend charts settings to show in the Dashboard panel and in the report.
            </summary>
            <remarks>The order in the list is important since charts will be shown in this order.</remarks>
        </member>
        <member name="T:NDepend.Project.LogRecurrence">
            <summary>
            Represents the recurrence of when trend metrics values are logged, or when historic analysis result are persisted.
            </summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.Always">
            <summary>Always</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.Never">
            <summary>Never</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceADay">
            <summary>AtMostOnceADay</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceADayMondayToFriday">
            <summary>AtMostOnceADayMondayToFriday</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceEveryTwoDays">
            <summary>AtMostOnceEveryTwoDays</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceAWeek">
            <summary>AtMostOnceAWeek</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceEveryTwoWeeks">
            <summary>AtMostOnceEveryTwoWeeks</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.AtMostOnceAMonth">
            <summary>AtMostOnceAMonth</summary>
        </member>
        <member name="F:NDepend.Project.LogRecurrence.Default">
            <summary>Default</summary>
        </member>
        <member name="T:NDepend.Project.IAssemblyResolvingError">
            <summary>
            Represents an application or third-party assembly resolving error, obtained when trying to resolve assemblies with the method <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="M:NDepend.Project.IProjectCodeToAnalyze.Resolve(System.Collections.Generic.IReadOnlyList{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.IReadOnlyList{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.IReadOnlyList{NDepend.Project.IAssemblyResolvingError}@,System.Collections.Generic.IReadOnlyList{NDepend.Project.IAssemblyResolvingError}@)" />.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects can correspond to resolving error situations like:<br />
            - no assembly file with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found in the set of directories <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute" />.<br />
            - several different assemblies files with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found in the set of directories provided <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute" />.<br />
            - one assembly file with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found but it is a corrupted assembly main module file.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IAssemblyResolvingError.AssemblyName">
            <summary>
            The assembly main module file name on which the resolving error occured.
            </summary>
        </member>
        <member name="P:NDepend.Project.IAssemblyResolvingError.ErrorDescription">
            <summary>
            The plain english description of the resolving error.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProject">
            <summary>
            Represents an NDepend project, with all its settings readable and writable.
            </summary>
            <remarks>
            <see cref="T:NDepend.Project.IProjectManager" /> presents methods to create, load and save an NDepend project.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProject.Properties">
            <summary>
            Represents this NDepend project main properties.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.CodeToAnalyze">
            <summary>
            Represents this NDepend project assemblies to analyze.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.Report">
            <summary>
            Represents settings of this NDepend project concerning report.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.BaselineDuringAnalysis">
            <summary>
            Represents settings of this NDepend project concerning the baseline eventually used during analysis.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.BaselineInUI">
            <summary>
            Represents settings of this NDepend project concerning the baseline eventually used in NDepend user interface (VisualNDepend or VisualStudio addin).
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.Coverage">
            <summary>
            Represents settings of this NDepend project concerning code coverage file(s) to load to obtain code coverage metrics.
            </summary>
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
        </member>
        <member name="P:NDepend.Project.IProject.Trend">
            <summary>
            Represents this NDepend project's settings relative to trend metrics log and diagrams displayed.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.HistoricAnalysisResult">
            <summary>
            Represents this NDepend project's settings relative to Historic Analysis Results storage.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.DisabledWarnings">
            <summary>
            Represents the collection of analysis warnings disabled, of this NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.SourceFilesRebasing">
            <summary>
            Represents this NDepend project source files rebasing settings.
            </summary>
            <remarks>
            SourceFilesRebasing is useful if the analysis results are produced on a machine, but used from another machine, where source file are nested in a different root directory.<br />
            Hence source files rebasing settings are used to rebase source files paths.
            </remarks>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />
            <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable" />
        </member>
        <member name="P:NDepend.Project.IProject.CodeQueries">
            <summary>
            Represents this NDepend project code queries and code rules.
            </summary>
            <seealso cref="N:NDepend.CodeQuery" />
        </member>
        <member name="P:NDepend.Project.IProject.RuleFiles">
            <summary>
            Represents the list of rule files referenced by this project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.GraphFiles">
            <summary>
            Represents the list of graph files referenced by this project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.DebtSettings">
            <summary>
            Represents the debt settings of this project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.PathVariables">
            <summary>
            Represents this NDepend project path variables collection.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProject.Github">
            <summary>
            Represents this NDepend project Github settings.
            </summary>
        </member>
        <member name="M:NDepend.Project.IProject.GetProjectRef(System.DateTime)">
            <summary>
            Gets a reference to this NDepend project, with <see cref="T:NDepend.Project.IProjectRef" />.<see cref="P:NDepend.Project.IProjectRef.DateLastTouched" /> equals to <paramref name="dateLastTouched" />.
            </summary>
            <param name="dateLastTouched">The <see cref="T:NDepend.Project.IProjectRef" />.<see cref="P:NDepend.Project.IProjectRef.DateLastTouched" /> of the returned NDepend project reference.</param>
        </member>
        <member name="E:NDepend.Project.IProject.SettingsChanged">
            <summary>
            This event is triggered each time some settings of this NDepend project are changed.
            </summary>
            <remarks>The settings changed are listed through the <see cref="T:NDepend.Project.ProjectSettings" /> flags.</remarks>
        </member>
        <member name="T:NDepend.Project.BaselineProjectMode">
            <summary>
            Represents a value that determines if a <see cref="T:NDepend.Project.IProjectBaseline" /> comparison doesn't occur, occurs with a previous analyis result of this NDepend project or occurs with a previous analyis result of another NDepend project.
            </summary>
            <remarks>
            <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />    : don't do comparison when doing a new analysis.<br />
            <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.CurrentProject" /> : do a comparison with a previous analysis result of the current project.<br />
            <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" /> : do a comparison with a previous analysis result of another project.
            </remarks>
        </member>
        <member name="F:NDepend.Project.BaselineProjectMode.DontCompare">
            <summary>DontCompare</summary>
        </member>
        <member name="F:NDepend.Project.BaselineProjectMode.CurrentProject">
            <summary>CurrentProject</summary>
        </member>
        <member name="F:NDepend.Project.BaselineProjectMode.AnotherProject">
            <summary>AnotherProject</summary>
        </member>
        <member name="T:NDepend.Project.BaselineAnalysisResultMode">
            <summary>
            Represents a value that determines for a <see cref="T:NDepend.Project.IProjectBaseline" />, with which analysis result the comparison occurs..
            </summary>
            <remarks>
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable" /> : compare with the most recent analysis result available.<br />
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />            : compare with an analysis result made N days ago. If no analysis result found, then try to find the closest analysis result.<br />
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />          : compare with a particular analysis result.
            </remarks>
        </member>
        <member name="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable">
            <summary>MostRecentAnalysisResultAvailable</summary>
        </member>
        <member name="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult">
            <summary>NDaysAgoAnalysisResult</summary>
        </member>
        <member name="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult">
            <summary>ParticularAnalysisResult</summary>
        </member>
        <member name="T:NDepend.Project.IProjectBaseline">
            <summary>
            Represents baseline settings of an NDepend project. It can be the settings for <see cref="P:NDepend.Project.IProject.BaselineInUI" /> or <see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" />.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectBaseline.ProjectMode">
            <summary>
            Gets or sets a value that determines if the comparison doesn't occur, occurs with a previous analyis result of this NDepend project or occurs with a previous analyis result of another NDepend project.
            </summary>
            <remarks>
            Specified values can be:<br />
            <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />    : don't do comparison when doing a new analysis.<br />
            <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.CurrentProject" /> : do a comparison with a previous analysis result of the current project.<br />
            <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" /> : do a comparison with a previous analysis result of another project.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectBaseline.AnalysisResultMode">
            <summary>
            Gets or sets a value that determines with which analysis result the comparison occurs.
            </summary>
            <remarks>
            The <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> value is only used when <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" /> is different than <see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />.<br />
            Specified values can be:<br />
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable" /> : compare with the most recent analysis result available.<br />
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />            : compare with an analysis result made N days ago. If no analysis result found, then try to find the closest analysis result.<br />
            <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />          : compare with a particular analysis result.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectBaseline.AnalysisResultCreatedNDaysAgo">
            <summary>
            Gets or sets the number of days ago, used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> is set to <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectBaseline.OtherProjectFilePath">
            <summary>
            Gets or sets the other NDepend project file path, used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" /> is set to <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" />.
            </summary>
            <remarks>
            If the returned path is a relative path (<see cref="T:NDepend.Path.IFilePath" />.<see cref="P:NDepend.Path.IPath.IsRelativePath" />), the path is relative to the current NDepend project file path (<see cref="T:NDepend.Project.IProjectProperties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<see cref="P:NDepend.Path.IAbsolutePath.ParentDirectoryPath" />).<br />
            An empty value for this property is represented by a null reference.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectBaseline.ParticularAnalysisResultFilePath">
            <summary>
            Gets or sets the <see cref="T:NDepend.Analysis.IAnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.AnalysisResultFilePath" /> used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> is set to <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />.
            </summary>
            <remarks>
            If the returned path is a relative path (<see cref="T:NDepend.Path.IFilePath" />.<see cref="P:NDepend.Path.IPath.IsRelativePath" />), the path is relative to the current NDepend project file path (<see cref="T:NDepend.Project.IProjectProperties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<see cref="P:NDepend.Path.IAbsolutePath.ParentDirectoryPath" />).<br />
            An empty value for this property is represented by a null reference.
            </remarks>
        </member>
        <member name="M:NDepend.Project.IProjectBaseline.GetBaselineSettingsDescription">
            <summary>
            Returns this baseline settings plain english description.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectCodeToAnalyze">
            <summary>
            Represents application and third-party assemblies to analyze, of an NDepend project.
            </summary>
            <remarks>
            Assemblies are referenced by names.<br /> 
            A collection of directories is provided.<br />
            At assemblies resolving time, assemblies are resolved by names in directories provided. Some <see cref="T:NDepend.Project.IAssemblyResolvingError" /> can then occur.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCodeToAnalyze.IDEFiles">
            <summary>
            Gets a read-only list of Visual Studio solution(s) or project(s) from which some application assemblies are inferred to be analyzed.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectCodeToAnalyze.ApplicationAssembliesNames">
            <summary>
            Gets a read-only list of application assemblies files names.
            </summary>
            <remarks>The list returned is a read-only clone. Hence it doesn't reflect any modification in the original collection.</remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCodeToAnalyze.RuntimeProfileDesc">
            <summary>
            Get or set a string that describes the .NET runtime profile for assemblies of this project.
            </summary>
            <remarks>
            This value is used to infer runtime profile directories in which referenced assemblies are resolved at analysis time.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCodeToAnalyze.Directories">
            <summary>
            Gets a read-only list of directories paths where to search for assemblies.
            </summary>
            <remarks>
            The list returned is a read-only clone. Hence it doesn't reflect any modification in the original collection.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute">
            <summary>
            Gets a read-only list of absolute directories paths where to search for assemblies.
            </summary>
            <remarks>
            Return a read-only list of <see cref="P:NDepend.Project.IProjectCodeToAnalyze.Directories" /> resolved as absolute, in the context of the current machine and the current project.<br />
            In this situation, if a directory cannot be resolved to absolute (like for example the relative directory <i>"..\..\Dir0"</i> cannot be resolved from <i>"C:\Dir1\Project.ndproj"</i>), it doesn't appears in the returned collection of paths.<br />
            The list returned is a read-only clone. Hence it doesn't reflect any modification in the original collection.
            </remarks>
        </member>
        <member name="M:NDepend.Project.IProjectCodeToAnalyze.SetApplicationAssemblies(System.Collections.Generic.IEnumerable{NDepend.Path.IAbsoluteFilePath})">
            <summary>
            Set the collection of application assemblies to analyze. 
            </summary>
            <remarks>
            This method resets the <see cref="T:NDepend.Project.IProjectCodeToAnalyze" /><see cref="P:NDepend.Project.IProjectCodeToAnalyze.ApplicationAssembliesNames" /> for this project.<br />
            Third-party assemblies are inferred from these application assemblies and also application assemblies inferred from <see cref="P:NDepend.Project.IProjectCodeToAnalyze.IDEFiles" />.<br />
            Directories (absolute or relative to the NDepend project file path) are inferred as well.<br />
            .NET Framework directories are also inferred.
            </remarks>
            <param name="assembliesPath">The sequence of absolute file paths of the application assemblies to analyze.</param>
        </member>
        <member name="M:NDepend.Project.IProjectCodeToAnalyze.SetIDEFiles(System.Collections.Generic.IEnumerable{NDepend.Project.IDEFile})">
            <summary>
            Set the collection of Visual Studio files (solution or project) to analyze from which some application assemblies are inferred to be analyzed. 
            </summary>
            <remarks>
            This method resets the <see cref="T:NDepend.Project.IProjectCodeToAnalyze" /><see cref="P:NDepend.Project.IProjectCodeToAnalyze.IDEFiles" /> for this project.<br />
            Third-party assemblies are inferred from application assemblies inferred from <see cref="P:NDepend.Project.IProjectCodeToAnalyze.IDEFiles" /> and also from <see cref="P:NDepend.Project.IProjectCodeToAnalyze.ApplicationAssembliesNames" />.<br />
            Directories (absolute or relative to the NDepend project file path) are inferred as well.<br />
            .NET Framework directories are also inferred.
            </remarks>
            <param name="ideFiles">The sequence of Visual Studio files from which some application assemblies are inferred to be analyzed.</param>
        </member>
        <member name="M:NDepend.Project.IProjectCodeToAnalyze.Resolve(System.Collections.Generic.IReadOnlyList{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.IReadOnlyList{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.IReadOnlyList{NDepend.Project.IAssemblyResolvingError}@,System.Collections.Generic.IReadOnlyList{NDepend.Project.IAssemblyResolvingError}@)">
            <summary>
            Try resolve application and third-party assemblies paths, and if some are not resolved, returns corresponding <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects.
            </summary>
            <remarks>
            The result of this resolving action is not cached and each time calling this method can take a few tenths of second.
            </remarks>
            <param name="applicationAssemblies">Paths to application assemblies files resolved.</param>
            <param name="thirdPartyAssemblies">Paths to third-party assemblies files resolved.</param>
            <param name="applicationAssembliesError">A read-only list of <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects, one for each application assemblies files unresolved.</param>
            <param name="thirdPartyAssembliesError">A read-only list of <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects, one for each third-party assemblies files unresolved.</param>
            <returns>Returns <i>true</i> if no assembly resolving error is found, otherwise returns false.</returns>
        </member>
        <member name="T:NDepend.Project.IProjectCoverage">
            <summary>
            Represents settings of an NDepend project concerning code coverage file(s) to load to obtain code coverage metrics.
            </summary>
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
            <seealso cref="P:NDepend.CodeModel.ICodeContainer.CoverageDataAvailable" />
            <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
            <seealso cref="T:NDepend.Project.IProjectCoverage" />
        </member>
        <member name="M:NDepend.Project.IProjectCoverage.AddCoverageFile(NDepend.Path.IFilePath)">
            <summary>
            Adds the coverage file path.
            </summary>
            <remarks>
            The list can't contains duplicate path.
            If the path is added, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Coverage_Settings" /> activated.<br />
            </remarks>
            <returns>
            Returns <i>true</i> only if the path is correctly added.<br />
            When adding a duplicate path, the method does nothing and returns <i>false</i>.<br />
            </returns>
            <param name="coverageFilePath">The coverage file path to add.</param>
        </member>
        <member name="M:NDepend.Project.IProjectCoverage.RemoveCoverageFile(NDepend.Path.IFilePath)">
            <summary>
            Removes the <paramref name="coverageFilePath" /> from the collection of coverage files.
            </summary>
            <remarks>
            If the path is removed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Coverage_Settings" /> activated.<br />
            </remarks>
            <returns>
            If the path is not found, the method does nothing and returns false.<br />
            Returns true only if the path is correctly removed.
            </returns>
            <param name="coverageFilePath">The coverage file path to remove.</param>
        </member>
        <member name="P:NDepend.Project.IProjectCoverage.CoverageFiles">
            <summary>
            Gets a read-only list of coverages files paths.
            </summary>
            <remarks>
            The list returned is a clone. Hence it doesn't reflect any modification in the original collection.<br />
            Use <see cref="M:NDepend.Project.IProjectCoverage.AddCoverageFile(NDepend.Path.IFilePath)" /> and <see cref="M:NDepend.Project.IProjectCoverage.RemoveCoverageFile(NDepend.Path.IFilePath)" /> methods to modify the collection of coverages files paths.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCoverage.CoverageDir">
            <summary>
            Gets or sets a directory path that contains some coverage files to import. A <i>null</i> value means that this facility is not used.
            </summary>
            <remarks>
            In addition to the specified list of coverage files, a directory can be specified to import all files in this directory as coverage files.
            This facility is useful to just dump all coverage files in a directory at build time, and don't need to care about their number nor names.
            If some files in this directory are not recognized as coverage files, a warning will be emitted.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCoverage.CoverageExclusionFile">
            <summary>
            Gets or sets a file path that contains some data to exclude some projects or some code elements from code coverage statistics.
            </summary>
            <remarks>
            In .NET a coverage exclusion file is a file with extension .runsettings file with a CodeCoverage section.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCoverage.CoverageDirFilter">
            <summary>
            Gets or sets a wildcard filter string that is used to locate coverage files when the <see cref="P:NDepend.Project.IProjectCoverage.CoverageDir" /> is set.
            </summary>
            <remarks>
            No filter means only files in coverage directory are taken account.<br />
            Filter "*" matches all files in coverage directory (same as above).<br />
            Filter "**\*.xml" matches all files with .xml extension (case-insensitive) in coverage directory and in all its child directories (recursive).<br />
            Filter "Cov*\*" matches all files in coverage directory's child directories whose name starts with Cov (case-insensitive).<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectCoverage.UncoverableAttribute">
            <summary>Gets or sets the full name string of the uncoverable attribute.</summary>
            <remarks>
            Through this option, the user can define an attribute that tags uncoverage methods, types or assemblies.<br />
            NDepend will then take care of this attribute and compute coverage ratio adequately.<br />
            For example, if all methods of a type are 100% covered by tests except a method that calls a blocking method such as MessageBox.Show(), this method can be tagged with the uncoverable attributes and as a result, the type.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> ratio is artificially maintained to 100%.<br />
            The NDepend.API offers the attribute class <see cref="T:NDepend.Attributes.UncoverableByTestAttribute" /> for default uncoverable attribute, but you can define your own uncoverable attribute and set this property adequately.<br />
            The name of the uncoverable attribute must be formatted "{namespace}.{typeAttribute}". For example: "NDepend.Attributes.UncoverableByTestAttribute"
            </remarks>
            <seealso cref="T:NDepend.Attributes.UncoverableByTestAttribute" />
        </member>
        <member name="M:NDepend.Project.IProjectCoverage.GetCoverageDescription">
            <summary>
            Returns a plain english description of the coverage files.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectManager">
            <summary>
            Exposes base operations on NDepend project, including load/save/create/get most recent... A IProjectManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.ProjectManager" />.
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectManager.LoadProject(NDepend.Path.IAbsoluteFilePath)">
            <summary>
            Loads a NDepend project, a <see cref="T:NDepend.Project.IProject" /> object, from the path of the project file.
            </summary>
            <param name="projectFilePath">The path of the project file.</param>
            <returns>The <see cref="T:NDepend.Project.IProject" /> object.</returns>
            <exception cref="T:NDepend.Project.ProjectException">The project cannot be loaded, the exception message describes the failure reason.</exception>
        </member>
        <member name="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)">
            <summary>
            Saves a NDepend project to the project file defined by project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.
            </summary>
            <param name="project">The project object to save.</param>
            <exception cref="T:NDepend.Project.ProjectException">The project cannot be saved, the exception message describes the failure reason.</exception>
        </member>
        <member name="M:NDepend.Project.IProjectManager.GetMostRecentlyUsedProjects">
            <summary>
            Gets a read-only list of NDepend projects references object representing most recently used NDepend projects.
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectManager.CreateBlankProject(NDepend.Path.IAbsoluteFilePath,System.String)">
            <summary>
            Creates a new blank project. This method doesn't create the project file, the method <see cref="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)" /> can be called for that.
            </summary>
            <remarks>
            Once the project object is created, the project file is then accessible through project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.
            </remarks>
            <param name="projectFilePath">The absolute path to the project file, a project cannot be initialized without a valid project file path.</param>
            <param name="projectName">The initial name of the project.</param>
            <returns>The blank project object.</returns>
        </member>
        <member name="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)">
            <summary>
            Creates a new temporary project. Calling this method creates the temporary project file in a temporary directory.
            </summary>
            <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br />
            Tree temporary projects can coexist corresponding to the three <see cref="T:NDepend.Project.TemporaryProjectMode" /> values, <see cref="F:NDepend.Project.TemporaryProjectMode.Temporary" />, <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> and <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" />.<br />
            Be aware that calling this method erases the current temporary project corresponding to <paramref name="temporaryProjectMode" />.
            </remarks>
            <param name="applicationAssemblies">Application assemblies file paths to analyze.</param>
            <param name="temporaryProjectMode">The temporary project mode: <see cref="F:NDepend.Project.TemporaryProjectMode.Temporary" />, <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> or <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" />.</param>
            <returns>The project object initialized.</returns> 
            <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
            <seealso cref="P:NDepend.Project.IProjectProperties.TemporaryProjectMode" />
        </member>
        <member name="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
            <summary>
            Shows a dialog that allows the user select a set of assemblies files.
            </summary>
            <returns>true if the user clicked OK, false if the user clicked Cancel.</returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="applicationAssemblies">Application assemblies file paths choosen</param>
            <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(System.IntPtr,NDepend.Project.IProject@)" />
            <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(System.IntPtr,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
        </member>
        <member name="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
            <summary>
            Shows a dialog that allows the user select a set of assemblies files.
            </summary>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="applicationAssembliesIn">A collection of file paths to the assemblies that the dialog initially shows to the user.</param>
            <param name="applicationAssembliesOut">Application assemblies file paths choosen</param>
            <returns>true if the user clicked OK, false if the user clicked Cancel.</returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(System.IntPtr,NDepend.Project.IProject@)" />
            <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(System.IntPtr,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
        </member>
        <member name="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(System.IntPtr,NDepend.Project.IProject@)">
            <summary>
            Shows a dialog that allows the user select an existing NDepend project.
            </summary>
            <param name="ownerWindowHandle">The window handle of the parent window that shows the dialog.</param>
            <param name="project">The project choosen.</param>
            <returns>true if the user clicked OK, false if the user clicked Cancel</returns>
            <remarks>This method can only be invoked within a .NET Framework 4.x and Windows OS context else it throws a <i>NotSupportedException</i>.</remarks>
            <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.IntPtr,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
            <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(System.IntPtr,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
        </member>
        <member name="T:NDepend.Project.TemporaryProjectMode">
            <summary>
            Specifies if a project is temporary or not. Three temporary projects can co-exist. <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> and <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" /> values are useful if you wish to compare two temporary projects.
            </summary>
        </member>
        <member name="F:NDepend.Project.TemporaryProjectMode.None">
            <summary>None</summary>
        </member>
        <member name="F:NDepend.Project.TemporaryProjectMode.Temporary">
            <summary>Temporary</summary>
        </member>
        <member name="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder">
            <summary>TemporaryOlder</summary>
        </member>
        <member name="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer">
            <summary>TemporaryNewer</summary>
        </member>
        <member name="T:NDepend.Project.IProjectProperties">
            <summary>
            Represents main properties of an NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.Name">
            <summary>
            Gets or sets the name of the NDepend project.
            </summary>
            <remarks>
            When the name is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Name" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.OutputDir">
            <summary>
            Gets or sets the output directory path of the NDepend project, the path where all analysis results will be stored.
            </summary>
            <remarks>
            When the output directory is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.OutputDirectoryPath" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.FilePath">
            <summary>
            Gets or sets the NDepend project file path.
            </summary>
            <remarks>
            It is not recommended to change the project file path if some paths referenced by the project are relative.<br />
            Indeed, in such situation most of directories and files referenced by the project are relative to the <see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<br />
            When the file path is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.FilePath" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.TemporaryProjectMode">
            <summary>
            Gets a value indicating whether this project is a temporary project or not.
            </summary>
            <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br />
            </remarks>
            <seealso cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" />
        </member>
        <member name="P:NDepend.Project.IProjectProperties.KeepXmlFiles">
            <summary>
            Gets or sets a boolean value indicating whether at the end of an analysis, the XML files used to generate the report through a XSL transformation, are kept or not.
            </summary>
            <remarks>
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Report_KeepXmlFilesUsedToBuildReport" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.MergeCodeGeneratedByCompiler">
            <summary>
            Gets or sets a boolean value indicating whether at analysis time, types and methods generated by the C# and VB.NET compilers to handle language constructs like lambda, iterators, anonymous and asynchronous methods, are merged within their declaring methods.
            </summary>
            <remarks>
            The default value is <i>true</i>. In most situations you'll want to avoid having to deal with such generated types and methods.<br />
            Anonymous types are not merged since they are explicitly created and used in the source code.<br />
            Types created by the Microsoft Code Contract infrastructure are not merged as well.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.ZipSourceFiles">
            <summary>
            Gets or sets a boolean value indicating whether at analysis time source files get zipped.
            </summary>
            <remarks>
            The default value is <i>true</i>. In most situations you'll want to zip source files. Having access to source files is especially useful when you want to diff particular changes in code.<br />
            However zipping source files consumes a bit of CPU at analysis time and a bit of hard drive space to keep the zip files for each analysis result.<br />
            So it might make sense to prefer no zipping source files.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectProperties.ProjectFileWrittenByProductVersion">
            <summary>
            Gets the NDepend version that has written last time this project file.
            </summary>
            <remarks>
            This property appeared with NDepend version 7. All project written with a major version lower than 7 have by default the version 6.0.0.0.
            </remarks>
        </member>
        <member name="T:NDepend.Project.IProjectCodeQueries">
            <summary>
            Represents this NDepend project code queries and code rules.
            </summary>
            <seealso cref="N:NDepend.CodeQuery" />
        </member>
        <member name="P:NDepend.Project.IProjectCodeQueries.CodeQueriesSet">
            <summary>
            Gets or sets the set of code rules and queries for this NDepend project.
            </summary>
            <remarks>
            If this NDepend project file exists, the set of code rules and queries data is loaded from and saved to the project file, each time this property getter or setter is invoked.<br />
            If this NDepend project file doesn't exist, the set of code rules and queries data is loaded from and saved to, in memory.<br />
            (property getter only) If this NDepend project file XML content is corrupted, the set of default queries is returned.
            </remarks>
            <exception cref="T:System.IO.IOException">(property setter only) The project file exists but cannot be written.</exception>
        </member>
        <member name="M:NDepend.Project.IProjectCodeQueries.SetDefaultCodeQueries">
            <summary>
            Set the set of default code rules and queries for this NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectCodeQueries.AreActive">
            <summary>
            Gets or sets the active status of code queries and rules defined in this NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectCodeQueries.QueryPersistenceKind">
            <summary>
            Gets or sets how queries are persisted in this project file.
            </summary>
        </member>
        <member name="T:NDepend.Project.IProjectSourceFilesRebasing">
            <summary>
            Represents an NDepend project's analysis time source files rebasing settings.
            </summary>
            <remarks>
            <see cref="T:NDepend.Project.IProjectSourceFilesRebasing" /> settings are useful if the source code compilation occurs on a machine, but NDepend analysis is executed on another machine, where source files are nested in a different root directory.<br />
            Hence source files rebasing settings are used to rebase source files paths at analysis time.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectSourceFilesRebasing.FromPath">
            <summary>
            Gets or sets the deeper folder that contains all source files of the application at compile time. A null reference means that the analysis time rebasing possibility is not used.
            </summary>
            <remarks> 
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Rebasing_FromPath" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectSourceFilesRebasing.ToPath">
            <summary>
            Gets or sets the deeper folder that contains all source files of the application during NDepend analysis time. A null reference means that the analysis time rebasing possibility is not used.
            </summary>
            <remarks> 
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Rebasing_ToPath" /> activated.<br />
            </remarks>
        </member>
        <member name="T:NDepend.Project.IProjectRef">
            <summary>
            Represents a reference to a NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectRef.ProjectName">
            <summary>
            Gets the NDepend project name.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectRef.ProjectFilePath">
            <summary>
            Gets the NDepend project file path.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectRef.DateLastTouched">
            <summary>
            Gets the date representing the last time the project has been used through NDepend user interface.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectRef.TemporaryProjectMode">
            <summary>
            Gets a value indicating whether this project is a temporary project or not.
            </summary>
            <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br />
            </remarks>
            <seealso cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" />
        </member>
        <member name="M:NDepend.Project.IProjectRef.Load">
            <summary>
            Loads a project from this project reference.
            </summary>
            <returns>The project loaded.</returns>
            <exception cref="T:NDepend.Project.ProjectException">The project cannot be loaded, the exception message describes the failure reason.</exception>
        </member>
        <member name="T:NDepend.Project.ReportFormat">
            <summary>
            Represents the report format option.
            </summary>
        </member>
        <member name="F:NDepend.Project.ReportFormat.Standard">
            <summary>Standard</summary>
        </member>
        <member name="F:NDepend.Project.ReportFormat.CustomXsl">
            <summary>CustomXsl</summary>
        </member>
        <member name="F:NDepend.Project.ReportFormat.Default">
            <summary>Default</summary>
        </member>
        <member name="T:NDepend.Project.ReportSections">
            <summary>
            Represents an array of flags that indicates a sub set of possible report sections.
            </summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.ApplicationMetrics">
            <summary>ApplicationMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesMetrics">
            <summary>AssembliesMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.TreemapMetricView">
            <summary>TreemapMetricView</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesAbstractnessVSInstability">
            <summary>AssembliesAbstractnessVSInstability</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesDependencies">
            <summary>AssembliesDependencies</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesDependencyGraph">
            <summary>AssembliesDependencyGraph</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesDependencyMatrix">
            <summary>AssembliesDependencyMatrix</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AssembliesBuildOrder">
            <summary>AssembliesBuildOrder</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.AnalysisLog">
            <summary>AnalysisLog</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.QualityGates">
            <summary>QualityGates</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.CodeRules">
            <summary>CodeRules</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.CodeQueries">
            <summary>CodeQueries</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.TypesMetrics">
            <summary>TypesMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.TypesDependencies">
            <summary>TypesDependencies</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.NamespacesMetrics">
            <summary>NamespacesMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.NamespacesDependencies">
            <summary>NamespacesDependencies</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.TrendCharts">
            <summary>TrendCharts</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.None">
            <summary>None</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.All">
            <summary>All</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.Default">
            <summary>Default</summary>
        </member>
        <member name="F:NDepend.Project.ReportSections.ReportDiagrams">
            <summary>Flags about all pictures in reports</summary>
        </member>
        <member name="T:NDepend.Project.ReportOptionsFlags">
            <summary>
            Represents an array of flags that indicates various boolean report options.
            </summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.None">
            <summary>None</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.ValueUsedWhenNoOptionFlagsFoundInXML">
            <summary>ValueUsedWhenNoOptionFlagsFoundInXML</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.HideTierAssembliesInGraph">
            <summary>HideTierAssembliesInGraph</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.GraphLayoutDirectionTopToBottom">
            <summary>GraphLayoutDirectionTopToBottom</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.HideTypesMetricsOnLargeApp">
            <summary>HideTypesMetricsOnLargeApp</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.HideTypesDependenciesOnLargeApp">
            <summary>HideTypesDependenciesOnLargeApp</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.DontShowTooManyCodeRulesMatchedItems">
            <summary>DontShowTooManyCodeRulesMatchedItems</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.HideNamespacesMetricsOnLargeApp">
            <summary>HideNamespacesMetricsOnLargeApp</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.HideNamespacesDependenciesOnLargeApp">
            <summary>HideNamespacesDependenciesOnLargeApp</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.AllowBreakLongLine">
            <summary>AllowBreakLongLine</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.CollapseCodeQueriesBodies">
            <summary>CollapseCodeQueriesBodies</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.ShowRuleDescriptionIfAvailable">
            <summary>ShowRuleDescriptionIfAvailable</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.DontClusterAsmInGraph">
            <summary>DontClusterAsmInGraph</summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.DontUnfoldMultiItemsCell">
            <summary>
            Some rules and code queries result's cells match several items (like several classes or several issues). When this flag is un-set, it unfolds up to 10 items in the concerned queries' results' cells.
            </summary>
            <remarks>
            This flag is negative - prefixed by don't - so existing project files get multi-items cells unfold in report as-is.
            </remarks>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.DontShowCodeElementIcons">
            <summary>
            When this flag is un-set, icons are shown before code elements in the report.
            </summary>
            <remarks>
            This flag is negative - prefixed by don't - so existing project files get code elements' icons in report as-is.
            </remarks>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.DontLinkElementToSourceFile">
            <summary>
            When the source file declaration(s) of a code element has been resolved at analysis time, with this flag un-set it is possible to get a link to this declaration for each occurrence of the code element in the report.
            </summary>
            <remarks>
            This flag is negative - prefixed by don't - so existing project files get elements links in report as-is.
            </remarks>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.LinkElementToRelativeSourceFile">
            <summary>
            When this flag is set, links to source file declarations in the report are paths relative to the report file location.
            </summary>
        </member>
        <member name="F:NDepend.Project.ReportOptionsFlags.Default">
            <summary>Default</summary>
        </member>
        <member name="T:NDepend.Project.IProjectReport">
            <summary>
            Represents report settings of an NDepend project.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectReport.ReportFilePath">
            <summary>
            Gets the report file path in the directory project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectReport.ReportFormat">
            <summary>
            Gets or sets a value that determines the report format.
            </summary>
            <remarks>
            When this value is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Report_Format" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectReport.ReportSectionsEnabled">
            <summary>
            Gets or sets an array of flags that indicates enabled report sections.
            </summary>
            <remarks>
            When this value is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Report_SectionsEnabled" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectReport.ReportXslPath">
            <summary>
            Gets or sets the path to the report XSL file. A null value for this path means that the user wants to use the default Xsl sheet to build report.
            </summary>
            <remarks>
            When the report XSL file path is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Report_XslPath" /> activated.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectReport.ReportOptionsFlags">
            <summary>
            Gets or sets an array of flags that indicates various boolean report options.
            </summary>
        </member>
        <member name="P:NDepend.Project.IProjectReport.NbItemsToUnfold">
            <summary>
            When the flag <see cref="P:NDepend.Project.IProjectReport.ReportOptionsFlags" />.<see cref="F:NDepend.Project.ReportOptionsFlags.DontUnfoldMultiItemsCell" /> is not-set, this value is used to know the maximum of items to unfold.
            </summary>
        </member>
        <member name="M:NDepend.Project.IProjectReport.RebaseSourcePathsInReport(System.String,System.String,System.String)">
            <summary>
            This method can be called before analyzing with report creation, to update the paths in the report.
            </summary>
            <param name="fromPath">A sub-string of the source path that defines which portion to replace.</param>
            <param name="toPath">The portion replacement in the new path.</param>
            <param name="lineSuffix">A string to append at the end of the path with the tag $LineNumber$ that is replaced with the line number. Empty string is accepted if the updated path shouldn't be suffixed with the line number.</param>
            <remarks>
            For example to transform this path:<br />
            C:\a\root\ClassLibrary\test.cs Line 76<br />
            to<br />
            https://github.com/myproject/testcore/blob/main/ClassLibrary/test.cs#L76 <br />
            this method can be called with these arguments:<br />
            "root", "https://github.com/myproject/testcore/blob/main", "#L$LineNumber$"<br />
            Notice that the provided information are not stored in the project file.<br />
            They are just used on next calls to <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject,System.String)"/> on this <see cref="T:NDepend.Project.IProject"/> object.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Such exception can be thrown if provided arguments are not valid.
            </exception>
        </member>
        <member name="T:NDepend.Project.IProjectDisabledWarnings">
            <summary>
            Represents the collection of analysis time warnings disabled, of an NDepend project.
            </summary>
            <remarks>
            Disabling some warnings is useful to avoid being warned again and again with recurring warnings at analysis time.
            </remarks>
        </member>
        <member name="P:NDepend.Project.IProjectDisabledWarnings.WarningsDisabled">
            <summary>
            Get or set the set of warnings disabled for this project.
            </summary>
            <remarks>
            If the project file exists, this data is loaded from and saved in the project file.<br />
            (getter only) If the project file is corrupted, an empty array is returned.
            </remarks>
            <exception cref="T:System.IO.IOException">The project file cannot be read or written.</exception>
        </member>
        <member name="T:NDepend.Project.ProjectException">
            <summary>
            The exception that is thrown when a project related operation fails.
            </summary>
            <remarks>
            Methods potentially throwing this exception are: <br />
            IProjectCodeToAnalyze.<see cref="M:NDepend.Project.IProjectCodeToAnalyze.SetApplicationAssemblies(System.Collections.Generic.IEnumerable{NDepend.Path.IAbsoluteFilePath})" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.LoadProject(NDepend.Path.IAbsoluteFilePath)" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /><br />
            IProjectRef.<see cref="M:NDepend.Project.IProjectRef.Load" /><br />
            </remarks>
        </member>
        <member name="M:NDepend.Project.ProjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Project.ProjectException" /> class with a specified error message.
            </summary>
            <param name="message">A message that describes the error.</param>
        </member>
        <member name="T:NDepend.Project.ProjectSettings">
            <summary>
            Represents a bit array of an NDepend project settings.
            </summary>
            <remarks>This bit array enumeration is useful to know which settings of an NDepend project have been changed through the event <see cref="E:NDepend.Project.IProject.SettingsChanged" />.</remarks>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.None">
            <summary>None</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.AllSettings">
            <summary>AllSettings</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.CodeToAnalyze_IDEFiles">
            <summary>CodeToAnalyze_ApplicationComponents</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.CodeToAnalyze_ApplicationComponents">
            <summary>CodeToAnalyze_ApplicationComponents</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.CodeToAnalyze_RuntimeProfileDesc">
            <summary>CodeToAnalyze_RuntimeProfileDesc</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.CodeToAnalyze_DirectoriesPaths">
            <summary>CodeToAnalyze_DirectoriesPaths</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Name">
            <summary>Name</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.OutputDirectoryPath">
            <summary>OutputDirectoryPath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.FilePath">
            <summary>FilePath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Report_KeepXmlFilesUsedToBuildReport">
            <summary>Report_KeepXmlFilesUsedToBuildReport</summary>      
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Report_XslPath">
            <summary>Report_XslPath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Report_Format">
            <summary>Report_Format</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Report_SectionsEnabled">
            <summary>Report_SectionsEnabled</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Report_OptionFlags">
            <summary>Report_OptionFlags</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.WarningsDisabled">
            <summary>WarningsDisabled</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI">
            <summary>BaselineInUI</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI_ProjectMode">
            <summary>BaselineInUI_ProjectMode</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI_AnalysisMode">
            <summary>BaselineInUI_AnalysisMode</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI_MadeNDaysAgo">
            <summary>BaselineInUI_MadeNDaysAgo</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI_OtherProjectFilePath">
            <summary>BaselineInUI_OtherProjectFilePath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineInUI_ParticularAnalysisResultFilePath">
            <summary>BaselineInUI_ParticularAnalysisResultFilePath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis">
            <summary>BaselineDuringAnalysis</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis_ProjectMode">
            <summary>BaselineDuringAnalysis_ProjectMode</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis_AnalysisMode">
            <summary>BaselineDuringAnalysis_AnalysisMode</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis_MadeNDaysAgo">
            <summary>BaselineDuringAnalysis_MadeNDaysAgo</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis_OtherProjectFilePath">
            <summary>BaselineDuringAnalysis_OtherProjectFilePath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.BaselineDuringAnalysis_ParticularAnalysisResultFilePath">
            <summary>BaselineDuringAnalysis_ParticularAnalysisResultFilePath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.CodeQueryRawXml">
            <summary>CodeQueryRawXml</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Coverage_Settings">
            <summary>Coverage_Settings</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Coverage_FilesPaths">
            <summary>Coverage_FilesPaths</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Coverage_Dir">
            <summary>Coverage_Dir</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Rebasing_FromPath">
            <summary>Rebasing_FromPath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Rebasing_ToPath">
            <summary>Rebasing_ToPath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Trend_Settings">
            <summary>TrendMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Trend_StoreCustomDirectoryPath">
            <summary>TrendMetrics</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Trend_ChartsSettings">
            <summary>Trend_ChartsSettings</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.PathVariables">
            <summary>PathVariables</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.HistoricAnalysisResult_Settings">
            <summary>HistoricAnalysisResult_Settings</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.HistoricAnalysisResult_CustomDirectoryPath">
            <summary>HistoricAnalysisResult_CustomDirectoryPath</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.RuleFilesRef_Activation">
            <summary>RuleFilesRef_Activation</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.RuleFilesRef_Paths">
            <summary>RuleFilesRef_Paths</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.ProjectRules_AreActive">
            <summary>ProjectRules_AreActive</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.MergeCodeGeneratedByCompiler">
            <summary>MergeCodeGeneratedByCompiler</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.ZipSourceFiles">
            <summary>ZipSourceFiles</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.DebtSettings">
            <summary>DebtSettings</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.DebtSettingsStorage">
            <summary>SettingsStorage</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.GraphFilesRef_Paths">
            <summary>GraphFilesRef_Paths</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Coverage_DirFilter">
            <summary>Coverage_DirFilter</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Coverage_ExclusionFile">
            <summary>Coverage_ExclusionFile</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.ProjectRules_QueryPersistenceKind">
            <summary>ProjectRules_PersistenceKind</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Github_Repo">
            <summary>Github_Repo</summary>
        </member>
        <member name="F:NDepend.Project.ProjectSettings.Github_Account">
            <summary>Github_Account</summary>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet">
            <summary>
            Presents extension methods on rules and code elements, that provide a syntax friendly way to gather debt and issues data in CQLinq rules queries.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all rely on a hidden <see cref="T:NDepend.Issue.IIssuesSet" /> object, hidden in CQLinq queries. This results in less syntax burden.<br />
            At CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods into calls to methods of a <see cref="T:NDepend.Issue.IIssuesSet" /> object.<br />
            Indeed each of these extension methods, has an equivalent method defined by <see cref="T:NDepend.Issue.IIssuesSet" />, that can be called from a program that consumes NDepend.API.
            </remarks>
            <seealso cref="T:NDepend.Issue.IIssue" />
            <seealso cref="T:NDepend.Issue.IRule" />
            <seealso cref="T:NDepend.Issue.IIssuesSet" />
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssues(NDepend.Analysis.IAnalysisResult)" />
            <seealso cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSet(NDepend.CodeModel.ICodeBase,NDepend.TechnicalDebt.IDebtFormatter)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Issues(NDepend.Issue.IRule)">
            <summary>
            Gets all issues of <paramref name="rule" />.
            </summary>
             <param name="rule">The rule on which to get the issues.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Issues(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.Issue.IRule)">
             <summary>
             Gets the summed debt of all issues of <paramref name="rule" />.
             </summary>
             <param name="rule">The rule on which to get the issues.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.Issue.IRule)">
             <summary>
             Gets the summed annual-interest of all issues of <paramref name="rule" />.
             </summary>
             <param name="rule">The rule on which to get the issues.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.IsViolated(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if the <paramref name="rule" /> is violated in the context of this issues-set.
             </summary>
             <remarks>
             The returned value is the value of <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated" /> of the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object used when calling the method <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetIssues(NDepend.Issue.IRule,NDepend.CodeQuery.IQueryExecutionSuccessResult)" />.
             </remarks>
             <param name="rule">The rule on which to get the is-violated value.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.IsViolated(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.BreakingPoint(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.Issue.IRule)" />).
             </summary>
             <param name="rule">The rule on which to get the is-violated value.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.BreakingPoint(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterestPercent(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.Issue.IRule)" />).
             </summary>
             <param name="rule">The rule on which to get the is-violated value.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterestPercent(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.HasIssue(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value indicating whether the <paramref name="codeElement" /> has issues or not.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.HasIssue(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.HasDebt(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value indicating whether the <paramref name="codeElement" /> has debt or not.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>
             If <paramref name="codeElement" /> has only issues with <see cref="P:NDepend.Issue.IIssue.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" />, this getter returns <i>false</i>.
             This property getter has a constant time complexity.
             </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.HasDebt(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.HasAnnualInterest(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value indicating whether the <paramref name="codeElement" /> has annual-interest or not.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>
             If <paramref name="codeElement" /> has only issues with <see cref="P:NDepend.Issue.IIssue.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" />, this getter returns <i>false</i>.
             This property getter has a constant time complexity.
             </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.HasAnnualInterest(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Issues(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets all issues relative to <paramref name="codeElement" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Issues(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the summed debt of all issues relative to <paramref name="codeElement" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the summed annual-interest of all issues relative to <paramref name="codeElement" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.BreakingPoint(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.BreakingPoint(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterestPercent(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterestPercent(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllIssuesCount(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the count of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllIssuesCountIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllIssues(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets all issues relative to <paramref name="codeElement" />, and relative to all its child code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>
             This property getter has a <i>O(</i><paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />.<see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" /><i>)</i> time complexity.<br />
             If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeBase" /> this method has a constant time complexity.<br />
             If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Issues(NDepend.CodeModel.ICodeElement)" />.
             </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllIssuesIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the summed debt of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>
             This property getter has a constant time complexity.<br />
             If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" />.
             </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllAnnualInterest(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the summed annual-interest of all issues relative to <paramref name="codeElement" />, and relative to all its children code elements, defined by <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElementParent.RecursiveChildren" />, if <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.ICodeElementParent" />.
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>
             This property getter has a constant time complexity.<br />
             If <paramref name="codeElement" /> is a <see cref="T:NDepend.CodeModel.IMethod" /> or a <see cref="T:NDepend.CodeModel.IField" />, it is not a <see cref="T:NDepend.CodeModel.ICodeElementParent" /> and this method is equivalent to <i>this</i>.<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" />.
             </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllBreakingPoint(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllAnnualInterest(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllBreakingPointIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllAnnualInterestPercent(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllAnnualInterest(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <param name="codeElement">The code element.</param>
             <remarks>This property getter has a constant time complexity.</remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestPercentIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets the debt rating of <paramref name="codeElement" /> in the range <see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> (very good) to <see cref="F:NDepend.TechnicalDebt.DebtRating.E" /> (very bad).
             </summary>
             <remarks>
             The debt to infer the rating is obtained through <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).<br />
             This method implementation calls <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />.<br />
             This method returns <i>null</i> if <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
             </remarks>
             <param name="codeElement">The code element on which we infer the rating.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.CostToReachRating(NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)">
             <summary>
             Returns the estimated effort to reach <paramref name="ratingToReach" />, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).
             </summary>
             <remarks>
             If the actual rating of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) is equals or better than <paramref name="ratingToReach" />, this method returns a zero duration <see cref="T:NDepend.TechnicalDebt.Debt" /> value.<br />
             This method implementation calls <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)" />.<br />
             This method returns <i>null</i> if <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
             </remarks>
             <param name="codeElement">The code element on which we infer the cost to reach <paramref name="ratingToReach" />.</param>
             <param name="ratingToReach">The rating to reach for <paramref name="codeElement" /></param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.CostToReachRating(NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.CostToReachBetterRating(NDepend.CodeModel.ICodeElement)">
             <summary>
             Returns the estimated cost, to reach a better rating, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />).
             </summary>
             <remarks>
             <i>Better rating</i> means the rating just better than the actual one.<br />
             If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.D" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.C" />.<br />
             If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.B" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />.<br />
             If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />, this method returns <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" />.<br />
             This method implementation calls <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachBetterRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />.<br />
             This method returns <i>null</i> if <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />) returns <i>null</i>.<br />
             </remarks>
             <param name="codeElement">The code element on which we infer the cost to reach a better rating.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.CostToReachBetterRating(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)">
             <summary>
             Estimate the ratio of technical debt, measured through <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSet.AllDebt(NDepend.CodeModel.ICodeElement)" />(<paramref name="codeElement" />). 
             This ratio is expressed in percentage, of estimated debt, compared to the estimated time it would take to rewrite <paramref name="codeElement" /> from scratch. 
             </summary>
             <remarks>
             This method implementation calls <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
             and returns <i>null</i> if <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>,
             which happens when the PDB file is not found for the assembly containing <paramref name="codeElement" />,
             which means that <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>.
             </remarks>
             <param name="codeElement">The code element on which we infer the percentage of debt.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff">
            <summary>
            Presents extension methods on rules and code elements, that provide a syntax friendly way to gather debt and issues data in CQLinq rules queries.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all rely on a hidden <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object, hidden in CQLinq queries. This results in less syntax burden.<br />
            At CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods into calls to methods of a <see cref="T:NDepend.Issue.IIssuesSetDiff" /> object.<br />
            Indeed each of these extension methods, has an equivalent method defined by <see cref="T:NDepend.Issue.IIssuesSetDiff" />, that can be called from a program that consumes NDepend.API.
            </remarks>
            <seealso cref="T:NDepend.Issue.IIssue" />
            <seealso cref="T:NDepend.Issue.IRule" />
            <seealso cref="T:NDepend.Issue.IIssuesSet" />
            <seealso cref="T:NDepend.Issue.IIssuesSetDiff" />
            <seealso cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.ComputeIssuesDiff(NDepend.Analysis.IAnalysisResult,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.Issue.ExtensionMethodsIssue.CreateIssuesSetDiff(NDepend.CodeModel.ICompareContext,NDepend.Issue.IIssuesSet,NDepend.Issue.IIssuesSet)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)">
            <summary>
            Gets the <paramref name="qualityGate" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="qualityGate" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <remarks>If <paramref name="qualityGate" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
            <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)">
             <summary>
             Gets the <paramref name="qualityGate" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="qualityGate" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <remarks>If <paramref name="qualityGate" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
             <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IQualityGate)">
             <summary>
             Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
             </summary>
             <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IQualityGate)">
             <summary>
             Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <param name="qualityGate">The quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IQualityGate)">
             <summary>
             Gets a value that indicates if <paramref name="qualityGate" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
             </summary>
             <param name="qualityGate">The quality gate object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of the same quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.ValueDiff(NDepend.Issue.IQualityGate)">
             <summary>
             Gets the <see cref="P:NDepend.Issue.IQualityGate.Value" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> of <paramref name="qualityGate" />, 
             minus the <see cref="P:NDepend.Issue.IQualityGate.Value" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of <paramref name="qualityGate" />.
             </summary>
             <remarks>
             If the older or newer value is <i>null</i> returns <i>null</i>.
             </remarks>
             <param name="qualityGate">The quality gate object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IQualityGate)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IQualityGate)" /> of the same quality gate.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.ValueDiff(NDepend.Issue.IQualityGate)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)">
            <summary>
            Gets the <paramref name="rule" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="rule" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
            </summary>
            <remarks>If <paramref name="rule" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
            <param name="rule">The rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)">
             <summary>
             Gets the <paramref name="rule" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="rule" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <remarks>If <paramref name="rule" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
             <param name="rule">The rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
             </summary>
             <param name="rule">The rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <param name="rule">The rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if <paramref name="rule" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
             </summary>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsNotViolatedAnymore(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if <paramref name="rule" /> is present in both <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and is violated in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and not in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
             </summary>,
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsNotViolatedAnymore(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.WasNotViolatedAndIsViolated(NDepend.Issue.IRule)">
             <summary>
             Gets a value that indicates if <paramref name="rule" /> is present in both <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and is violated in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and not in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>,
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.WasNotViolatedAndIsViolated(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IssuesAdded(NDepend.Issue.IRule)">
             <summary>
             Gets all issues of <paramref name="rule" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. These issues are considered as added.
             </summary>
             <remarks>
             The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, all issues of <paramref name="rule" /> are returned.
             </remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IssuesAdded(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IssuesFixed(NDepend.Issue.IRule)">
             <summary>
             Gets all issues of <paramref name="rule" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. These issues are considered as fixed.
             </summary>
             <remarks>
             The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, all issues of <paramref name="rule" /> are returned.
             </remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IssuesFixed(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
             </remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.Issue.IRule)" /> of <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of <paramref name="rule" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
             </remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)" />).
             </summary>
             <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IRule)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IRule)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IRule)" />).
             </summary>
             <remarks>The returned value can be positive, zero or negative.</remarks>
             <param name="rule">The rule object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IRule)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IRule)" /> of the same rule.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IRule)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)">
             <summary>
             Gets the <paramref name="issue" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, or <i>null</i> if <paramref name="issue" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
             </summary>
             <remarks>If <paramref name="issue" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />, this method returns it.</remarks>
             <param name="issue">The issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)">
             <summary>
             Gets the <paramref name="issue" /> in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, or <i>null</i> if <paramref name="issue" /> has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <remarks>If <paramref name="issue" /> is already in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />, this method returns it.</remarks>
             <param name="issue">The issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.
             </summary>
             <param name="issue">The issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInNewerIssuesSet(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.
             </summary>
             <param name="issue">The issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsInOlderIssuesSet(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" /> is in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has an equivalent in the other issues-set.
             </summary>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IsPresentInBothIssuesSet(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.WasAdded(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" /> is present in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. It is then considered as an issue added.
             </summary>
             <remarks>
             If <paramref name="issue" /> is the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the issue, this method returns <i>false</i>.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.WasAdded(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.WasFixed(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" /> is present in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> and has no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. It is then considered as a fixed issue.
             </summary>
             <remarks>
             If <paramref name="issue" /> is the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> of the issue, this method returns <i>false</i>.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.WasFixed(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)">
             <summary>
             Gets <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.Debt" /> of <paramref name="issue" />, 
             minus  <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.Debt" /> of <paramref name="issue" />, 
             </summary>
             <remarks>
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)">
             <summary>
             Gets <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> of <paramref name="issue" />, 
             minus  <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" />.<see cref="P:NDepend.Issue.IIssue.AnnualInterest" /> of <paramref name="issue" />, 
             </summary>
             <remarks>
             If <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IIssue)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)" />).
             </summary>
             <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IIssue)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.Issue.IIssue)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.Issue.IIssue)" />).
             </summary>
             <remarks>The returned value can be positive, zero or negative.</remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.SeverityChanged(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> is different for <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.SeverityChanged(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.SeverityDecreased(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> has decreased between <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.<br />
             Severity decrease means for example that <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" /> is considered <i>less</i> severe than <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" />.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.SeverityDecreased(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.SeverityIncreased(NDepend.Issue.IIssue)">
             <summary>
             Gets a value that indicates if <paramref name="issue" />.<see cref="P:NDepend.Issue.IIssue.Severity" /> has increased between <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> and <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of <paramref name="issue" /> is <i>null</i>.<br />
             Severity increase means for example that <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" /> is considered <i>more</i> severe than <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" />.
             </remarks>
             <param name="issue">The issue object can be the <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.NewerVersion(NDepend.Issue.IIssue)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.OlderVersion(NDepend.Issue.IIssue)" /> of the same issue.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.SeverityIncreased(NDepend.Issue.IIssue)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IssuesAdded(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets all issues on <paramref name="codeElement" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />. These issues are considered as added.
             </summary>
             <remarks>
             The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
             If <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, all issues on <paramref name="codeElement" /> are returned.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IssuesAdded(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.IssuesFixed(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets all issues on <paramref name="codeElement" /> that have no equivalent in <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />. These issues are considered as fixed.
             </summary>
             <remarks>
             The issues of <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" /> and <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" /> are paired when they share the same <see cref="P:NDepend.Issue.IIssue.Rule" /> and the same <see cref="P:NDepend.Issue.IIssue.CodeElement" />.<br />
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, all issues on <paramref name="codeElement" /> are returned.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.IssuesFixed(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.Debt(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AnnualInterest(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.BreakingPointDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.BreakingPointDiff(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestPercentDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <remarks>The returned value can be positive, zero or negative.</remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AnnualInterestPercentDiff(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllDebtDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllDebtIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be positive, zero or negative.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AllDebtDiffIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllAnnualInterestDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.AllAnnualInterestIn(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value is taken instead.<br />
             The returned <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be positive, zero or negative.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestDiffIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>    
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllBreakingPointDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllDebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllAnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <remarks>The returned <see cref="T:System.TimeSpan" /> value can be positive, zero or negative.</remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AllBreakingPointDiffIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllAnnualInterestPercentDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)" />(<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllDebtDiff(NDepend.CodeModel.ICodeElement)" />,<see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.AllAnnualInterestDiff(NDepend.CodeModel.ICodeElement)" />).
             </summary>
             <remarks>The returned value can be positive, zero or negative.</remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.AllAnnualInterestPercentDiffIn(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtRatioDiff(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             minus <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             If <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>, this method returns <i>null</i>.<br />
             <br />
             If <see cref="P:NDepend.Issue.IIssuesSetDiff.NewerIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />, 
             or <see cref="P:NDepend.Issue.IIssuesSetDiff.OlderIssuesSet" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRatio(NDepend.CodeModel.ICodeElement)" /> of <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />
             is <i>null</i>, this method returns <i>null</i>.<br />
             <br />
             The returned value can be <i>null</i> or else, positive, zero or negative.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtRatioDiff(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtRatingChanged(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is different for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> and <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
             If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
             <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtRatingChanged(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtRatingImproved(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is better for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> than for <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
             If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
             <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtRatingImproved(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqIssuesSetDiff.DebtRatingWorsened(NDepend.CodeModel.ICodeElement)">
             <summary>
             Gets a value that indicates if <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is better for <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> than for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> of <paramref name="codeElement" />.
             </summary>
             <remarks>
             This methods returns <i>false</i> if <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of <paramref name="codeElement" /> is <i>null</i>.<br />
             If <paramref name="codeElement" />.<see cref="M:NDepend.Issue.IIssuesSet.DebtRating(NDepend.CodeModel.ICodeElement)" /> is <i>null</i> for <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" />,
             <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> is taken instead.
             </remarks>
             <param name="codeElement">The code element object can be the <see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> or <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> of the same code element.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.Issue.IIssuesSetDiff" />.<see cref="M:NDepend.Issue.IIssuesSetDiff.DebtRatingWorsened(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter">
            <summary>
            Presents miscellaneous extension methods, that provide a syntax friendly way to gather data.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all rely on a hidden <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object, hidden in CQLinq queries. This results in less syntax burden.<br />
            At CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods into calls to the proper <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object.<br />
            </remarks>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.AnnualInterestThreshold(NDepend.TechnicalDebt.Severity)">
            <summary>
            Get the <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> threshold corresponding to the <paramref name="severity" />
            </summary>
            <remarks>
            <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" />.<br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Medium" />.<br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Medium2HighSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.High" />.<br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.High2CriticalSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Critical" />.<br />
            The <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" />.
            </remarks>
            <param name="severity">The severity level to get the threshold from.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.AnnualInterestThreshold(NDepend.TechnicalDebt.Severity)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.EffortToDevelop(NDepend.CodeModel.ICodeElement)">
            <summary>
            Evaluate the total time to develop <paramref name="codeElement" /> based on
            <paramref name="codeElement" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" />, 
            by applying a linear coefficent inferred from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> settings:
            <see cref="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode" /> and 
            <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <remarks>This method returns <i>null</i> if <paramref name="codeElement" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>.</remarks>
            <param name="codeElement">The code element on which to infer time-to-develop.</param>
            <seealso cref="M:NDepend.TechnicalDebt.IDebtFormatter.EffortToDevelop(NDepend.CodeModel.ICodeElement)" />
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.EffortToDevelop(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(System.TimeSpan)">
            <summary>
            Gets a double number of man-days that represents <paramref name="duration" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-days that represents <paramref name="duration" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The nullable estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-days that represents <paramref name="debt" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(NDepend.TechnicalDebt.Debt)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-days that represents <paramref name="debt" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="debt">The nullable estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.Debt})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-days that represents <paramref name="annualInterest" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="annualInterest">The estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(NDepend.TechnicalDebt.AnnualInterest)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-days that represents <paramref name="annualInterest" />. 
            The number of man-days is computed from the project <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="annualInterest">The nullable estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(System.TimeSpan)">
            <summary>
            Gets a double number of man-months that represents <paramref name="duration" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-months that represents <paramref name="duration" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The nullable estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-months that represents <paramref name="debt" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(NDepend.TechnicalDebt.Debt)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-months that represents <paramref name="debt" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The nullable estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.Debt})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-months that represents <paramref name="annualInterest" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(NDepend.TechnicalDebt.AnnualInterest)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-months that represents <paramref name="annualInterest" />. 
            The number of man-months is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The nullable estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(System.TimeSpan)">
            <summary>
            Gets a double number of man-years that represents <paramref name="duration" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-years that represents <paramref name="duration" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The nullable estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-years that represents <paramref name="debt" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(NDepend.TechnicalDebt.Debt)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-years that represents <paramref name="debt" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The nullable estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.Debt})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-years that represents <paramref name="annualInterest" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(NDepend.TechnicalDebt.AnnualInterest)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-years that represents <paramref name="annualInterest" />. 
            The number of man-years is computed from <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The nullable estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(System.TimeSpan)">
            <summary>
            Estimate an amount of money from a <paramref name="duration" />.
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(System.Nullable{System.TimeSpan})">
            <summary>
            Estimate an amount of money from a <paramref name="duration" />. 
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="duration">The nullable estimated duration to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.TimeSpan)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(NDepend.TechnicalDebt.Debt)">
            <summary>
            Estimate an amount of money from a <paramref name="debt" />. 
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="debt">The estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(NDepend.TechnicalDebt.Debt)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Estimate an amount of money from a <paramref name="debt" />. 
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="debt">The nullable estimated effort to fix one or several issues</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.Debt})" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Estimate an amount of money from an <paramref name="annualInterest" />. 
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="annualInterest">The estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(NDepend.TechnicalDebt.AnnualInterest)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Estimate an amount of money from an <paramref name="annualInterest" />. 
            </summary>
            <remarks>
            The amount of money is expressed in the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the project's <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            </remarks>
            <param name="annualInterest">The nullable estimated cost-per-year to leave one or several issues unfixed</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})" /> must be called instead.</exception>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare">
            <summary>
            Presents extension methods on code elements, that provide a syntax friendly way to specify diff actions in CQLinq rules queries.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all rely on a hidden <see cref="T:NDepend.CodeModel.ICompareContext" /> object, hidden in CQLinq queries. This results in less syntax burden.<br />
            At CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods into calls to methods of a <see cref="T:NDepend.CodeModel.ICompareContext" /> object.<br />
            Indeed each of these extension methods, has an equivalent method defined by <see cref="T:NDepend.CodeModel.ICompareContext" />, that can be called from a program that consumes NDepend.API.
            </remarks>
            <seealso cref="T:NDepend.CodeModel.ICompareContext" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
            <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.IEnumerable{System.String},NDepend.CodeModel.ICompareContext)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceDecl,NDepend.CodeModel.ISourceDecl)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.NewerVersion``1(``0)">
            <summary>
            Returns the newer version of this <paramref name="codeElement" /> object. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> must be called instead.
            </summary>
            <remarks>
            If this code element is already the newer version, returns this code element.<br />
            If this code element has been removed and has no corresponding newer version, returns null.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.<br />
            </remarks>
            <typeparam name="T"><i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeElement" /> generic type, like in <i>ICodeElement&lt;IMethod&gt;</i> or <i>ICodeElement&lt;ICodeBase&gt;</i> for example.</typeparam>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(``0)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.OlderVersion``1(``0)">
            <summary>
            Returns the older version of this <paramref name="codeElement" /> object. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> must be called instead.
            </summary>
            <remarks>
            If this code element is already the older version, returns this code element.<br />
            If this code element has been added and has no corresponding older version, returns null.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.<br />
            </remarks>
            <typeparam name="T"><i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeElement" /> generic type, like in <i>ICodeElement&lt;IMethod&gt;</i> or <i>ICodeElement&lt;ICodeBase&gt;</i> for example.</typeparam>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(``0)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInNewerBuild(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInOlderBuild(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in the older version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsPresentInBothBuilds(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is both in the newer and older versions of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            If this method returns true, this means that this code element has not been added nor removed.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasChanged(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object was changed in any way (code change, comment change, visibility change...). This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasChanged(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CodeWasChanged(NDepend.CodeModel.ICodeContainer)">
            <summary>
            Returns <i>true</i> if the code of this <paramref name="codeContainer" /> object, has been modified. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeContainer">This <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)">
            <summary>
            Returns <i>true</i> if comments of this <paramref name="codeContainer" /> object, have been modified. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.
            </summary>
            <remarks>
            So far, comments change is detected only when <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" /> has been changed.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeContainer">This <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasAdded(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object has been added and thus, is not present in the older version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasRemoved(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object has been removed and thus, is not present in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedRecently(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the newer version of the code base, but not by the older version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the older version of the code base, but not by the newer version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.VisibilityWasChanged(NDepend.CodeModel.IMember)">
            <summary>
            Returns <i>true</i> if the visibility of this <paramref name="member" /> has been changed. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="member">This <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.BecameObsolete(NDepend.CodeModel.IMember)">
            <summary>
            Returns <i>true</i> if this <paramref name="member" /> is not tagged with <i>System.ObsoleteAttribute</i> in the older version of the code base, but is tagged as obsolete in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="member">This <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)">
            <summary>
            Returns <i>true</i> if this <paramref name="codeElementParent" /> is a namespace or a type in a third-party assembly (or is a third-party assembly itself) and if some of its children code elements are not used anymore by the newer version of the code base, or are used by the newer version of the code base, but are not used by the older version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" /> must be called instead.
            </summary>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <param name="codeElementParent">This <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object. A <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IType" /> object.</param>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" /> must be called instead.</exception>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency">
            <summary>
            Presents extension methods on code elements, that provides a syntax friendly way to specify dependencies in CQLinq rules queries.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all require a special resolving step prior to query execution, that resolves once for all code elements by name.<br />
            The user doesn't have to write this resolving code. This results in less syntax burden.<br />
            For each of these extension methods, there are one or several corresponding methods in <see cref="N:NDepend.CodeModel" />, that can be called to get the same action done.<br />
            This pre-resolving step is weaved at CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods to calls to their <see cref="N:NDepend.CodeModel" /> equivalent.<br />
            These extension methods cannot be called from a program consuming NDepend.API, since it would provoke the resolving step to be invoked for all code elements.
            </remarks>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)">
            <summary>
            Append the prefix <i>"OPTIONAL:"</i> to <paramref name="codeElementName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />, that takes a code element name string as argument, that if no code element is matched, no exception should be sent.
            </summary>
            <param name="codeElementName">The original code element name.</param>
            <returns><paramref name="codeElementName" /> prefixed with <i>"OPTIONAL:"</i>.</returns>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FromAssembly(System.String,System.String)">
            <summary>
            Append the prefix <i>"FROM_ASM{<paramref name="assemblyName" />}"</i> to <paramref name="codeElementName" /> to restreint code element search by name only to a certain assembly.
            </summary>
            <param name="codeElementName">The original code element name.</param>
            <param name="assemblyName">The original code element name.</param>
            <returns><paramref name="codeElementName" /> prefixed with <i>"FROM_ASM{<paramref name="assemblyName" />}"</i>.</returns>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)">
            <summary>
            Append the prefix <i>"ASSEMBLY:"</i> to <paramref name="assemblyName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only assemblies can be matched by name.
            </summary>
            <param name="assemblyName">The original code element name.</param>
            <returns><paramref name="assemblyName" /> prefixed with <i>"ASSEMBLY:"</i>.</returns>
            <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)">
            <summary>
            Append the prefix <i>"NAMESPACE:"</i> to <paramref name="namespaceName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only namespaces can be matched by name.
            </summary>
            <param name="namespaceName">The original code element name.</param>
            <returns><paramref name="namespaceName" /> prefixed with <i>"NAMESPACE:"</i>.</returns>
            <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)">
            <summary>
            Append the prefix <i>"TYPE:"</i> to <paramref name="typeFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only types can be matched by name.
            </summary>
            <param name="typeFullName">The original code element name.</param>
            <returns><paramref name="typeFullName" /> prefixed with <i>"TYPE:"</i>.</returns>
            <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)">
            <summary>
            Append the prefix <i>"METHOD:"</i> to <paramref name="methodFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only methods can be matched by name.
            </summary>
            <param name="methodFullName">The original code element name.</param>
            <returns><paramref name="methodFullName" /> prefixed with <i>"METHOD:"</i>.</returns>
            <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)">
            <summary>
            Append the prefix <i>"FIELD:"</i> to <paramref name="fieldFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only fields can be matched by name.
            </summary>
            <param name="fieldFullName">The original code element name.</param>
            <returns><paramref name="fieldFullName" /> prefixed with <i>"FIELD:"</i>.</returns>
            <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element user.<br />
            <br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByAssembly(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IAssembly" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="userAssemblyName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userAssemblyName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the assembly user.<br />
            The string <paramref name="userAssemblyName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several assemblies are matched by <paramref name="userAssemblyName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several assemblies are matched by <paramref name="userAssemblyName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByNamespace(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.INamespace" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="userNamespaceName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userNamespaceName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the namespace user.<br />
            The string <paramref name="userNamespaceName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several namespaces are matched by <paramref name="userNamespaceName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several namespaces are matched by <paramref name="userNamespaceName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByType(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the type user.<br />
            The string <paramref name="userTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="userTypeFullName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="userTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByMethod(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IMethod" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userMethodFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userMethodFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the method user.<br />
            The string <paramref name="userMethodFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several methods are matched by <paramref name="userMethodFullName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several methods are matched by <paramref name="userMethodFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns a non-null depth of usage value, if <paramref name="usedCodeElement" /> is <b>directly or indirectly</b> used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element user.<br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userCodeElementFullName" />: <br />
            Returns null if <paramref name="usedCodeElement" /> is not directly nor indirectly used by a <i>userCodeElement</i>.<br />
            Returns 0 if <paramref name="usedCodeElement" /> is, or belongs to, a <i>userCodeElement</i>.<br />
            Returns 1 if <paramref name="usedCodeElement" /> is directly used by a <i>userCodeElement</i>.<br />
            Returns 2 if <paramref name="usedCodeElement" /> is directly used by a code element that is directly used by a <i>userCodeElement</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)">
            <summary>
            Returns true if <paramref name="usedCodeElement" /> is, <b>directly or indirectly</b>, used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
            <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element user.<br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="userCodeElementFullName" />: <br />
            Returns true if <paramref name="usedCodeElement" /> is, <b>directly or indirectly</b>, used by a <i>userCodeElement</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingAssembly(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IAssembly" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="usedAssemblyName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedAssemblyName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the assembly used.<br />
            The string <paramref name="usedAssemblyName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several assemblies are matched by <paramref name="usedAssemblyName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several assemblies are matched by <paramref name="usedAssemblyName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingNamespace(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.INamespace" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="usedNamespaceName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedNamespaceName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the namespace used.<br />
            The string <paramref name="usedNamespaceName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several namespaces are matched by <paramref name="usedNamespaceName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several namespaces are matched by <paramref name="usedNamespaceName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingType(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the type used.<br />
            The string <paramref name="usedTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="usedTypeFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="usedTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingMethod(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IMethod" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedMethodFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedMethodFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the method used.<br />
            The string <paramref name="usedMethodFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several methods are matched by <paramref name="usedMethodFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several methods are matched by <paramref name="usedMethodFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingField(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedFieldFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the field used.<br />
            The string <paramref name="usedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="usedFieldFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several fields are matched by <paramref name="usedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)" /> must be called instead.</exception>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns a non-null depth of usage value, if <paramref name="userCodeElement" /> is <b>directly or indirectly</b> using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>usedCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedCodeElementFullName" />: <br />
            Returns null if <paramref name="userCodeElement" /> is not directly nor indirectly using a <i>usedCodeElement</i>.<br />
            Returns 0 if <paramref name="userCodeElement" /> is, or belongs to, a <i>usedCodeElement</i>.<br />
            Returns 1 if <paramref name="userCodeElement" /> is directly using a <i>usedCodeElement</i>.<br />
            Returns 2 if <paramref name="userCodeElement" /> is directly using a code element that directly uses a <i>usedCodeElement</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)">
            <summary>
            Returns true if <paramref name="userCodeElement" /> is, <b>directly or indirectly</b>, using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
            <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
            <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br />
            <br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br />
            <br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br />
            </param>
            <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="usedCodeElementFullName" />: <br />
            Returns true if <paramref name="userCodeElement" /> is, <b>directly or indirectly</b>, using a <i>userCodeElement</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)">
            <summary>
            Returns a non-null depth of inheritance value, if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a class whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="baseClassFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="type">This derived type.</param>
            <param name="baseClassFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the base class.<br />
            The string <paramref name="baseClassFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several classes are matched by <paramref name="baseClassFullName" />, this method has a <i>derives from <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several classes are matched by <paramref name="baseClassFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>baseClass</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="baseClassFullName" />: <br />
            Returns null if <paramref name="type" /> is not directly nor indirectly deriving from <i>baseClass</i>.<br />
            Returns 0 if <paramref name="type" /> is a <i>baseClass</i>.<br />
            Returns 1 if <paramref name="type" /> directly derives from <i>baseClass</i>.<br />
            Returns 2 if <paramref name="type" /> directly derives from a base class that directly derives from a <i>baseClass</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.</exception>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)">
            <summary>
            Returns true if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a class whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="baseClassFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="type">This derived type.</param>
            <param name="baseClassFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the base class.<br />
            The string <paramref name="baseClassFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several classes are matched by <paramref name="baseClassFullName" />, this method has a <i>derives from <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several classes are matched by <paramref name="baseClassFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>baseClass</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="baseClassFullName" />: <br />
            Returns true if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a <i>baseClass</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.</exception>
            <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
            <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
            <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
            <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)">
            <summary>
            Returns true if <paramref name="type" /> implements an interface whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="interfaceFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="type">This implementer type.</param>
            <param name="interfaceFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the interface.<br />
            The string <paramref name="interfaceFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several interfaces are matched by <paramref name="interfaceFullName" />, this method has a <i>implements <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several interfaces are matched by <paramref name="interfaceFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>interface</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="interfaceFullName" />: <br />
            Returns true if <paramref name="type" /> implements a <i>interface</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" /> must be called instead.</exception>
            <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
            <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
            <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
            <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns true if <paramref name="method" /> has a return value of a type whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="returnTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ReturnType" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="returnTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of this method's return type.<br />
            The string <paramref name="returnTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="returnTypeFullName" />, this method has a <i>returns <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="returnTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>returnType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="returnTypeFullName" />: <br />
            Returns true if <paramref name="method" /> returns a <i>returnType</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ReturnType" /> must be used instead.</exception>
            <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns true if <paramref name="method" /> is assigning a field whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns true if <paramref name="method" /> assigns a <i>assignedField</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" /> must be used instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns true if <paramref name="method" /> is assigning, <b>directly or indirectly</b>, a field whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns true if <paramref name="method" /> assigns, <b>directly or indirectly</b>, a <i>assignedField</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns a non-null depth value, if <paramref name="method" /> is assigning, <b>directly or indirectly</b>, a field whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns null if <paramref name="method" /> is not directly nor indirectly assigning a <i>assignedField</i>.<br />
            Returns 0 if <paramref name="method" /> is assigning a <i>assignedField</i>.<br />
            Returns 1 if <paramref name="method" /> is calling a method that is assigning a <i>assignedField</i>.<br />
            Returns 2 if <paramref name="method" /> is calling a method, that is calling a method, that is assigning a <i>assignedField</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.</exception>
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns true if <paramref name="method" /> is calling a constructor of a type, whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns true if <paramref name="method" /> is creating an instance of <i>createdType</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" /> must be used instead.</exception>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns true if <paramref name="method" /> is calling, <b>directly or indirectly</b>, a constructor of a type, whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns true if <paramref name="method" /> is calling, <b>directly or indirectly</b>, a constructor of <i>createdType</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.</exception>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)">
            <summary>
            Returns a non-null depth value, if <paramref name="method" /> is creating, <b>directly or indirectly</b>, an instance of a type, whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.
            </summary>
            <param name="method">This method.</param>
            <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns null if <paramref name="method" /> is not directly nor indirectly creating an instance of <i>createdType</i>.<br />
            Returns 0 if <paramref name="method" /> is a constructor of <i>createdType</i>.<br />
            Returns 1 if <paramref name="method" /> is calling a constructor of <i>createdType</i>.<br />
            Returns 2 if <paramref name="method" /> is calling a method, that is calling a constructor of <i>createdType</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.</exception>
            <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
            <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)">
            <summary>
            Returns true if <paramref name="field" /> has a field type whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="fieldTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.FieldType" /> must be used instead.
            </summary>
            <param name="field">This field.</param>
            <param name="fieldTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of this field's type.<br />
            The string <paramref name="fieldTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="fieldTypeFullName" />, this method has a <i>has <b>any</b> field type</i> behavior.
            </param>
            <remarks>
            If one or several types are matched by <paramref name="fieldTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <returns>
            <i>fieldType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="fieldTypeFullName" />: <br />
            Returns true if <paramref name="field" /> has for field type a <i>fieldType</i>, otherwise returns false.<br />
            </returns>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.FieldType" /> must be used instead.</exception>
            <see cref="P:NDepend.CodeModel.IField.FieldType" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)">
            <summary>
            Returns true if this <paramref name="attributeTargetCodeElement" /> is directly tagged by a attribute class whose <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> is <paramref name="attributeTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IAttributeTarget" />.<see cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
            <param name="attributeTargetCodeElement">This <see cref="T:NDepend.CodeModel.IAttributeTarget" /> object. A <see cref="T:NDepend.CodeModel.IAttributeTarget" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="attributeTypeFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> of the attribute type.<br />
            The string <paramref name="attributeTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="attributeTypeFullName" />, this method has a <i>tagged by <b>any</b></i> behavior.
            </param>
            <remarks>
            If one or several attribute classes are matched by <paramref name="attributeTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IAttributeTarget" />.<see cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" /> must be called instead.</exception>
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming">
            <summary>
            Presents extension methods to match code elements and members by name, through regular expressions.
            </summary>
            <remarks>
            <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all require a special regular expressions compilation step prior to query execution, that compiles once for all, specified regular expressions.<br />
            The user doesn't have to write this regular expressions compilation step. This results in less syntax burden.<br />
            For each of these extension methods, there are some corresponding methods in <see cref="N:NDepend.CodeModel" />, that can be called to get the same action done.<br />
            This pre regular expression compilation step is weaved at CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods adequately.<br />
            These extension methods cannot be called from a program consuming NDepend.API, since it would provoke regular expressions to be compiled for each code elements.
            </remarks>
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)">
            <summary>
            Returns true if this <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.Name" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
            <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.SimpleNameLike(NDepend.CodeModel.ICodeElement,System.String)">
            <summary>
            Returns true if this <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SimpleName" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object.</param>
            <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
        </member>
        <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.ICodeElement,System.String)">
            <summary>
            Returns true if this <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.FullName" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
            <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object.</param>
            <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
            <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
            <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
            <seealso cref="P:NDepend.CodeModel.ICodeElement.FullName" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
            <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToFullNameLikePredicate(System.String)" />
        </member>
        <member name="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext">
            <summary>
            The CQLinq <b>context</b> represents the single input of a CQLinq query execution.<br />
            This interface is reserved for CQLinq implementation usage and is not intended to be used in your code.
            </summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.CodeBase">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.JustMyCode">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.CompareContext">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.CompareContextDefined">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.IssuesSet">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.IssuesSetDiff">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.DebtSettings">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.DebtFormatter">
            <summary>Gets the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object corresponding to the project debt settings.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.UniqueLoop">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate0">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate1">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate2">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate3">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate4">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate5">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate6">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate7">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate8">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate9">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate10">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate11">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate12">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate13">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate14">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate15">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate16">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate17">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate18">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate19">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate20">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate21">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate22">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate23">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate24">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate25">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate26">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate27">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate28">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate29">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate30">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate31">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator0">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator1">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator2">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator3">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator4">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator5">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator6">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator7">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator8">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator9">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator10">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator11">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator12">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator13">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator14">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator15">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator16">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator17">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator18">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator19">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator20">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator21">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator22">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator23">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator24">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator25">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator26">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator27">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator28">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator29">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator30">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator31">
            <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.Reserved.Linq.CodeQueryProvider">
            <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.CodeQueryProvider.#ctor">
            <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.CodeQueryProvider.Execute(System.Linq.Expressions.Expression)">
            <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.CodeQueryProvider.GetQueryText(System.Linq.Expressions.Expression)">
            <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.Reserved.Linq.ObjectHidden">
            <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.Reserved.Linq.QueryableImpl`1">
            <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.#ctor(NDepend.Reserved.Linq.QueryProviderBase)">
            <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.#ctor(NDepend.Reserved.Linq.QueryProviderBase,System.Linq.Expressions.Expression)">
            <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.GetEnumerator">
            <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.Reserved.Linq.QueryProviderBase">
            <summary>This abstract class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryProviderBase.#ctor">
            <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryProviderBase.GetQueryText(System.Linq.Expressions.Expression)">
            <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="M:NDepend.Reserved.Linq.QueryProviderBase.Execute(System.Linq.Expressions.Expression)">
            <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.Reserved.Linq.UniqueLoopObject">
            <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
        </member>
        <member name="T:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq">
            <summary>
            This static class provides various extension methods related to Debt objects. These methods are usable in CQLinq expressions.
            </summary> 
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.ToDebt(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:NDepend.TechnicalDebt.Debt" /> value from a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="timeSpan">The input <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.ToDebt(System.Nullable{System.TimeSpan})">
            <summary>
            Returns a <see cref="T:NDepend.TechnicalDebt.Debt" /> value from a <i>nullable</i> <see cref="T:System.TimeSpan" /> value.
            </summary>
            <remarks>if <paramref name="nullableTimeSpan" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> is returned.</remarks>
            <param name="nullableTimeSpan">The input  <i>nullable</i> <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.ToAnnualInterest(System.TimeSpan)">
            <summary>
            Returns an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value from a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="timeSpan">The input <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.ToAnnualInterest(System.Nullable{System.TimeSpan})">
            <summary>
            Returns an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value from a <i>nullable</i> <see cref="T:System.TimeSpan" /> value.
            </summary>
            <remarks>if <paramref name="nullableTimeSpan" /> is <i>null</i>, <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> is returned.</remarks>
            <param name="nullableTimeSpan">The input  <i>nullable</i> <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets the time point from now when the estimated cost-to-not-fix the <paramref name="debt" /> will reach the estimated cost-to-fix the <paramref name="debt" />. This time point is named the <strong>breaking point</strong>.
            </summary>
            <remarks>
            The breaking point is the <paramref name="debt" /> divided by the <paramref name="annualInterest" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the breaking point is equal to 5 years from now.<br />
            Notice that a breaking point <i>lower than</i> a year means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value for <paramref name="annualInterest" />, in which case it returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            If <paramref name="annualInterest" /> is zero, then this method returns a zero <see cref="T:System.TimeSpan" />.<br />
            If the division leads to a too large value to be handled by <see cref="T:System.TimeSpan" />, this method will return <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MaxValue" /> or <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.MinValue" />
            depending on the sign of the too large value.<br />
            If <paramref name="debt" /> is overflow or <paramref name="annualInterest" /> is overflow this method returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            </remarks>
            <param name="debt">The estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The estimated cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.BreakingPoint" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets the time point from now when the estimated cost-to-not-fix the <paramref name="debt" /> will reach the estimated cost-to-fix the <paramref name="debt" />. This time point is named the <strong>breaking point</strong>.
            </summary>
            <returns><i><paramref name="debt" />.Value.BreakingPoint(<paramref name="annualInterest" />)</i> if <paramref name="debt" /> is not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The breaking point is the <paramref name="debt" /> divided by the <paramref name="annualInterest" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the breaking point is equal to 5 years from now.<br />
            Notice that a breaking point <i>lower than</i> a year means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value for <paramref name="annualInterest" />, in which case it returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            </remarks>
            <param name="debt">The nullable estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.BreakingPoint" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets the time point from now when the estimated cost-to-not-fix the <paramref name="debt" /> will reach the estimated cost-to-fix the <paramref name="debt" />. This time point is named the <strong>breaking point</strong>.
            </summary>
            <returns><i><paramref name="debt" />.Value.BreakingPoint(<paramref name="annualInterest" />.Value)</i> if both <paramref name="debt" /> and <paramref name="annualInterest" /> are not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The breaking point is the <paramref name="debt" /> divided by the <paramref name="annualInterest" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the breaking point is equal to 5 years from now.<br />
            Notice that a breaking point <i>lower than</i> a year means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value for <paramref name="annualInterest" />, in which case it returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            </remarks>
            <param name="debt">The nullable estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The nullable cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.BreakingPoint" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.BreakingPoint(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets the time point from now when the estimated cost-to-not-fix the <paramref name="debt" /> will reach the estimated cost-to-fix the <paramref name="debt" />. This time point is named the <strong>breaking point</strong>.
            </summary>
            <returns><i><paramref name="debt" />.BreakingPoint(<paramref name="annualInterest" />.Value)</i> if <paramref name="annualInterest" /> is not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The breaking point is the <paramref name="debt" /> divided by the <paramref name="annualInterest" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the breaking point is equal to 5 years from now.<br />
            Notice that a breaking point <i>lower than</i> a year means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> value for <paramref name="annualInterest" />, in which case it returns <see cref="T:System.TimeSpan" />.<see cref="F:System.TimeSpan.Zero" />.
            </remarks>
            <param name="debt">The estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The nullable cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.BreakingPoint" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets the estimated annual <paramref name="debt" /> interest percent, expressed in percent per year.
            </summary>
            <remarks>
            The annual interest percent is equal to 100 multiplied by the <paramref name="annualInterest" /> divided by the <paramref name="debt" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the debt annual interest percent is 20% per year.<br />
            Notice that an annual interest percent <i>higher than</i> 100% means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value for <paramref name="debt" />, in which case it returns <i>zero</i>.
            If <paramref name="debt" /> is overflow or <paramref name="annualInterest" /> is overflow this method returns 0.
            </remarks>
            <param name="debt">The estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.AnnualInterestPercent" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets the estimated annual <paramref name="debt" /> interest percent, expressed in percent per year.
            </summary>
            <returns><i><paramref name="debt" />.Value.AnnualInterestPercent(<paramref name="annualInterest" />)</i> if <paramref name="debt" /> is not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The annual interest percent is equal to 100 multiplied by the <paramref name="annualInterest" /> divided by the <paramref name="debt" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the debt annual interest percent is 20% per year.<br />
            Notice that an annual interest percent <i>higher than</i> 100% means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value for <paramref name="debt" />, in which case it returns <i>zero</i>.
            </remarks>
            <param name="debt">The nullable estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.AnnualInterestPercent" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets the estimated annual <paramref name="debt" /> interest percent, expressed in percent per year.
            </summary>
            <returns><i><paramref name="debt" />.Value.AnnualInterestPercent(<paramref name="annualInterest" />.Value)</i> if both <paramref name="debt" /> and <paramref name="annualInterest" /> are not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The annual interest percent is equal to 100 multiplied by the <paramref name="annualInterest" /> divided by the <paramref name="debt" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the debt annual interest percent is 20% per year.<br />
            Notice that an annual interest percent <i>higher than</i> 100% means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value for <paramref name="debt" />, in which case it returns <i>zero</i>.
            </remarks>
            <param name="debt">The nullable estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The nullable cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.AnnualInterestPercent" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.AnnualInterestPercent(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets the estimated annual <paramref name="debt" /> interest percent, expressed in percent per year.
            </summary>
            <returns><i><paramref name="debt" />.AnnualInterestPercent(<paramref name="annualInterest" />.Value)</i> if <paramref name="annualInterest" /> is not <i>null</i>, else returns <i>null</i>.</returns>
            <remarks>
            The annual interest percent is equal to 100 multiplied by the <paramref name="annualInterest" /> divided by the <paramref name="debt" />.<br />
            For example if the estimated cost-to-fix the <paramref name="debt" /> is equal to 10 man-days, and the estimated cost-to-not-fix the <paramref name="debt" /> is equal to 2 man-days per year 
            (this is the <paramref name="annualInterest" />) then the debt annual interest percent is 20% per year.<br />
            Notice that an annual interest percent <i>higher than</i> 100% means that during the next 12 monthes, it would be cheaper to fix the debt than not to fix it.<br />
            This method accepts <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> value for <paramref name="debt" />, in which case it returns <i>zero</i>.
            </remarks>
            <param name="debt">The estimated cost-to-fix a set of issues, it can be negative in case of debt-diff value.</param>
            <param name="annualInterest">The nullable cost-to-not-fix per year a set of issue, it can be negative in case of annual-interest-diff value.</param>
            <seealso cref="P:NDepend.Issue.IIssue.AnnualInterestPercent" />
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.ToChar(NDepend.TechnicalDebt.DebtRating)">
            <summary>
            Convert the <paramref name="debtRating" /> to a 'A' 'B' 'C' 'D' 'E' char.
            </summary>
            <param name="debtRating">The <see cref="T:NDepend.TechnicalDebt.DebtRating" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.Sum(System.Collections.Generic.IEnumerable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Sum the values of all <see cref="T:NDepend.TechnicalDebt.Debt" /> values in the sequence <paramref name="seq" />.
            </summary>
            <param name="seq">This sequence that contains <see cref="T:NDepend.TechnicalDebt.Debt" /> values to sum</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,NDepend.TechnicalDebt.Debt})">
            <summary>
            Sum the values of all <see cref="T:NDepend.TechnicalDebt.Debt" /> values obtained from elements of the sequence <paramref name="seq" /> through the function <paramref name="projecter" />.
            </summary>
            <param name="seq">This sequence that contains objects that are projected to <see cref="T:NDepend.TechnicalDebt.Debt" /> values to sum, through the function <paramref name="projecter" /></param>
            <param name="projecter">The function that projects <typeparamref name="T" /> objects to <see cref="T:NDepend.TechnicalDebt.Debt" /> values</param>
            <typeparam name="T">The generic type of elements of <paramref name="seq" /></typeparam>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.Sum(System.Collections.Generic.IEnumerable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Sum the values of all <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values in the sequence <paramref name="seq" />.
            </summary>
            <param name="seq">This sequence that contains <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values to sum</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebtUsableInCQLinq.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Sum the values of all <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values obtained from elements of the sequence <paramref name="seq" /> through the function <paramref name="projecter" />.
            </summary>
            <param name="seq">This sequence that contains objects that are projected to <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values to sum, through the function <paramref name="projecter" /></param>
            <param name="projecter">The function that projects <typeparamref name="T" /> objects to <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values</param>
            <typeparam name="T">The generic type of elements of <paramref name="seq" /></typeparam>
        </member>
        <member name="T:NDepend.TechnicalDebt.AnnualInterest">
            <summary>
            Represent the estimated <b>cost-per-year</b>, of an <b>issue-not-fixed</b>, in terms of developer time.
            </summary>
            <remarks>
            The raw value of a annual-interest estimation is based on a time-span.<br />
            An object of type <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> can be used to fomat the annual-interest estimation into man-days, man-months or money.<br />
            A <see cref="T:NDepend.TechnicalDebt.Severity" /> level can also be obtained from a <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> an issue value, through the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToSeverity(NDepend.TechnicalDebt.AnnualInterest)" />.
            In CQLinq code rule, annual-interest values are obtained by casting explicitly a <see cref="T:System.TimeSpan" /> value to an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value,
            or by naming a <i>TimeSpan</i> column <b>AnnualInterest</b>, in which case <i>TimeSpan</i> values are automatically converted to <i>AnnualInterest</i> values.<br />
            Also such annual-interest value obtained in a CQLinq rule context is multiplied by the <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestFactor" />.   
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.#ctor(System.TimeSpan)">
            <summary>
            Build an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value, based on the time-span <paramref name="value" />. 
            </summary>
            <param name="value">The estimated annual-interest of an issue</param>
        </member>
        <member name="P:NDepend.TechnicalDebt.AnnualInterest.Value">
            <summary>
            Get the raw time-span value of this estimated annual-interest value.
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.AnnualInterest.IsOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this annual-interest value reached the positive or negative maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.AnnualInterest.IsPositiveOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this annual-interest value reached the positive maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.AnnualInterest.IsNegativeOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this annual-interest value reached the negative maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.AnnualInterest.Zero">
            <summary>
            AnnualInterest with zero value.
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Implicit(System.TimeSpan)~NDepend.TechnicalDebt.AnnualInterest">
            <summary>
            A <see cref="T:System.TimeSpan" /> value can be implicitly converted to an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <param name="timeSpan">The <see cref="T:System.TimeSpan" /> value to convert to an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Implicit(System.Nullable{System.TimeSpan})~NDepend.TechnicalDebt.AnnualInterest">
            <summary>
            A nullable <see cref="T:System.TimeSpan" /> value can be implicitly converted to a <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <remarks>In case of <i>null</i> <paramref name="nullableTimeSpan" />, the value <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> is built.</remarks>
            <param name="nullableTimeSpan">The nullable <see cref="T:System.TimeSpan" /> value to convert to a <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Implicit(NDepend.TechnicalDebt.AnnualInterest)~System.TimeSpan">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value can be implicitly converted to a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="annualInterest">The <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value to convert to an <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.Equals(System.Object)">
            <summary>
            Returns <i>true</i> if <paramref name="obj" /> is an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> with <see cref="P:NDepend.TechnicalDebt.AnnualInterest.Value" /> equals to <i>this</i>.<see cref="P:NDepend.TechnicalDebt.AnnualInterest.Value" />.
            </summary>
            <param name="obj">The object to compare to</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.GetHashCode">
            <summary>
            Returns a hash code for this instance, from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.AnnualInterest.Value" />.
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Equality(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Equality compare <paramref name="annualInterest" /> and <paramref name="y" />.
            </summary>
            <param name="annualInterest">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Equality(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Equality compare <paramref name="annualInterest" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Equality(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Equality compare <paramref name="annualInterest" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Inequality(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Inequality compare <paramref name="x" /> and <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Inequality(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Inequality compare <paramref name="annualInterest" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Inequality(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Inequality compare <paramref name="annualInterest" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is lower than or equals to <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="annualInterest" /> is lower than or equals to <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is lower than or equals to <paramref name="annualInterest" />.
            </summary>
            <param name="timeSpan">Annual-interest estimation operand</param>
            <param name="annualInterest">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and lower than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is lower than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is lower than or equal to <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThanOrEqual(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is higher than or equals to <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="annualInterest" /> is higher than or equals to <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is higher than or equals to <paramref name="annualInterest" />.
            </summary>
            <param name="timeSpan">Annual-interest estimation operand</param>
            <param name="annualInterest">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and higher than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is higher than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is higher than or equal to <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThanOrEqual(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="annualInterest" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is strictly lower than <paramref name="annualInterest" />.
            </summary>
            <param name="timeSpan">Annual-interest estimation operand</param>
            <param name="annualInterest">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is strictly lower than <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_LessThan(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="annualInterest" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is strictly higher than <paramref name="annualInterest" />.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is strictly higher than <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_GreaterThan(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Multiply(System.Double,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Multiply <paramref name="x" /> by <paramref name="factor" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="factor">The factor by which <paramref name="x" /> is multiplied.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Multiply(NDepend.TechnicalDebt.AnnualInterest,System.Double)">
            <summary>
            Multiply <paramref name="x" /> by <paramref name="factor" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="factor">The factor by which <paramref name="x" /> is multiplied.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Division(NDepend.TechnicalDebt.AnnualInterest,System.Double)">
            <summary>
            Divide <paramref name="x" /> by <paramref name="quotient" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="quotient">The quotient by which <paramref name="x" /> is divided.</param>
            <exception cref="T:System.DivideByZeroException">This exception is thrown if quotient is zero.</exception>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Addition(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Addition(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Add <paramref name="annualInterest" /> and <paramref name="timeSpan" /> and returns the result in an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Addition(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Add <paramref name="timeSpan" /> and <paramref name="annualInterest" /> and returns the result in an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Addition(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />. If <paramref name="x" /> is null, returns null.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Addition(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />. If <paramref name="y" /> is null, returns null.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Subtraction(NDepend.TechnicalDebt.AnnualInterest,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Substract <paramref name="y" /> to <paramref name="x" />.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Subtraction(NDepend.TechnicalDebt.AnnualInterest,System.TimeSpan)">
            <summary>
            Substract <paramref name="annualInterest" /> to <paramref name="timeSpan" /> and returns the result in an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Subtraction(System.TimeSpan,NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Substract <paramref name="timeSpan" /> to <paramref name="annualInterest" /> and returns the result in an <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value.
            </summary>
            <param name="annualInterest">A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Subtraction(System.Nullable{NDepend.TechnicalDebt.AnnualInterest},NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Substract <paramref name="x" /> to <paramref name="y" />. If <paramref name="x" /> is null, returns null.
            </summary>
            <param name="x">Nullable annual-interest estimation operand</param>
            <param name="y">Annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_Subtraction(NDepend.TechnicalDebt.AnnualInterest,System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Substract <paramref name="x" /> to <paramref name="y" />. If <paramref name="y" /> is null, returns null.
            </summary>
            <param name="x">Annual-interest estimation operand</param>
            <param name="y">Nullable annual-interest estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.AnnualInterest.op_UnaryNegation(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Negate <paramref name="x" />.
            </summary>
            <param name="x">Annual-interest estimation operand to negate.</param>
        </member>
        <member name="T:NDepend.TechnicalDebt.Severity">
            <summary>
            This enumeration defines the level of severity that an issue can have.
            </summary>
            <remarks>
            The severity of an issue depends on the <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> the issue, expressed in man-time per year,
            and is obtained from the severity thresholds defined in <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Low">
            <summary>
            The severity level <i>Low</i> is used by issues that have a zero, or close to zero, value for <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.
            </summary>
            <remarks>
            Issues with a <i>Low</i> severity level represents small improvements, ways to make the code looks more elegant.<br />
            The <i>Broken Window Theory</i> https://en.wikipedia.org/wiki/Broken_windows_theory states that:
            <i>Consider a building with a few broken windows. If the windows are not repaired, the tendency is for vandals to break a few more windows. Eventually, they may even break into the building, and if it's unoccupied, perhaps become squatters or light fires inside.</i>. <br />
            <br />
            Issues with a <i>Low</i> or <i>Medium</i> severity level represents the <i>broken windows</i> of a code base.
            If they are not fixed, the tendency is for developers to not care for living in an elegant code, which will result in extra-maintenance-cost in the long term.
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Medium">
            <summary>
            An issue with a severity level <i>Medium</i> is a warning that if not fixed, won't have a significant impact on development.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.High">
            <summary>
            An issue with a severity level <i>High</i> should be fixed quickly, but can wait until the next scheduled interval.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Critical">
            <summary>
            An issue with a severity level <i>Critical</i> shouldn't move to production. 
            It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Blocker">
            <summary>
            An issue with a severity level <i>Blocker</i> cannot move to production, it <b>must</b> be fixed. 
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Info">
            <summary>
            Use Severity.Low instead
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Minor">
            <summary>
            Use Severity.Medium instead
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.Severity.Major">
            <summary>
            Use Severity.High instead
            </summary>
        </member>
        <member name="T:NDepend.TechnicalDebt.Debt">
            <summary>
            Represent the estimated debt an issue. Such estimation represents the <b>technical debt generated by the issue</b>.
            </summary>
            <remarks>
            The raw value of a debt estimation is based on a time-span.<br />
            An object of type <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> can be used to fomat the debt estimation into man-days, man-months, money or ratio or rate.<br />
            In CQLinq code rule, debt values are obtained by casting explicitly a <see cref="T:System.TimeSpan" /> value to a <see cref="T:NDepend.TechnicalDebt.Debt" /> value,
            or by naming a <i>TimeSpan</i> column <b>Debt</b> (in which case <i>TimeSpan</i> values are automatically converted to <i>Debt</i> values.<br />
            Also such debt value obtained in a CQLinq rule context is multipied by the <see cref="T:NDepend.TechnicalDebt.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtFactor" />.   
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.#ctor(System.TimeSpan)">
            <summary>
            Build a <see cref="T:NDepend.TechnicalDebt.Debt" /> value, based on the time-span <paramref name="value" />. 
            </summary>
            <param name="value">The estimated debt an issue</param>
        </member>
        <member name="P:NDepend.TechnicalDebt.Debt.Value">
            <summary>
            Get the raw time-span value of this estimated debt value.
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.Debt.IsOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this debt value reached the positive or negative maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.Debt" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.Debt.IsPositiveOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this debt value reached the positive maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.Debt" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.Debt.IsNegativeOverflow">
            <summary>
            Returns <i>true</i> if the internal <i>ticks</i> value of this debt value reached the negative maximum autorized by <see cref="T:System.TimeSpan" />.<see cref="P:System.TimeSpan.Ticks" />.
            </summary>
            <remarks>
            Minimum and maximum range for an <see cref="T:NDepend.TechnicalDebt.Debt" /> value is a bit more than [-29 247 years ; +29 247 years].
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.Debt.Zero">
            <summary>
            Debt with zero value.
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Implicit(System.TimeSpan)~NDepend.TechnicalDebt.Debt">
            <summary>
            A <see cref="T:System.TimeSpan" /> value can be implicitly converted to a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <param name="timeSpan">The <see cref="T:System.TimeSpan" /> value to convert to a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Implicit(System.Nullable{System.TimeSpan})~NDepend.TechnicalDebt.Debt">
            <summary>
            A nullable <see cref="T:System.TimeSpan" /> value can be implicitly converted to a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <remarks>In case of <i>null</i> <paramref name="nullableTimeSpan" />, the value <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" /> is built.</remarks>
            <param name="nullableTimeSpan">The nullable <see cref="T:System.TimeSpan" /> value to convert to a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Implicit(NDepend.TechnicalDebt.Debt)~System.TimeSpan">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.Debt" /> value can be implicitly converted to a <see cref="T:System.TimeSpan" /> value.
            </summary>
            <param name="debt">The <see cref="T:NDepend.TechnicalDebt.Debt" /> value to convert to a <see cref="T:System.TimeSpan" /> value.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.Equals(System.Object)">
            <summary>
            Returns <i>true</i> if <paramref name="obj" /> is a <see cref="T:NDepend.TechnicalDebt.Debt" /> with <see cref="P:NDepend.TechnicalDebt.Debt.Value" /> equals to <i>this</i>.<see cref="P:NDepend.TechnicalDebt.Debt.Value" />.
            </summary>
            <param name="obj">The object to compare to</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.GetHashCode">
            <summary>
            Returns a hash code for this instance, from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.Debt.Value" />.
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Equality(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Equality compare <paramref name="debt" /> and <paramref name="y" />.
            </summary>
            <param name="debt">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Equality(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Equality compare <paramref name="debt" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Equality(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Equality compare <paramref name="debt" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Inequality(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Inequality compare <paramref name="x" /> and <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Inequality(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Inequality compare <paramref name="debt" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Inequality(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Inequality compare <paramref name="debt" /> and <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is lower than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="timeSpan">Debt estimation operand</param>
            <param name="debt">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and lower than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is lower than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is lower than or equal to <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(NDepend.TechnicalDebt.Debt,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is lower than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThanOrEqual(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is lower than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is higher than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="timeSpan">Debt estimation operand</param>
            <param name="debt">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and higher than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is higher than or equal to <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is higher than or equal to <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(NDepend.TechnicalDebt.Debt,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is higher than or equal to <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThanOrEqual(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is higher than or equal to <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="timeSpan">Debt estimation operand</param>
            <param name="debt">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is strictly lower than <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is strictly lower than <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(NDepend.TechnicalDebt.Debt,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is strictly lower than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_LessThan(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is strictly lower than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="x" /> is not null and strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="y" /> is not null and <paramref name="x" /> is strictly higher than <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="x" /> and <paramref name="y" /> are not null, and <paramref name="x" /> value is strictly higher than <paramref name="y" /> value.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.TimeSpan)">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.TimeSpan,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if <paramref name="debt" /> is not null and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(NDepend.TechnicalDebt.Debt,System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="debt" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{System.TimeSpan},NDepend.TechnicalDebt.Debt)">
            <summary>
            Returns <i>true</i> if <paramref name="timeSpan" /> is not null, and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{NDepend.TechnicalDebt.Debt},System.Nullable{System.TimeSpan})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="debt" /> is strictly higher than <paramref name="timeSpan" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_GreaterThan(System.Nullable{System.TimeSpan},System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Returns <i>true</i> if both <paramref name="debt" /> and <paramref name="timeSpan" /> are not null, and <paramref name="timeSpan" /> is strictly higher than <paramref name="debt" />.
            </summary>
            <param name="debt">A nullable <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A nullable <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Multiply(System.Double,NDepend.TechnicalDebt.Debt)">
            <summary>
            Multiply <paramref name="x" /> by <paramref name="factor" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="factor">The factor by which <paramref name="x" /> is multiplied.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Multiply(NDepend.TechnicalDebt.Debt,System.Double)">
            <summary>
            Multiply <paramref name="x" /> by <paramref name="factor" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="factor">The factor by which <paramref name="x" /> is multiplied.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Division(NDepend.TechnicalDebt.Debt,System.Double)">
            <summary>
            Divide <paramref name="x" /> by <paramref name="quotient" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="quotient">The quotient by which <paramref name="x" /> is divided.</param>
            <exception cref="T:System.DivideByZeroException">This exception is thrown if quotient is zero.</exception>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Addition(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Addition(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Add <paramref name="debt" /> and <paramref name="timeSpan" /> and returns the result in a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Addition(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Add <paramref name="timeSpan" /> and <paramref name="debt" /> and returns the result in a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Addition(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />. If <paramref name="x" /> is null, returns null.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Addition(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Add <paramref name="x" /> and <paramref name="y" />. If <paramref name="y" /> is null, returns null.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Subtraction(NDepend.TechnicalDebt.Debt,NDepend.TechnicalDebt.Debt)">
            <summary>
            Substract <paramref name="y" /> to <paramref name="x" />.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Subtraction(NDepend.TechnicalDebt.Debt,System.TimeSpan)">
            <summary>
            Substract <paramref name="debt" /> to <paramref name="timeSpan" /> and returns the result in a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Subtraction(System.TimeSpan,NDepend.TechnicalDebt.Debt)">
            <summary>
            Substract <paramref name="timeSpan" /> to <paramref name="debt" /> and returns the result in a <see cref="T:NDepend.TechnicalDebt.Debt" /> value.
            </summary>
            <param name="debt">A <see cref="T:NDepend.TechnicalDebt.Debt" /> value operand</param>
            <param name="timeSpan">A <see cref="T:System.TimeSpan" /> value operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Subtraction(System.Nullable{NDepend.TechnicalDebt.Debt},NDepend.TechnicalDebt.Debt)">
            <summary>
            Substract <paramref name="x" /> to <paramref name="y" />. If <paramref name="x" /> is null, returns null.
            </summary>
            <param name="x">Nullable debt estimation operand</param>
            <param name="y">Debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_Subtraction(NDepend.TechnicalDebt.Debt,System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Substract <paramref name="x" /> to <paramref name="y" />. If <paramref name="y" /> is null, returns null.
            </summary>
            <param name="x">Debt estimation operand</param>
            <param name="y">Nullable debt estimation operand</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.Debt.op_UnaryNegation(NDepend.TechnicalDebt.Debt)">
            <summary>
            Negate <paramref name="x" />.
            </summary>
            <param name="x">Debt estimation operand to negate.</param>
        </member>
        <member name="T:NDepend.TechnicalDebt.DebtRating">
            <summary>
            The debt rating is estimated from the percentage of technical debt on a <see cref="T:NDepend.CodeModel.ICodeElement" /> object
            and from the various rating thresholds defined in this <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object. <br />
            </summary>
            <remarks>
            This implements the concept of SQALE Rating defined by the SQALE method: http://www.sqale.org/
            </remarks>
            <seealso cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtRating.A">
            <summary>Debt rating A</summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtRating.B">
            <summary>Debt rating B</summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtRating.C">
            <summary>Debt rating C</summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtRating.D">
            <summary>Debt rating D</summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtRating.E">
            <summary>Debt rating E</summary>
        </member>
        <member name="T:NDepend.TechnicalDebt.DebtStringFormat">
            <summary>
            Define constants related to string formatting obtained from <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToString(System.TimeSpan,System.String)" /> method.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MONEY">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoneyString(System.TimeSpan)" />.
            </summary>
            <seealso cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.TimeSpan)" />
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MONEY_DETAILLED">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoneyStringDetailled(System.TimeSpan)" />.
            </summary>
            <remarks>There is a typo in the field name on 'Detailed' but we prefer to not set this field as obsolete just for a typo.</remarks>
            <seealso cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.TimeSpan)" />
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_DAY_DOUBLE">
            <summary>
            This tag is replaced by the total double number of man-days represented by the duration.
            </summary>
            <remarks>There is a typo on 'detailed' with on 'L' we prefer to not set this field as obsolete just for a typo.</remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_DAY_DETAILLED">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDayStringDetailled(System.TimeSpan)" />.
            </summary>
            <remarks>There is a typo in the field name on 'Detailed' but we prefer to not set this field as obsolete just for a typo.</remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_DAY">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDayString(System.TimeSpan)" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_MONTH_DOUBLE">
            <summary>
            This tag is replaced by the total double number of man-months represented by the duration.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_MONTH_DETAILLED">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonthStringDetailled(System.TimeSpan)" />.
            </summary>
            <remarks>There is a typo in the field name on 'Detailed' but we prefer to not set this field as obsolete just for a typo.</remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_MONTH">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonthString(System.TimeSpan)" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_YEAR_DOUBLE">
            <summary>
            This tag is replaced by the total double number of man-years represented by the duration.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_YEAR_DETAILLED">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYearStringDetailled(System.TimeSpan)" />.
            </summary>
            <remarks>There is a typo in the field name on 'Detailed' but we prefer to not set this field as obsolete just for a typo.</remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_YEAR">
            <summary>
            This tag is replaced by the string obtained from the method <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYearString(System.TimeSpan)" />.
            </summary>
        </member>
        <member name="T:NDepend.TechnicalDebt.ExtensionMethodsDebt">
            <summary>
            This static class provides various extension methods related to Debt objects.
            </summary> 
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebt.CreateDebtFormatter(NDepend.TechnicalDebt.DebtSettings)">
            <summary>
            Create a <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object from this debt settings object.
            </summary>
            <param name="debtSettings">The <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> object from which to get the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object.</param>
            <remarks>
            The <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object store a cloned copy of <paramref name="debtSettings" />.<br />
            If this <paramref name="debtSettings" /> are changing, the settings contained in the returned <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object are not changed.
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebt.ToBackColor(NDepend.TechnicalDebt.DebtRating)">
            <summary>
            Convert the <paramref name="debtRating" /> to a back color.
            </summary>
            <param name="debtRating">The <see cref="T:NDepend.TechnicalDebt.DebtRating" /> value.</param>
            <remarks>
            Strong green (RGB: 51;204;51) is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" />.<br />
            Light green (RGB: 153;255;101) is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.B" />.<br />
            Yellow (RGB: 255;255;0) is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.C" />.<br />
            Orange (RGB: 255;153;0) is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.D" />.<br />
            Red (RGB: 255;0;0) is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.E" />.<br />
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebt.ToForeColor(NDepend.TechnicalDebt.DebtRating)">
            <summary>
            Convert the <paramref name="debtRating" /> to a fore color.
            </summary>
            <param name="debtRating">The <see cref="T:NDepend.TechnicalDebt.DebtRating" /> value.</param>
            <remarks>
            Black is returned for <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.A" />, <see cref="F:NDepend.TechnicalDebt.DebtRating.B" />, <see cref="F:NDepend.TechnicalDebt.DebtRating.C" /> and <see cref="F:NDepend.TechnicalDebt.DebtRating.D" />.<br />
            White is returned for the value <see cref="T:NDepend.TechnicalDebt.DebtRating" />.<see cref="F:NDepend.TechnicalDebt.DebtRating.E" />.<br />
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.ExtensionMethodsDebt.GetImage``1(NDepend.TechnicalDebt.Severity)">
            <summary>
            Get the image that represents the <paramref name="severity" /> level.
            </summary>
            <param name="severity">The severity level.</param>
            <typeparam name="T">So far the GetImage&lt;T&gt;() parameter type T must be System.Drawing.Image. This requirement might evolve in future version when other UI framework will be supported.</typeparam>
        </member>
        <member name="T:NDepend.TechnicalDebt.IDebtFormatter">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object is used to format a <see cref="T:System.TimeSpan" /> value to human-readable object, like man-months string or money amount.
            </summary>
            <remarks>
            A <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object can be created 
            from the <see cref="T:NDepend.Project.IProject" /> extension method <see cref="T:NDepend.TechnicalDebt.ExtensionMethodsDebt" />.<see cref="M:NDepend.TechnicalDebt.ExtensionMethodsDebt.CreateDebtFormatter(NDepend.TechnicalDebt.DebtSettings)" />.<br />
            A <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object is immutable. 
            The settings it contains on which formatting is based, cannot be changed.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings">
            <summary>
            Gets a cloned copy of the <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object from which formatting is done by this <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.
            </summary>
            <remarks>
            A <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object is immutable. 
            The settings it contains on which formatting is based, cannot be changed.
            This is why this property returns a cloned copy of debts-settings.
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToString(System.TimeSpan)">
            <summary>
            Format the technical <paramref name="duration" /> to a string, according to the <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtStringFormat" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <returns>A string representing the technical debt estimation formatted</returns>
            <seealso cref="T:NDepend.TechnicalDebt.DebtStringFormat" />
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToString(System.TimeSpan,System.String)">
            <summary>
            Format the technical <paramref name="duration" /> to a string, according to the <paramref name="format" /> string.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <param name="format">The string that contains debt formatting tags defined in <see cref="T:NDepend.TechnicalDebt.DebtStringFormat" />.</param>
            <returns>A string representing the technical debt estimation formatted</returns>
            <remarks>
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
            <seealso cref="T:NDepend.TechnicalDebt.DebtStringFormat" />
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.TimeSpan)">
            <summary>
            Estimate an amount of money from a <paramref name="duration" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.
            </remarks>
            <param name="duration">The duration to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.Nullable{System.TimeSpan})">
            <summary>
            Estimate an amount of money from a <paramref name="duration" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.<br />
            If <paramref name="duration" /> is <i>null</i> this method returns <i>null</i>.
            </remarks>
            <param name="duration">The duration to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(NDepend.TechnicalDebt.Debt)">
            <summary>
            Estimate an amount of money from a <paramref name="debt" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.
            </remarks>
            <param name="debt">The debt to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Estimate an amount of money from a <paramref name="debt" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.<br />
            If <paramref name="debt" /> is <i>null</i> this method returns <i>null</i>.
            </remarks>
            <param name="debt">The nullable debt to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Estimate an amount of money from a <paramref name="annualInterest" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.
            </remarks>
            <param name="annualInterest">The debt to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoney(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Estimate an amount of money from a <paramref name="annualInterest" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            The cents are not shown if the amount of money is greater or equals to 50.<br />
            If <paramref name="annualInterest" /> is <i>null</i> this method returns <i>null</i>.
            </remarks>
            <param name="annualInterest">The nullable annual interest to evaluate as money</param>
            <returns>A double value that represents an amount of money </returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoneyString(System.TimeSpan)">
            <summary>
            Gets a string shortened with 'K' for thousands and 'M' for millions, that represents an amount of money estimated from a <paramref name="duration" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
            <param name="duration">The duration to evaluate as money</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToMoneyStringDetailled(System.TimeSpan)">
            <summary>
            Gets a string that represents an amount of money estimated from a <paramref name="duration" />.
            </summary>
            <remarks>
            This <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" /> object has been created from a <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object.<br />
            The amount of money is expressed in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" /> and is computed from the setting <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" />.
            <br />
            There is a typo in the method name on 'Detailed' but we prefer to not set this method as obsolete just for a typo.<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
            <param name="duration">The duration to evaluate as money</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.TimeSpan)">
            <summary>
            Gets a double number of man-days that represents <paramref name="duration" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-days that represents <paramref name="duration" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <remarks>If <paramref name="duration" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="duration">The estimated nullable duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-days that represents <paramref name="debt" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-days that represents <paramref name="debt" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <remarks>If <paramref name="debt" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="debt">The estimated nullable cost to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-days that represents <paramref name="annualInterest" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="annualInterest">The estimated cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-days that represents <paramref name="annualInterest" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <remarks>If <paramref name="annualInterest" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="annualInterest">The estimated nullable cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDay(System.TimeSpan,System.TimeSpan@)">
            <summary>
            Gets an integer number of man-days that represents <paramref name="duration" />. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <param name="residualHoursMinutesSeconds">Out parameter that represents the residual less-than-a-man-day duration, expressed in hours/minutes/seconds</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDayString(System.TimeSpan)">
            <summary>
            Gets a string that represents <paramref name="duration" /> as a number of man-days. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1 234d  2h"<br />  
            "2:02:43" if duration is less than a man-day<br />
            "2min 43s" if duration is less than an hour<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManDayStringDetailled(System.TimeSpan)">
            <summary>
            Gets a detailled string that represents <paramref name="duration" /> as a number of man-days. 
            The number of man-days is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1 234d  2:02:43" <br />  
            "2:02:43" if duration is less than a man-days<br />
            "2min 43s" if duration is less than an hour
            <br />
            There is a typo in the method name on 'Detailed' but we prefer to not set this method as obsolete just for a typo.<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.TimeSpan)">
            <summary>
            Gets a double number of man-months that represents <paramref name="duration" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-months that represents <paramref name="duration" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="duration" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="duration">The estimated nullable duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-months that represents <paramref name="debt" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-months that represents <paramref name="debt" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="debt" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="debt">The estimated nullable cost to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-months that represents <paramref name="annualInterest" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The estimated cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-months that represents <paramref name="annualInterest" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="annualInterest" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="annualInterest">The estimated nullable cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonth(System.TimeSpan,System.Int32@,System.TimeSpan@)">
            <summary>
            Gets an integer number of man-months that represents <paramref name="duration" />. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <param name="residualDays">Out parameter that represents the residual less-than-a-man-months number of man-days</param>
            <param name="residualHoursMinutesSeconds">Out parameter that represents the residual less-than-a-man-day duration, expressed in hours/minutes/seconds</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonthString(System.TimeSpan)">
            <summary>
            Gets a string that represents <paramref name="duration" /> as a number of man-months. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1m  12d" hours are not shown if duration is at least a man-month<br />
            "12d  2h" if duration is less than a man-month<br />  
            "2:02:43" if duration is less than a man-day<br />
            "2min 43s" if duration is less than an hour<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManMonthStringDetailled(System.TimeSpan)">
            <summary>
            Gets a detailled string that represents <paramref name="duration" /> as a number of man-months. 
            The number of man-months is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1m  12d  2:02:43" if duration is at least a man-month<br />
            "12d  2:02:43" if duration is less than a man-month<br />  
            "2:02:43" if duration is less than a man-day<br />
            "2min 43s" if duration is less than an hour<br />
            <br />
            There is a typo in the method name on 'Detailed' but we prefer to not set this method as obsolete just for a typo.<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.TimeSpan)">
            <summary>
            Gets a double number of man-years that represents <paramref name="duration" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.Nullable{System.TimeSpan})">
            <summary>
            Gets a double number of man-years that represents <paramref name="duration" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="duration" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="duration">The estimated nullable duration to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(NDepend.TechnicalDebt.Debt)">
            <summary>
            Gets a double number of man-years that represents <paramref name="debt" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="debt">The estimated effort to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.Debt})">
            <summary>
            Gets a double number of man-years that represents <paramref name="debt" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="debt" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="debt">The estimated nullable cost to fix one or several issues</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a double number of man-years that represents <paramref name="annualInterest" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="annualInterest">The estimated cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.Nullable{NDepend.TechnicalDebt.AnnualInterest})">
            <summary>
            Gets a double number of man-years that represents <paramref name="annualInterest" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <remarks>If <paramref name="annualInterest" /> is <i>null</i> this method returns <i>null</i>.</remarks>
            <param name="annualInterest">The estimated nullable cost per year to leave one or several issues unfixed</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYear(System.TimeSpan,System.Int32@,System.TimeSpan@)">
            <summary>
            Gets an integer number of man-years that represents <paramref name="duration" />. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <param name="residualDays">Out parameter that represents the residual less-than-a-man-years number of man-days</param>
            <param name="residualHoursMinutesSeconds">Out parameter that represents the residual less-than-a-man-day duration, expressed in hours/minutes/seconds</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYearString(System.TimeSpan)">
            <summary>
            Gets a string that represents <paramref name="duration" /> as a number of man-years. 
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1y  2m  12d" hours are not shown if duration is at least a man-year<br />
            "2m  12d" hours are not shown if duration is at least a man-month<br />
            "12d  2h" if duration is less than a man-month<br />  
            "2:02:43" if duration is less than a man-day<br />
            "2min 43s" if duration is less than an hour<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToManYearStringDetailled(System.TimeSpan)">
            <summary>
            Gets a detailled string that represents <paramref name="duration" /> as a number of man-years.
            The number of man-years is computed from <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> and <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear" />.
            </summary>
            <param name="duration">The estimated duration to fix one or several issues</param>
            <remarks>
            For example this method can return: <br /> 
            "1y  2m  12d  2:02:43" if duration is at least a man-years<br />
            "1m  12d  2:02:43" if duration is at least a man-month<br />
            "12d  2:02:43" if duration is less than a man-month<br />  
            "2:02:43" if duration is less than a man-day<br />
            "2min 43s" if duration is less than an hour<br />
            <br />
            There is a typo in the method name on 'Detailed' but we prefer to not set this method as obsolete just for a typo.<br />
            If <paramref name="duration" />.<see cref="P:System.DateTime.Ticks" /> is higher than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MAX_TICKS" /> or lower than <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.MIN_TICKS" /> this method returns the string "overflow".
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)">
            <summary>
            Estimate the debt rating of <paramref name="codeElement" /> in the range <see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> (very good) to <see cref="F:NDepend.TechnicalDebt.DebtRating.E" /> (very bad).
            </summary>
            <remarks>
            The debt rating is estimated by the value of the Technical Debt Ratio for <paramref name="codeElement" /> obtained from <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />,
            and from the various rating thresholds defined in this <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> object. <br />
            If <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> returns null for <paramref name="codeElement" />, this method returns <i>null</i> as well.
            </remarks>
            <param name="debt">The estimated debt to fix all issues on <paramref name="codeElement" /></param>
            <param name="codeElement">The code element on which we infer the rating from the <paramref name="debt" /></param>
            <returns>The debt rating in the range <see cref="F:NDepend.TechnicalDebt.DebtRating.A" /> (very good) to <see cref="F:NDepend.TechnicalDebt.DebtRating.E" /> (very bad) or null if the method <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i> for <paramref name="codeElement" />.</returns>
            <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement,NDepend.TechnicalDebt.DebtRating)">
            <summary>
            Returns the estimated effort to reach <paramref name="ratingToReach" />, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <paramref name="debt" />.
            </summary>
            <param name="debt">The estimated debt to fix all issues on <paramref name="codeElement" /></param>
            <param name="codeElement">The code element on which we infer the rating from the <paramref name="debt" /></param>
            <param name="ratingToReach">The rating to reach for <paramref name="codeElement" /></param>
            <remarks>
            If the actual rating of <paramref name="codeElement" /> given <paramref name="debt" /> is equals or better than <paramref name="ratingToReach" />,
            this method returns a zero duration <see cref="T:NDepend.TechnicalDebt.Debt" /> value.<br />
            If <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> returns null for <paramref name="codeElement" />, this method returns <i>null</i>.
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.CostToReachBetterRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)">
            <summary>
            Returns the estimated cost, to reach a better rating, based on the fact that <paramref name="codeElement" /> has actually a total debt estimated to <paramref name="debt" />.
            </summary>
            <param name="debt">The estimated debt to fix all issues on <paramref name="codeElement" /></param>
            <param name="codeElement">The code element on which we infer the rating from the <paramref name="debt" /></param>
            <remarks>
            <i>Better rating</i> means the rating just better than the actual one.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.D" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.C" />.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.B" />, better rating is  <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />.<br />
            If code element actual rating is <see cref="F:NDepend.TechnicalDebt.DebtRating.A" />, this method returns <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="F:NDepend.TechnicalDebt.Debt.Zero" />.<br />
            If <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> returns null for <paramref name="codeElement" />, this method returns <i>null</i>.
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)">
            <summary>
            Estimate the ratio of technical debt, measured through <paramref name="debt" />, for <paramref name="codeElement" />. 
            This ratio is expressed in percentage, of estimated <paramref name="debt" />, compared to the estimated time it would take to rewrite <paramref name="codeElement" /> from scratch. 
            </summary>
            <remarks>
            This method is obtaining the number of lines of code for <paramref name="codeElement" /> from the method,
            <see cref="T:NDepend.CodeModel.ExtensionMethodsHelpers" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" />.<br />
            This method returns <i>null</i>, if and only if,  <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i> for <paramref name="codeElement" />.<br />
            To estimate the time it would take to rewrite <paramref name="codeElement" /> from scratch, both <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> values are used: <br />  
             - <see cref="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode" /> <br />
             - <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> <br />
            </remarks>
            <param name="debt">The estimated debt to fix all issues on <paramref name="codeElement" /></param>
            <param name="codeElement">The code element on which we infer the percentage of <paramref name="debt" /></param>
            <returns>The percentage of technical debt or null if the metric <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is not available for <paramref name="codeElement" />.</returns>
            <see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatioString(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)">
            <summary>
            Gets a string that represents the ratio of technical debt, measured through <paramref name="debt" />, for <paramref name="codeElement" />.
            This ratio is expressed in percentage of estimated <paramref name="debt" /> to fix the debt, compared to the estimated duration it would take to rewrite <paramref name="codeElement" /> from scratch.
            </summary>
            <remarks>
            This method is obtaining the number of lines of code for <paramref name="codeElement" /> from the method,
            <see cref="T:NDepend.CodeModel.ExtensionMethodsHelpers" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" />.<br />
            This method returns null, if and only if,  <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i> for <paramref name="codeElement" />.<br />
            To estimate the time it would take to rewrite <paramref name="codeElement" /> from scratch, both <see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" /> values are used: <br />  
             - <see cref="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode" /> <br />
             - <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> <br />
            If <paramref name="debt" /> is overflow this method returns the string "overflow".
            </remarks>
            <param name="debt">The estimated debt to fix all issues on <paramref name="codeElement" /></param>
            <param name="codeElement">The code element on which we infer the percentage of <paramref name="debt" /></param>
            <returns>The percentage of technical debt or the string "N/A" if the metric <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is not available for <paramref name="codeElement" />.</returns>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.ToSeverity(NDepend.TechnicalDebt.AnnualInterest)">
            <summary>
            Gets a <see cref="T:NDepend.TechnicalDebt.Severity" /> from <paramref name="annualInterest" /> an issue, expressed in man-time per year.
            </summary>
            <remarks>
            The <see cref="T:NDepend.TechnicalDebt.Severity" /> value returned, is inferred from severity thresholds defined in <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<br />
            Negative and zero values of <paramref name="annualInterest" /> are valid and lead to <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" /> returned.<br />  
            </remarks>
            <param name="annualInterest">The <i>annual-interest</i> an issue, expressed in man-time per year.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.AnnualInterestThreshold(NDepend.TechnicalDebt.Severity)">
            <summary>
            Get the <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> threshold corresponding to the <paramref name="severity" />
            </summary>
            <remarks>
            <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="F:NDepend.TechnicalDebt.AnnualInterest.Zero" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Low" />.<br />
            The <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Medium" />.<br />
            The <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Medium2HighSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.High" />.<br />
            The <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.High2CriticalSeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Critical" />.<br />
            The <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold" /> is returned for <see cref="T:NDepend.TechnicalDebt.Severity" />.<see cref="F:NDepend.TechnicalDebt.Severity.Blocker" />.
            </remarks>
            <param name="severity">The severity level to get the threshold from.</param>
        </member>
        <member name="M:NDepend.TechnicalDebt.IDebtFormatter.EffortToDevelop(NDepend.CodeModel.ICodeElement)">
            <summary>
            Evaluate the total time to develop <paramref name="codeElement" /> based on
            <paramref name="codeElement" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" />, 
            by applying a linear coefficent inferred from
            <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode" /> and 
            <i>this</i>.<see cref="P:NDepend.TechnicalDebt.IDebtFormatter.DebtSettings" />.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" />.
            </summary>
            <remarks>This method returns <i>null</i> if <paramref name="codeElement" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.GetNbLinesOfCode_GuaranteedIfPDBFound(NDepend.CodeModel.ICodeElement)" /> returns <i>null</i>.</remarks>
            <param name="codeElement">The code element on which to infer time-to-develop.</param>
        </member>
        <member name="T:NDepend.TechnicalDebt.DebtSettings">
            <summary>
            This class contains all settings needed to present a <see cref="T:NDepend.TechnicalDebt.Debt" /> value to the user. 
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.DebtSettings.Clone">
            <summary>
            Create a new <see cref="T:NDepend.TechnicalDebt.DebtSettings" /> objects, with all settings values cloned from this.
            </summary>
        </member>
        <member name="M:NDepend.TechnicalDebt.DebtSettings.Equals(NDepend.TechnicalDebt.DebtSettings)">
            <summary>
            Returns <i>true</i> if all settings of <paramref name="other" /> debt settings, are equals to this settings.
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.DebtFactor">
            <summary>
            A factor that multiplies <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="P:NDepend.TechnicalDebt.Debt.Value" /> of all issues.
            </summary>
            <remarks>
            The default value is 1.0.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestFactor">
            <summary>
            A factor that multiplies <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="P:NDepend.TechnicalDebt.AnnualInterest.Value" /> of all issues.
            </summary>
            <remarks>
            The default value is 1.0.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.DebtDefault">
            <summary>
            The default <see cref="T:NDepend.TechnicalDebt.Debt" />.<see cref="P:NDepend.TechnicalDebt.Debt.Value" /> for issues for which <see cref="T:NDepend.TechnicalDebt.Debt" /> is not defined.
            </summary>
            <remarks>
            The default value is zero.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestDefault">
            <summary>
            The default <see cref="T:NDepend.TechnicalDebt.AnnualInterest" />.<see cref="P:NDepend.TechnicalDebt.AnnualInterest.Value" /> for issues for which <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> is not defined.
            </summary>
            <remarks>
            The default value is zero.
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.DEFAULT_COST_MIN">
            <summary>
            The minimum value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtDefault" /> and <see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestDefault" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.DEFAULT_COST_MAX">
            <summary>
            The maximum value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtDefault" /> and <see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestDefault" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.DEFAULT_COST_DEFAULT">
            <summary>
            The default value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.DebtDefault" /> and <see cref="P:NDepend.TechnicalDebt.DebtSettings.AnnualInterestDefault" />.
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.DebtStringFormat">
            <summary>
            The debt string format used by <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToString(System.TimeSpan)" /> method.
            </summary>
            <remarks>
            The default value is <see cref="T:NDepend.TechnicalDebt.DebtStringFormat" />. <see cref="F:NDepend.TechnicalDebt.DebtStringFormat.TAG_MAN_DAY_DETAILLED" />.
            </remarks>
            <seealso cref="T:NDepend.TechnicalDebt.DebtStringFormat" />
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour">
            <summary>
            Gets or sets the average cost of a man-hour of developement, expressed in <see cref="P:NDepend.TechnicalDebt.DebtSettings.Currency" />.
            </summary>
            <remarks>The default value is 50.</remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Currency">
            <summary>
            Gets or sets the currency in which, <see cref="P:NDepend.TechnicalDebt.DebtSettings.MoneyPerManHour" /> is expressed.
            </summary>
            <remarks>The default value is "USD".</remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.CurrencyLocation">
            <summary>
            Gets or sets the currency location, before or after, the figure.
            </summary>
            <remarks>The default value is <see cref="T:NDepend.Helpers.BeforeAfter" />.<see cref="F:NDepend.Helpers.BeforeAfter.Before" />.</remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkDayPerYear">
            <summary>
            Gets or sets the number of worked day per developer per year. This value is used to format <see cref="T:NDepend.TechnicalDebt.Debt" /> and <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values in terms of man-years and man-months. 
            </summary>
            <remarks>
            The default value is 240, which means 4 full weeks off and 48 full weeks worked.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay">
            <summary>
            Gets or sets the number of worked hour per developer work day. This value is used to format <see cref="T:NDepend.TechnicalDebt.Debt" /> and <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> values in terms of man-days. 
            </summary>
            <remarks>
            The default value is 8. 
            A developer typically doesn't spend 8 hours per day coding (because of email, meeting, discussion...) but this is not relevant, since this setting is used to format the <b>Debt</b> values in terms of man-days.<br />
            This cost necessarily includes side-costs like email or meeting costs, that represent an incompressible fraction of the productive time.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.A2B_RatingThreshold">
            <summary>
            Returns the percentage of technical debt under which, a code element gets the A rating.
            </summary>
            <remarks>
            The default value is 5%.
            A2B is the only threshold that can be equals to 0.0. 
            In such case, it means that any cost-fix leads to a rating B or worst. 
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.B2C_RatingThreshold">
            <summary>
            Returns the percentage of technical debt under which, a code element gets the B rating.
            </summary>
            <remarks>The default value is 10%.</remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.C2D_RatingThreshold">
            <summary>
            Returns the percentage of technical debt under which, a code element gets the C rating.
            </summary>
            <remarks>The default value is 20%.</remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.D2E_RatingThreshold">
            <summary>
            Returns the percentage of technical debt under which, a code element gets the D rating. Any percentage of technical debt value higher than this value will get the E rating.
            </summary>
            <remarks>The default value is 50%.</remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.DebtSettings.SetRatingThresholds(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Set the various thresholds used to infer the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> character value in the range of 'A' 'B' 'C' 'D' 'E', from the <b>Debt Ratio</b> of a code element.<br />
            </summary>
            <remarks>
            The <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> method returns a character in the range 'A' 'B' 'C' 'D' 'E'.<br />
            This rating value is obtained from the ratio of technical debt of the code element, and the various thresholds assigned by this method.
            </remarks>
            <param name="a2b">The A to B rating threshold of technical debt, used to infer the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> character value, from the percentage of technical debt of a code element.</param>
            <param name="b2c">The B to C rating threshold of technical debt, used to infer the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> character value, from the percentage of technical debt of a code element.</param>
            <param name="c2d">The C to D rating threshold of technical debt, used to infer the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> character value, from the percentage of technical debt of a code element.</param>
            <param name="d2e">The D to E rating threshold of technical debt, used to infer the <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRating(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" /> character value, from the percentage of technical debt of a code element.</param>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode">
            <summary>
            Gets or sets the estimated number of man-days to develop 1.000 logical lines of code, as defined by <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />.
            </summary>
            <remarks>
            The <b>debt ratio</b> value of one or several issues on a code element,
            is obtained by this formula: 100 * <i>estimated Debt of the issues</i> / <i>estimated effort to develop the code element</i>.<br />
            The <i>estimated Debt of the issues</i> is the <see cref="T:NDepend.TechnicalDebt.Debt" /> value.<br />
            The <i>estimated effort to develop the code element</i> is obtained from this <b>EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode</b> value,
            and from the code element number of <i>logical</i> lines of code. <br />
            The value of this setting is just an estimation, in the short-term it is meaningless.<br />
            After a few man-years of development, this value is typically stable enough to rely on, for estimation purposes.<br />
            This estimation also needs to take account of the cost of writing unit-tests. 
            The default value is 18 man-days which means an average of 55 new logical lines of code, <i>100% covered by unit-tests</i>, written per day, per developer.<br />
            <br />
            Lines of code as expressed by <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is logical lines of code. 
            This metric doesn't depend on formatting nor commenting and is inferred from # sequences points (gathered from PDB files).<br />
            </remarks>
            <seealso cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToDebtRatio(NDepend.TechnicalDebt.Debt,NDepend.CodeModel.ICodeElement)" />
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.EstimatedEffortToDevelopOneLogicalLineOfCode">
            <summary>
            Gets the estimated time to develop one logical line of code.
            </summary>
            <remarks>
            This property has no setter because the result is obtained from the formula: <br />
            (<i>this</i>.<see cref="P:NDepend.TechnicalDebt.DebtSettings.EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode" /> *
             <i>this</i>.<see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> / 1000).<see cref="M:NDepend.Helpers.ExtensionMethodsTimeSpan.ToHours(System.Double)" />.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value below (or equals) the returned threshold has a <see cref="F:NDepend.TechnicalDebt.Severity.Critical" /> severity, 
            and above the returned threshold, a <see cref="F:NDepend.TechnicalDebt.Severity.Blocker" /> severity.
            </summary>
            <remarks>
            The default value for this threshold is 10 man-hour.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.High2CriticalSeverityThreshold">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value below (or equals) the returned threshold has a <see cref="F:NDepend.TechnicalDebt.Severity.High" /> severity, 
            and above the returned threshold, a <see cref="F:NDepend.TechnicalDebt.Severity.Critical" /> severity.
            </summary>
            <remarks>
            The default value for this threshold is 2 man-hour.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Medium2HighSeverityThreshold">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value below (or equals) the returned threshold has a <see cref="F:NDepend.TechnicalDebt.Severity.Medium" /> severity, 
            and above the returned threshold, a <see cref="F:NDepend.TechnicalDebt.Severity.High" /> severity.
            </summary>
            <remarks>
            The default value for this threshold is 20 man-minute.
            </remarks>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold">
            <summary>
            A <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> value below (or equals) the returned threshold has a <see cref="F:NDepend.TechnicalDebt.Severity.Low" /> severity, 
            and above the returned threshold, a <see cref="F:NDepend.TechnicalDebt.Severity.Medium" /> severity.
            </summary>
            <remarks>
            The default value for this threshold is 2 man-minute.
            </remarks>
        </member>
        <member name="M:NDepend.TechnicalDebt.DebtSettings.SetSeverityThresholds(System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Set the various thresholds used to infer the <see cref="T:NDepend.TechnicalDebt.Severity" /> of the <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> an issue expressed in man-time per year.
            </summary>
            <remarks>
            The <see cref="T:NDepend.TechnicalDebt.IDebtFormatter" />.<see cref="M:NDepend.TechnicalDebt.IDebtFormatter.ToSeverity(NDepend.TechnicalDebt.AnnualInterest)" /> method is used to get the <see cref="T:NDepend.TechnicalDebt.Severity" /> of the <see cref="T:NDepend.TechnicalDebt.AnnualInterest" /> an issue.<br />
            </remarks>
            <param name="low2Medium">The value of <see cref="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold" />.</param>
            <param name="medium2High">The value of <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> to obtain <see cref="P:NDepend.TechnicalDebt.DebtSettings.Medium2HighSeverityThreshold" />.</param>
            <param name="high2Critical">The value of <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> to obtain <see cref="P:NDepend.TechnicalDebt.DebtSettings.High2CriticalSeverityThreshold" />.</param>
            <param name="critical2Blocker">The value of <see cref="P:NDepend.TechnicalDebt.DebtSettings.NumberOfWorkHourPerDay" /> to obtain <see cref="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold" />.</param>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.SEVERITY_THRESHOLD_MIN">
            <summary>
            The minimum value for a severity threshold.
            </summary>
            <remarks>
            Only <see cref="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold" /> can be equals to zero.
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.SEVERITY_THRESHOLD_MAX">
            <summary>
            The maximum value for a severity threshold.
            </summary>
            <remarks>
            Only <see cref="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold" /> can be equals to this maximum.
            </remarks>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.LOW2MEDIUM_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            The default value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.Low2MediumSeverityThreshold" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.MEDIUM2HIGH_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            The default value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.Medium2HighSeverityThreshold" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.HIGH2CRITICAL_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            The default value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.High2CriticalSeverityThreshold" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.CRITICAL2BLOCKER_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            The default value for <see cref="P:NDepend.TechnicalDebt.DebtSettings.Critical2Blocker_SeverityThreshold" />.
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.INFO2MINOR_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            Use INFO2MINOR_SEVERITY_THRESHOLD_DEFAULT instead
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.MINOR2MAJOR_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            Use MEDIUM2HIGH_SEVERITY_THRESHOLD_DEFAULT instead
            </summary>
        </member>
        <member name="F:NDepend.TechnicalDebt.DebtSettings.MAJOR2CRITICAL_SEVERITY_THRESHOLD_DEFAULT">
            <summary>
            Use HIGH2CRITICAL_SEVERITY_THRESHOLD_DEFAULT instead
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Major2Critical_SeverityThreshold">
            <summary>
            Use High2CriticalSeverityThreshold instead
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Minor2Major_SeverityThreshold">
            <summary>
            Use Medium2HighSeverityThreshold instead
            </summary>
        </member>
        <member name="P:NDepend.TechnicalDebt.DebtSettings.Info2Minor_SeverityThreshold">
            <summary>
            Use Low2MediumSeverityThreshold instead
            </summary>
        </member>
        <member name="T:NDepend.Path.AbsolutePathKind">
            <summary>
            Defines the kind of an absolute path.
            </summary>
        </member>
        <member name="F:NDepend.Path.AbsolutePathKind.DriveLetter">
            <summary>
            Represents a Windows absolute path prefixed with a drive letter like "C:\".
            </summary>
            <remarks>
            DriveLetter paths are never considered as existing when running on a Linux or OSX system.
            </remarks>
        </member>
        <member name="F:NDepend.Path.AbsolutePathKind.UNC">
            <summary>
            Represents a Windows UNC absolute path with a syntax like "\\server\share\path".
            </summary>
            <remarks>
            Notice the related properties <see cref="T:NDepend.Path.IAbsolutePath" />.<see cref="P:NDepend.Path.IAbsolutePath.UNCServer" /> and <see cref="T:NDepend.Path.IAbsolutePath" />.<see cref="P:NDepend.Path.IAbsolutePath.UNCShare" />.
            UNC paths are never considered as existing when running on a Linux or OSX system.
            </remarks>
        </member>
        <member name="F:NDepend.Path.AbsolutePathKind.LinuxStyle">
            <summary>
            Represents a Linux style path starting with the char '/'.
            </summary>
            <remarks>
             "/" is considered as a valid Linux style root path.
             Linux style paths are never considered as existing when running on a Windows system.
            </remarks>
        </member>
        <member name="T:NDepend.Path.EnvVarPathResolvingStatus">
            <summary>
            Defines the result of the <see cref="T:NDepend.Path.IEnvVarPath" />.<see cref="M:NDepend.Path.IEnvVarPath.TryResolve(NDepend.Path.IAbsolutePath@)" /> method.
            </summary>
        </member>
        <member name="F:NDepend.Path.EnvVarPathResolvingStatus.Success">
            <summary> 
            The environment variable has been resolved, and the resulting path is a valid absolute path. 
            </summary>
        </member>
        <member name="F:NDepend.Path.EnvVarPathResolvingStatus.ErrorUnresolvedEnvVar">
            <summary> 
            The environment variable cannot be resolved. 
            </summary>
        </member>
        <member name="F:NDepend.Path.EnvVarPathResolvingStatus.ErrorEnvVarResolvedButCannotConvertToAbsolutePath">
            <summary> 
            The environment variable has been resolved but the resulting path is not a valid absolute path. 
            </summary>
        </member>
        <member name="T:NDepend.Path.ExtensionMethodsOnPathsCollection">
            <summary>
            Extension methods helpers on collection of paths.
            </summary>
        </member>
        <member name="M:NDepend.Path.ExtensionMethodsOnPathsCollection.ContainsSamePathsThan``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            Determine if this collection1 and collection2 contain the same set of paths.
            </summary>
            <remarks>
            Collections can contain null paths.
            </remarks>
            <typeparam name="T">The path type, any interface type implementing IPath</typeparam>
            <param name="collection1">This collection of paths.</param>
            <param name="collection2">The other collection of paths.</param>
            <returns>
            true if collection2 contains the same set of path than this collection1.
            true also, if this collection1 and collection2 are both null.
            true also, if this collection1 and collection2 are both empty.
            </returns>
        </member>
        <member name="M:NDepend.Path.ExtensionMethodsOnPathsCollection.ContainsPath``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Returns <i>true</i> if <paramref name="seq" /> contains <paramref name="path" />.
            </summary>
            <remarks>
            The method IPath.Equals(), overridden from System.Object, is used to test path equality.
            </remarks>
            <param name="seq">The sequence to search in.</param>
            <param name="path">The path to search for.</param>
        </member>
        <member name="M:NDepend.Path.ExtensionMethodsOnPathsCollection.TryGetCommonRootDirectory(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteDirectoryPath},NDepend.Path.IAbsoluteDirectoryPath@)">
            <summary>
            Find the common root directory of all directories of this collection.
            </summary>
            <remarks>
            A return value indicates whether a common root directory has been found.
            A common root directory cannot be found if at least two directories path on two different drives are in this collection.
            If the collection contains at least one null path, a common root directory cannot be found.
            </remarks>
            <param name="collection">This collection of directories absolute paths.</param>
            <param name="commonRootDirectory">The common root directory if it has been found.</param>
            <returns>
            true if a common root directory has been found, else returns false.
            </returns>
        </member>
        <member name="T:NDepend.Path.IAbsoluteDirectoryPath">
            <summary>
            Represents an absolute path to a directory on file system.
            </summary>
            <remarks>
            The path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be called to create a new IAbsoluteDirectoryPath object from a string.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IAbsoluteDirectoryPath.DirectoryInfo">
            <summary>
            Returns a DirectoryInfo object representing this absolute directory path.
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
            <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
        </member>
        <member name="P:NDepend.Path.IAbsoluteDirectoryPath.ChildrenFilesPath">
            <summary>
            Returns a read-only list of file paths absolute matching files contained in this directory.
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
            <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
        </member>
        <member name="P:NDepend.Path.IAbsoluteDirectoryPath.ChildrenDirectoriesPath">
            <summary>
            Returns a read-only list of directory paths absolute matching directories contained in this directory.
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
            <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
        </member>
        <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new absolute file path representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
            <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The brother file name.</param>
            <exception cref="T:System.InvalidOperationException">This absolute directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
            <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The brother directory name.</param>
            <exception cref="T:System.InvalidOperationException">This absolute directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildFileWithName(System.String)">
            <summary>
            Returns a new absolute file path representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
            <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The child file name.</param>
        </member>
        <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildDirectoryWithName(System.String)">
            <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
            <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The child directory name.</param>
            <exception cref="T:System.InvalidOperationException">This absolute directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Compute this directory as relative from <paramref name="pivotDirectory" />. If this directory is "C:\Dir1\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is "..\Dir2".
            </summary>
            <remarks>
            This directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
            <exception cref="T:System.ArgumentException"><paramref name="pivotDirectory" /> is not on the same drive as this directory's drive.</exception>
            <returns>A new relative directory path representing this directory relative to <paramref name="pivotDirectory" />.</returns>
        </member>
        <member name="T:NDepend.Path.IAbsoluteFilePath">
            <summary>
            Represents an absolute path to a file on file system.
            </summary>
            <remarks>
            The path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be called to create a new IAbsoluteFilePath object from a string.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IAbsoluteFilePath.FileInfo">
            <summary>
            Returns a FileInfo object corresponding to this absolute file path.
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
            <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
        </member>
        <member name="M:NDepend.Path.IAbsoluteFilePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Compute this file as relative from <paramref name="pivotDirectory" />. If this file is "C:\Dir1\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file path is "..\Dir2\File.txt".
            </summary>
            <remarks>
            This file nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
            <exception cref="T:System.ArgumentException"><paramref name="pivotDirectory" /> is not on the same drive as this file's drive.</exception>
            <returns>A new relative file path representing this file relative to <paramref name="pivotDirectory" />.</returns>
        </member>
        <member name="M:NDepend.Path.IAbsoluteFilePath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new absolute file path refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
            <remarks>This file nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The brother file name</param>
        </member>
        <member name="M:NDepend.Path.IAbsoluteFilePath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
            <remarks>This file nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The brother directory name.</param>
        </member>
        <member name="M:NDepend.Path.IAbsoluteFilePath.UpdateExtension(System.String)">
            <summary>
            Returns a new absolute file path representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
            <remarks>
            The returned file nor this file need to exist for this operation to complete properly.
            </remarks>
            <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
        </member>
        <member name="T:NDepend.Path.IAbsolutePath">
            <summary>
            Represents an absolute path to a file or directory on file system.
            </summary>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.Kind">
            <summary>
            Gets the <see cref="T:NDepend.Path.AbsolutePathKind" /> value for this path.
            </summary>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.DriveLetter">
            <summary>
            Returns an <see cref="T:NDepend.Path.IDriveLetter" /> object representing the drive of this absolute path.
            </summary>
            <exception cref="T:System.InvalidOperationException"> is thrown if this absolute path <see cref="P:NDepend.Path.IAbsolutePath.Kind" /> is different than <see cref="T:NDepend.Path.AbsolutePathKind" />.<see cref="F:NDepend.Path.AbsolutePathKind.DriveLetter" />.</exception>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.UNCServer">
            <summary>
            Returns the server string if this is a UNC path with syntax '\\server\share\path'.
            </summary>
            <exception cref="T:System.InvalidOperationException"> is thrown if this absolute path <see cref="P:NDepend.Path.IAbsolutePath.Kind" /> is different than <see cref="T:NDepend.Path.AbsolutePathKind" />.<see cref="F:NDepend.Path.AbsolutePathKind.UNC" />.</exception>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.UNCShare">
            <summary>
            Returns the share string if this is a UNC path with syntax '\\server\share\path'.
            </summary>
            <exception cref="T:System.InvalidOperationException"> is thrown if this absolute path <see cref="P:NDepend.Path.IAbsolutePath.Kind" /> is different than <see cref="T:NDepend.Path.AbsolutePathKind" />.<see cref="F:NDepend.Path.AbsolutePathKind.UNC" />.</exception>
        </member>
        <member name="M:NDepend.Path.IAbsolutePath.OnSameVolumeThan(NDepend.Path.IAbsolutePath)">
            <summary>
            Gets a value indicating whether this absolute path is on the same volume as <paramref name="pathAbsoluteOther" />.
            </summary>
            <param name="pathAbsoluteOther">The other absolute path.</param>
            <remarks>Being on the same volume means being on the same local/network/shared drive.</remarks>
            <returns>true if this absolute path is on the same drive as <paramref name="pathAbsoluteOther" />, else returns false.</returns>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.IsSupportedByTheCurrentOperatingSystem">
            <summary>
            Gets a value indicating if the current absolute path is supported by the current operating system.
            </summary>
            <remarks>
            When running on Windows, returns <i>true</i> if <see cref="P:NDepend.Path.IAbsolutePath.Kind" /> is <see cref="F:NDepend.Path.AbsolutePathKind.DriveLetter" /> or <see cref="F:NDepend.Path.AbsolutePathKind.UNC" />.<br />
            When running on Linux or MacOS returns <i>true</i> if <see cref="P:NDepend.Path.IAbsolutePath.Kind" /> is <see cref="F:NDepend.Path.AbsolutePathKind.LinuxStyle" />.<br />
            Else returns <i>false</i>.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.Exists">
            <summary>
            Gets a value indicating whether the file or directory represented by this absolute path exists.
            </summary>
            <returns>
            true if the file or directory represented by this absolute path exists.
            </returns>
        </member>
        <member name="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Returns a new relative path representing this relative path to <paramref name="pivotDirectory" />.
            </summary>
            <remarks>
            If this path is "C:\Dir1\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is a IRelativeFilePath "..\Dir2\File.txt".
            If this path is "C:\Dir1\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is a IRelativeDirectoryPath "..\Dir2".
            This method is hidden in <see cref="T:NDepend.Path.IAbsoluteFilePath" /> and <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> to get a typed result.
            This file or directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
            <exception cref="T:System.ArgumentException"><paramref name="pivotDirectory" /> is not on the same drive as this file's drive.</exception>
        </member>
        <member name="M:NDepend.Path.IAbsolutePath.CanGetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Gets a value indicating whether a relative path representing this path can be computed from <paramref name="pivotDirectory" />.
            </summary>
            <remarks> 
            A relative path cannot be computed if <paramref name="pivotDirectory" /> is not on the same drive as this absolute path's drive.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
            <returns>true if a relative path representing this path can be computed from <paramref name="pivotDirectory" />, else returns false.</returns>
        </member>
        <member name="M:NDepend.Path.IAbsolutePath.CanGetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath,System.String@)">
            <summary>
            Gets a value indicating whether a relative path representing this path can be computed from <paramref name="pivotDirectory" />.
            </summary>
            <remarks> 
            A relative path cannot be computed if <paramref name="pivotDirectory" /> is not on the same drive as this absolute path's drive.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
            <param name="failureReason">If this method return <i>false</i>, it contains the plain-english description of the cause of this failure.</param>
            <returns>true if a relative path representing this path can be computed from <paramref name="pivotDirectory" />, else returns false.</returns>
        </member>
        <member name="P:NDepend.Path.IAbsolutePath.ParentDirectoryPath">
            <summary>
            Returns a new absolute directory path representing the parent directory of this absolute path.
            </summary>
            <remarks>
            This path nor its parent directory path need to exist for this operation to complete properly.
            </remarks>
            <exception cref="T:System.InvalidOperationException">This absolute path has no parent directory.</exception>
        </member>
        <member name="T:NDepend.Path.IDirectoryPath">
            <summary>
            Represents a path to a directory on file system.
            </summary>
            <remarks>
            The path can be relative or absolute.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be called to create a new IDirectoryPath object from a string.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IDirectoryPath.DirectoryName">
            <summary>
            Gets a string representing the directory name.
            </summary>
            <remarks>
            If the directory is a root volume, like "C:", returns an empty string.
            </remarks>
            <returns>
            The directory name.
            </returns>
        </member>
        <member name="M:NDepend.Path.IDirectoryPath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
            <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The brother file name.</param>
            <exception cref="T:System.InvalidOperationException">This directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IDirectoryPath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
            <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The brother directory name.</param>
            <exception cref="T:System.InvalidOperationException">This directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IDirectoryPath.GetChildFileWithName(System.String)">
            <summary>
            Returns a new file path representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
            <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The child file name.</param>
        </member>
        <member name="M:NDepend.Path.IDirectoryPath.GetChildDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
            <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The child directory name.</param>
            <exception cref="T:System.InvalidOperationException">This directory path doesn't have a parent directory.</exception>
        </member>
        <member name="T:NDepend.Path.IDriveLetter">
            <summary>
            Represents a drive on file system.
            </summary>
        </member>
        <member name="P:NDepend.Path.IDriveLetter.Letter">
            <summary>
            Returns the letter character of this drive.
            </summary>
            <remarks>
            The letter returned can be upper or lower case.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IDriveLetter.DriveInfo">
            <summary>
            Returns a DriveInfo object representing this drive.
            </summary>
            <exception cref="T:System.IO.DriveNotFoundException">This drive doesn't refer to an existing drive.</exception>
            <seealso cref="P:NDepend.Path.IAbsoluteDirectoryPath.DirectoryInfo" />
            <seealso cref="P:NDepend.Path.IAbsoluteFilePath.FileInfo" />
        </member>
        <member name="M:NDepend.Path.IDriveLetter.NotEquals(System.Object)">
            <summary>Returns true if obj is null, is not an IDrive, or is an IDrive representing a different drive than this drive (case insensitive).</summary>
        </member>
        <member name="T:NDepend.Path.IEnvVarDirectoryPath">
            <summary>
            Represents a directory path on file system, prefixed with an environment variable.
            </summary>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.TryResolve(NDepend.Path.IAbsoluteDirectoryPath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.EnvVarPathResolvingStatus" />.<see cref="F:NDepend.Path.EnvVarPathResolvingStatus.Success" /> if this directory path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute directory path.
            </summary>
            <param name="pathDirectoryResolved">It is the absolute directory path resolved returned by this method.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.TryResolve(NDepend.Path.IAbsoluteDirectoryPath@,System.String@)">
            <summary>
            Returns <see cref="T:NDepend.Path.EnvVarPathResolvingStatus" />.<see cref="F:NDepend.Path.EnvVarPathResolvingStatus.Success" /> if this directory path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute directory path.
            </summary>
            <param name="pathDirectoryResolved">It is the absolute directory path resolved returned by this method.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path prefixed with an environment variable, representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
            <param name="fileName">The brother file name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path prefixed with an environment variable, representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
            <param name="directoryName">The brother directory name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.GetChildFileWithName(System.String)">
            <summary>
            Returns a new file path prefixed with an environment variable, representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
            <param name="fileName">The child file name.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarDirectoryPath.GetChildDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path prefixed with an environment variable, representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
            <param name="directoryName">The child directory name.</param>
        </member>
        <member name="T:NDepend.Path.IEnvVarFilePath">
            <summary>
            Represents a file path on file system, prefixed with an environment variable.
            </summary>
        </member>
        <member name="M:NDepend.Path.IEnvVarFilePath.TryResolve(NDepend.Path.IAbsoluteFilePath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.EnvVarPathResolvingStatus" />.<see cref="F:NDepend.Path.EnvVarPathResolvingStatus.Success" /> if this file path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="pathFileResolved">It is the absolute file path resolved returned by this method.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarFilePath.TryResolve(NDepend.Path.IAbsoluteFilePath@,System.String@)">
            <summary>
            Returns <see cref="T:NDepend.Path.EnvVarPathResolvingStatus" />.<see cref="F:NDepend.Path.EnvVarPathResolvingStatus.Success" /> if this file path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="pathFileResolved">It is the absolute file path resolved returned by this method.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarFilePath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path prefixed with an environment variable, refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
            <param name="fileName">The brother file name</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarFilePath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path prefixed with an environment variable, representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
            <param name="directoryName">The brother directory name.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarFilePath.UpdateExtension(System.String)">
            <summary>
            Returns a new file path prefixed with an environment variable, representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
            <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
        </member>
        <member name="T:NDepend.Path.IEnvVarPath">
            <summary>
            Represents a path on file system, prefixed with an environment variable.
            </summary>
        </member>
        <member name="M:NDepend.Path.IEnvVarPath.TryResolve(NDepend.Path.IAbsolutePath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.EnvVarPathResolvingStatus" />.<see cref="F:NDepend.Path.EnvVarPathResolvingStatus.Success" /> if this path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute path.
            </summary>
            <param name="pathResolved">It is the absolute path resolved returned by this method.</param>
        </member>
        <member name="M:NDepend.Path.IEnvVarPath.TryResolve(NDepend.Path.IAbsolutePath@,System.String@)">
            <summary>
            Returns <i>true</i> if this path is prefixed with an environment variable that can be resolved into a drive letter or a UNC absolute path.
            </summary>
            <param name="pathResolved">It is the absolute path resolved returned by this method.</param>
            <param name="failureReason">If <i>false</i> is returned, <paramref name="failureReason" /> contains the plain english description of the failure.</param>
        </member>
        <member name="P:NDepend.Path.IEnvVarPath.EnvVar">
            <summary>
            Gets the environment variable string, prefixed and suffixed with two percents char.
            </summary>
        </member>
        <member name="P:NDepend.Path.IEnvVarPath.ParentDirectoryPath">
            <summary>
            Returns a new directory path prefixed with an environment variable, representing the parent directory of this path prefixed with an environment variable.
            </summary>
            <exception cref="T:System.InvalidOperationException">This path prefixed with an environment variable has no parent directory.</exception>
        </member>
        <member name="T:NDepend.Path.IFilePath">
            <summary>
            Represents a path to a file on file system.
            </summary>
            <remarks>
            The path can be relative or absolute.
            In case of an absolute IFilePath, the path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be called to create a new IFilePath object from a string.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IFilePath.FileName">
            <summary>
            Gets a string representing the file name with its extension if any.
            </summary>
            <returns>
            Returns the file name with its extension if any.
            </returns>
        </member>
        <member name="P:NDepend.Path.IFilePath.FileNameWithoutExtension">
            <summary>
            Gets a string representing the file name without its extension if any.
            </summary>
            <returns>
            Returns the file name without its extension if any.
            </returns>
        </member>
        <member name="P:NDepend.Path.IFilePath.FileExtension">
            <summary>
            Gets a string representing the file name extension.
            </summary>
            <returns>
            Returns the file name extension if any, else returns an empty string.
            </returns>
        </member>
        <member name="M:NDepend.Path.IFilePath.HasExtension(System.String)">
            <summary>
            Gets a value indicating whether this file name has the extension, <paramref name="extension" />.
            </summary>
            <param name="extension">The file extension. It must begin with a dot followed by one or many characters.</param>
            <returns>true if this file name has the extension, <paramref name="extension" />.</returns>
        </member>
        <member name="M:NDepend.Path.IFilePath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
            <remarks>This file nor the returned file need to exist for this operation to complete properly.</remarks>
            <param name="fileName">The brother file name</param>
        </member>
        <member name="M:NDepend.Path.IFilePath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
            <remarks>This file nor the returned directory need to exist for this operation to complete properly.</remarks>
            <param name="directoryName">The brother directory name.</param>
        </member>
        <member name="M:NDepend.Path.IFilePath.UpdateExtension(System.String)">
            <summary>
            Returns a new file path representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
            <remarks>
            The returned file nor this file need to exist for this operation to complete properly.
            </remarks>
            <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
        </member>
        <member name="T:NDepend.Path.IPath">
            <summary>
            Represents a path, absolute or relative, to a file or to a directory.
            </summary>
            <remarks>
            Equals(), ToString() and GetHashCode() operations are overridden from System.Object and are supported by all paths objects.
            Equals() and GetHashCode() are string case insensitive.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IPath.IsAbsolutePath">
            <summary>Gets a value indicating whether this path is an absolute path.</summary>
            <remarks>
            An absolute path can be down-casted to <see cref="T:NDepend.Path.IAbsolutePath" />.
            A <see cref="T:NDepend.Path.IAbsolutePath" /> can be down-casted to a <see cref="T:NDepend.Path.IAbsoluteFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            </remarks>
            <returns><i>true</i> if this path is an absolute path, else returns false.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.IsRelativePath">
            <summary>Gets a value indicating whether this path is a relative path.</summary>
            <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IRelativePath" />.
            A <see cref="T:NDepend.Path.IRelativePath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
            <returns><i>true</i> if this path is a relative path, else returns false.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.IsEnvVarPath">
            <summary>Gets a value indicating whether this path is prefixed with an environment variable.</summary>
            <remarks>
            A path prefixed with an environment variable can be down-casted to <see cref="T:NDepend.Path.IEnvVarPath" />.
            A <see cref="T:NDepend.Path.IEnvVarPath" /> can be down-casted to a <see cref="T:NDepend.Path.IEnvVarFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IEnvVarDirectoryPath" />.
            </remarks>
            <returns><i>true</i> if this path is prefixed with an environment variable, else returns <i>false</i>.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.IsVariablePath">
            <summary>Gets a value indicating whether this path contains variable(s).</summary>
            <remarks>
            A path contains variable(s) can be down-casted to <see cref="T:NDepend.Path.IVariablePath" />.
            A <see cref="T:NDepend.Path.IVariablePath" /> can be down-casted to a <see cref="T:NDepend.Path.IVariableFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IVariableDirectoryPath" />.
            </remarks>
            <returns><i>true</i> if this path contains variable(s), else returns <i>false</i>.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.IsDirectoryPath">
            <summary>Gets a value indicating whether this path is a directory path.</summary>
            <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IDirectoryPath" />.
            A <see cref="T:NDepend.Path.IDirectoryPath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeDirectoryPath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            </remarks>
            <returns><i>true</i> if this path is a directory path, else returns <i>false</i>.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.IsFilePath">
            <summary>Gets a value indicating whether this path is a file path.</summary>
            <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IFilePath" />.
            A <see cref="T:NDepend.Path.IFilePath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            </remarks>
            <returns><i>true</i> if this path is a file path, else returns <i>false</i>.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.PathMode">
            <summary>
            Gets a value indicating this path mode as defined in the enumeration <see cref="P:NDepend.Path.IPath.PathMode" />.
            </summary>
        </member>
        <member name="P:NDepend.Path.IPath.ParentDirectoryPath">
            <summary>Returns the parent directory path.</summary>
            <exception cref="T:System.InvalidOperationException">
            This path doesn't have a parent directory path.
            Root directories representing a drive, like C: or D: don't have a parent directory path.
            Relative path like ".\" or "..\" don't have a parent directory path.
            Notice that a file path necessarily has a parent directory path.
            </exception> 
        </member>
        <member name="M:NDepend.Path.IPath.IsChildOf(NDepend.Path.IDirectoryPath)">
            <summary>
            Gets a value indicating whether this path is a child path of <paramref name="parentDirectory" />.
            </summary>
            <remarks>This path resource nor <paramref name="parentDirectory" /> need to exist for this operation to complete properly.</remarks>
            <param name="parentDirectory">The parent directory.</param>
            <returns>true of this directory is a child directory of <paramref name="parentDirectory" />, else false.</returns>
        </member>
        <member name="P:NDepend.Path.IPath.HasParentDirectory">
            <summary>Gets a value indicating whether this path has a parent directory path</summary>
            <remarks>
            Root directories representing a drive, like C: or D: don't have a parent directory path.
            Relative path like ".\" or "..\" don't have a parent directory path.
            Notice that a file path necessarily has a parent directory path.
            </remarks>
            <returns>true if this path has a parent directory path, else returns false.</returns>
        </member>
        <member name="M:NDepend.Path.IPath.NotEquals(System.Object)">
            <summary>Returns true if obj is null, is not an IPath, or is an IPath representing a different path than this path (case insensitive).</summary>
            <remarks>
            This method is the opposite of the IPath.Equals() method, overridden from System.Object.
            It can be used to make the negation in !Equals more obvious.
            </remarks>
        </member>
        <member name="T:NDepend.Path.IRelativeDirectoryPath">
            <summary>
            Represents a relative directory path.
            </summary>
            <remarks>
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be called to create a new IRelativeDirectoryPath object from a string.
            </remarks>
        </member>
        <member name="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new relative file path representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
            <param name="fileName">The brother file name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
            <param name="directoryName">The brother directory name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IRelativeDirectoryPath.GetChildFileWithName(System.String)">
            <summary>
            Returns a new relative file path representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
            <param name="fileName">The child file name.</param>
        </member>
        <member name="M:NDepend.Path.IRelativeDirectoryPath.GetChildDirectoryWithName(System.String)">
            <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
            <param name="directoryName">The child directory name.</param>
        </member>
        <member name="M:NDepend.Path.IRelativeDirectoryPath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Resolve this relative directory from <paramref name="pivotDirectory" />. If this directory is "..\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned absolute directory is "C:\Dir1\Dir2".
            </summary>
            <remarks>
            The returned directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
            <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative directory path is "..\..\Dir2".
            </exception>
            <returns>A new absolute directory path representing this relative directory resolved from <paramref name="pivotDirectory" />.</returns>
        </member>
        <member name="T:NDepend.Path.IRelativeFilePath">
            <summary>
            Represents a relative file path.
            </summary>
            <remarks>
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be called to create a new IRelativeFilePath object from a string.
            </remarks>
        </member>
        <member name="M:NDepend.Path.IRelativeFilePath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new relative file path refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
            <param name="fileName">The brother file name</param>
        </member>
        <member name="M:NDepend.Path.IRelativeFilePath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
            <param name="directoryName">The brother directory name.</param>
        </member>
        <member name="M:NDepend.Path.IRelativeFilePath.UpdateExtension(System.String)">
            <summary>
            Returns a new relative file path representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
            <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
        </member>
        <member name="M:NDepend.Path.IRelativeFilePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Resolve this relative file from <paramref name="pivotDirectory" />. If this file is "..\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned absolute file is "C:\Dir1\Dir2\File.txt".
            </summary>
            <remarks>
            The returned file nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
            <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative file path is "..\..\Dir2\File.txt".
            </exception>
            <returns>A new absolute file path representing this relative file resolved from <paramref name="pivotDirectory" />.</returns>
        </member>
        <member name="T:NDepend.Path.IRelativePath">
            <summary>
            Represents a relative path to a file or directory. 
            </summary>
        </member>
        <member name="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            A new absolute path representing this relative path resolved from <paramref name="pivotDirectory" />.
            </summary>
            <remarks>
            If this path is "..\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file is "C:\Dir1\Dir2\File.txt".
            If this path is "..\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file is "C:\Dir1\Dir2".
            This method is hidden in <see cref="T:NDepend.Path.IAbsoluteFilePath" /> and <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> to get a typed result.
            The returned file or directory path nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
            <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative path is "..\..\Dir2".
            </exception>
            <returns>A new absolute file path representing this relative file resolved from <paramref name="pivotDirectory" />.</returns>
        </member>
        <member name="M:NDepend.Path.IRelativePath.CanGetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Gets a value indicating whether this relative path can be resolved from <paramref name="pivotDirectory" />.
            </summary>
            <remarks>
            An absolute path cannot be resolved for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative path is "..\..\Dir2".
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
            <returns>true if this relative path can be resolved from <paramref name="pivotDirectory" />, else returns false.</returns>
        </member>
        <member name="M:NDepend.Path.IRelativePath.CanGetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath,System.String@)">
            <summary>
            Gets a value indicating whether this relative path can be resolved from <paramref name="pivotDirectory" />.
            </summary>
            <remarks>
            An absolute path cannot be resolved for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative path is "..\..\Dir2".
            </remarks>
            <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
            <param name="failureReason">If this method return <i>false</i>, it contains the plain-english description of the cause of this failure.</param>
            <returns>true if this relative path can be resolved from <paramref name="pivotDirectory" />, else returns false.</returns>
        </member>
        <member name="P:NDepend.Path.IRelativePath.ParentDirectoryPath">
            <summary>
            Returns a new relative directory path representing the parent directory of this relative path.
            </summary>
            <exception cref="T:System.InvalidOperationException">This relative path has no parent directory.</exception>
        </member>
        <member name="T:NDepend.Path.IVariableDirectoryPath">
            <summary>
            Represents a directory path on file system, prefixed with an environment variable.
            </summary>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteDirectoryPath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute directory path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathDirectoryResolved">It is the absolute directory path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteDirectoryPath@,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathDirectoryResolved">It is the absolute directory path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
            <param name="unresolvedVariables">This list contains one or several variables names unresolved, if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.ErrorUnresolvedVariable" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteDirectoryPath@,System.String@)">
            <summary>
            Returns <i>true</i> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute directory path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathDirectoryResolved">It is the absolute directory path resolved obtained if this method returns <i>true</i>.</param>
            <param name="failureReason">If <i>false</i> is returned, <paramref name="failureReason" /> contains the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path containing variables, representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
            <param name="fileName">The brother file name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path containing variables, representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
            <param name="directoryName">The brother directory name.</param>
            <exception cref="T:System.InvalidOperationException">This relative directory path doesn't have a parent directory.</exception>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.GetChildFileWithName(System.String)">
            <summary>
            Returns a new file path containing variables, representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
            <param name="fileName">The child file name.</param>
        </member>
        <member name="M:NDepend.Path.IVariableDirectoryPath.GetChildDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path containing variables, representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
            <param name="directoryName">The child directory name.</param>
        </member>
        <member name="T:NDepend.Path.IVariableFilePath">
            <summary>
            Represents a file path on file system, prefixed with an environment variable.
            </summary>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteFilePath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathFileResolved">It is the absolute file path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteFilePath@,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathFileResolved">It is the absolute file path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
            <param name="unresolvedVariables">This list contains one or several variables names unresolved, if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.ErrorUnresolvedVariable" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsoluteFilePath@,System.String@)">
            <summary>
            Returns <i>true</i> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute file path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathFileResolved">It is the absolute file path resolved obtained if this method returns <i>true</i>.</param>
            <param name="failureReason">If <i>false</i> is returned, <paramref name="failureReason" /> contains the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.GetBrotherFileWithName(System.String)">
            <summary>
            Returns a new file path containing variables, refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
            <param name="fileName">The brother file name</param>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.GetBrotherDirectoryWithName(System.String)">
            <summary>
            Returns a new directory path containing variables, representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
            <param name="directoryName">The brother directory name.</param>
        </member>
        <member name="M:NDepend.Path.IVariableFilePath.UpdateExtension(System.String)">
            <summary>
            Returns a new file path containing variables, representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
            <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
        </member>
        <member name="T:NDepend.Path.IVariablePath">
            <summary>
            Represents a path containing variable(s) defined with the syntax (case-insensitive) <i>$(VariableName)</i>. Such path must be prefixed with a variable and can then contain more variables.
            </summary>
        </member>
        <member name="M:NDepend.Path.IVariablePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsolutePath@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> cref="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathResolved">It is the absolute path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariablePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsolutePath@,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" /> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathResolved">It is the absolute path resolved obtained if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.Success" />.</param>
            <param name="unresolvedVariables">This list contains one or several variables names unresolved, if this method returns <see cref="T:NDepend.Path.VariablePathResolvingStatus" />.<see cref="F:NDepend.Path.VariablePathResolvingStatus.ErrorUnresolvedVariable" />.</param>
        </member>
        <member name="M:NDepend.Path.IVariablePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsolutePath@,System.String@)">
            <summary>
            Returns <i>true</i> if <see cref="P:NDepend.Path.IVariablePath.AllVariables" /> of this path can be resolved from <paramref name="variablesValues" /> and the path can be resolved into a drive letter or a UNC absolute path.
            </summary>
            <param name="variablesValues">It is the sequence of pairs <i>[variable name/variable value]</i> used to resolve the path.</param>
            <param name="pathResolved">It is the absolute path resolved obtained if this method returns <i>true</i>.</param>
            <param name="failureReason">If <i>false</i> is returned, <paramref name="failureReason" /> contains the plain english description of the failure.</param>
        </member>
        <member name="P:NDepend.Path.IVariablePath.PrefixVariable">
            <summary>
            Gets the prefix variable name of this path.
            </summary>
            <remarks>
            For example, for the path  <i>$(VariableName)\Dir</i> this property getter returns <i>"VariableName"</i>.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IVariablePath.AllVariables">
            <summary>
            Gets all variables contained in this path, ordered from first one (the prefix variable) to the last one.
            </summary>
            <remarks>
            For example, for the path  <i>$(Variable1Name)\$(Variable2Name)</i> this property getter returns <i>["Variable1Name","Variable2Name"]</i>.
            </remarks>
        </member>
        <member name="P:NDepend.Path.IVariablePath.ParentDirectoryPath">
            <summary>
            Returns a new path containing variables, representing the parent directory of this path containing variables.
            </summary>
            <exception cref="T:System.InvalidOperationException">This path containing variables has no parent directory.</exception>
        </member>
        <member name="T:NDepend.Path.PathHelpers">
            <summary>
            Contains extensions methods to obtain a path object from a string and to check that a string indeed represents a valid path.
            </summary>
        </member>
        <member name="P:NDepend.Path.PathHelpers.PathVariableBegin">
            <summary>
            Path variables are formatted this way $(VariableName). Hence this getter returns the string "$(".
            </summary>
        </member>
        <member name="P:NDepend.Path.PathHelpers.PathVariableEnd">
            <summary>
            Path variables are formatted this way $(VariableName). Hence this getter returns the string ")".
            </summary>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidPathVariableName(System.String)">
            <summary>
            Returns <i>true</i> if <paramref name="pathVariableName" /> contains only upper/lower case letters, digits and underscore and has less than 1024 characters. In such case <paramref name="pathVariableName" /> is a valid path variable name.
            </summary>
            <param name="pathVariableName">The string on which we test if it is a valid path variable name.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidPathVariableValue(System.String)">
            <summary>
            Returns <i>true</i> if <paramref name="pathVariableValue" /> has less than 1024 characters and has no character in <see cref="P:NDepend.Path.PathHelpers.ForbiddenCharInPath" />. In such case <paramref name="pathVariableValue" /> is a valid path variable name.
            </summary>
            <param name="pathVariableValue">The string on which we test if it is a valid path variable value.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToStringOrIfNullToEmptyString(NDepend.Path.IPath)">
            <summary>
            Returns <paramref name="path" />.ToString() is path is null, else returns the empty string. 
            </summary>
            <param name="path">The path reference.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsNotNullAndExists(NDepend.Path.IAbsolutePath)">
            <summary>
            Returns <i>true</i> if <paramref name="path" /> is not null, and <paramref name="path" />.<see cref="P:NDepend.Path.IAbsolutePath.Exists" /> equals <i>true</i>. 
            </summary>
            <param name="path">The path reference.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.EqualsNullSupported(NDepend.Path.IPath,NDepend.Path.IPath)">
            <summary>
            Returns <i>true</i> if <paramref name="path" /> and <paramref name="pathOther" /> are both <i>null</i>, or if <paramref name="path" />.Equals(<paramref name="pathOther" />). 
            </summary>
            <param name="path">The first path.</param>
            <param name="pathOther">The second path.</param>
        </member>
        <member name="P:NDepend.Path.PathHelpers.ForbiddenCharInPath">
            <summary>
            An array of char forbidden in string representing path.
            </summary>
            <remarks>
            Use this string.IndexOfAny(char[]) method to detect the presence of any of this char in a string.<br />
            The char ':' is not included in this array. The only proper position for this character in a path, is the second position, just after a letter.
            </remarks>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid absolute file path.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IRelativeFilePath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid relative file path.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToEnvVarFilePath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IEnvVarFilePath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidEnvVarFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid file path prefixed with an environment variable.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToVariableFilePath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IVariableFilePath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidVariableFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid file path that contains variables.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid absolute directory path.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IRelativeDirectoryPath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid relative directory path.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToEnvVarDirectoryPath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IEnvVarDirectoryPath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidEnvVarDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid directory path prefixed with an environment variable.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToVariableDirectoryPath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IVariableDirectoryPath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidVariableDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid directory path that contains variables.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IDirectoryPath" /> object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid relative or absolute directory path or a valid directory path prefixed with an environment variable.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.ToFilePath(System.String)">
            <summary>
            Returns a new <see cref="T:NDepend.Path.IFilePath" /> object object from this string.
            </summary>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathString" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathString" /> is empty or doesn't represents a valid relative or absolute file path or a valid file path prefixed with an environment variable.</exception>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetAbsoluteFilePath(System.String,NDepend.Path.IAbsoluteFilePath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid absolute file path and as a consequence, the returned <paramref name="absoluteFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path string.</param>
            <param name="absoluteFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetRelativeFilePath(System.String,NDepend.Path.IRelativeFilePath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IRelativeFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid relative file path and as a consequence, the returned <paramref name="relativeFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="relativeFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetEnvVarFilePath(System.String,NDepend.Path.IEnvVarFilePath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IEnvVarFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path prefixed with an environment variable and as a consequence, the returned <paramref name="envVarFilePath" /> is not null.</returns>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <param name="envVarFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetVariableFilePath(System.String,NDepend.Path.IVariableFilePath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IVariableFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path that contains variables and as a consequence, the returned <paramref name="variableFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="variableFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetAbsoluteDirectoryPath(System.String,NDepend.Path.IAbsoluteDirectoryPath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid absolute directory path and as a consequence, the returned <paramref name="absoluteDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="absoluteDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetRelativeDirectoryPath(System.String,NDepend.Path.IRelativeDirectoryPath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid relative directory path and as a consequence, the returned <paramref name="relativeDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="relativeDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetEnvVarDirectoryPath(System.String,NDepend.Path.IEnvVarDirectoryPath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IEnvVarDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path prefixed with an environment variable and as a consequence, the returned <paramref name="envVarDirectoryPath" /> is not null.</returns>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <param name="envVarDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetVariableDirectoryPath(System.String,NDepend.Path.IVariableDirectoryPath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IVariableDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path that contains variables and as a consequence, the returned <paramref name="variableDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="variableDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetDirectoryPath(System.String,NDepend.Path.IDirectoryPath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path and as a consequence, the returned <paramref name="directoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="directoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetFilePath(System.String,NDepend.Path.IFilePath@,System.String@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IFilePath" /> object object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path and as a consequence, the returned <paramref name="filePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="filePath">If this method returns <i>true</i>, this is the returned path object.</param>
            <param name="failureReason">If this method returns <i>false</i>, this is the plain english description of the failure.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetAbsoluteFilePath(System.String,NDepend.Path.IAbsoluteFilePath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid absolute file path and as a consequence, the returned <paramref name="absoluteFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path string.</param>
            <param name="absoluteFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetRelativeFilePath(System.String,NDepend.Path.IRelativeFilePath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IRelativeFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid relative file path and as a consequence, the returned <paramref name="relativeFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="relativeFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetEnvVarFilePath(System.String,NDepend.Path.IEnvVarFilePath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IEnvVarFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path prefixed with an environment variable and as a consequence, the returned <paramref name="envVarFilePath" /> is not null.</returns>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <param name="envVarFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetVariableFilePath(System.String,NDepend.Path.IVariableFilePath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IVariableFilePath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path that contains variables and as a consequence, the returned <paramref name="variableFilePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="variableFilePath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetAbsoluteDirectoryPath(System.String,NDepend.Path.IAbsoluteDirectoryPath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid absolute directory path and as a consequence, the returned <paramref name="absoluteDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="absoluteDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetRelativeDirectoryPath(System.String,NDepend.Path.IRelativeDirectoryPath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid relative directory path and as a consequence, the returned <paramref name="relativeDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="relativeDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetEnvVarDirectoryPath(System.String,NDepend.Path.IEnvVarDirectoryPath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IEnvVarDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path prefixed with an environment variable and as a consequence, the returned <paramref name="envVarDirectoryPath" /> is not null.</returns>
            <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The environment variable prefixing the path doesn't need to exist for this operation to complete properly.
            </remarks>
            <param name="pathString">Represents the path.</param>
            <param name="envVarDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetVariableDirectoryPath(System.String,NDepend.Path.IVariableDirectoryPath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IVariableDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path that contains variables and as a consequence, the returned <paramref name="variableDirectoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="variableDirectoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetDirectoryPath(System.String,NDepend.Path.IDirectoryPath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IDirectoryPath" /> object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid directory path and as a consequence, the returned <paramref name="directoryPath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="directoryPath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.TryGetFilePath(System.String,NDepend.Path.IFilePath@)">
            <summary>
            Try get a new <see cref="T:NDepend.Path.IFilePath" /> object object from this string.
            </summary>
            <returns><i>true</i> if <paramref name="pathString" /> is a valid file path and as a consequence, the returned <paramref name="filePath" /> is not null.</returns>
            <remarks>The path represented by this string doesn't need to exist for this operation to complete properly.</remarks>
            <param name="pathString">Represents the path.</param>
            <param name="filePath">If this method returns <i>true</i>, this is the returned path object.</param>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String)">
            <summary>
            Determine whether this string is a valid file path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid relative or absolute file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid file path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid relative or absolute file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String)">
            <summary>
            Determine whether this string is a valid directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid relative or absolute directory path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid relative or absolute directory path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String)">
            <summary>
            Determine whether this string is a valid absolute directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid absolute path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid absolute directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid absolute path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String)">
            <summary>
            Determine whether this string is a valid relative directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid relative path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid relative directory path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid relative path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidEnvVarDirectoryPath(System.String)">
            <summary>
            Determine whether this string is a valid directory path prefixed with an environment variable or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToEnvVarDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IEnvVarDirectoryPath" />.<br />
            In addition to the the letters and digits, the following characters are accepted in the environment variable name _(){}[]$+-#',;.@!
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid path prefixed with an environment variable, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidEnvVarDirectoryPath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid directory path prefixed with an environment variable or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToEnvVarDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IEnvVarDirectoryPath" />.<br />
            In addition to the the letters and digits, the following characters are accepted in the environment variable name _(){}[]$+-#',;.@!
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid path prefixed with an environment variable, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidVariableDirectoryPath(System.String)">
            <summary>
            Determine whether this string is a valid directory path that contains variables.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToVariableDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IVariableDirectoryPath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid path that contains variables, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidVariableDirectoryPath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid directory path that contains variables.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToVariableDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IVariableDirectoryPath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid path that contains variables, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String)">
            <summary>
            Determine whether this string is a valid file absolute path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid absolute file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid file absolute path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid absolute file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String)">
            <summary>
            Determine whether this string is a valid relative file path or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeFilePath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid relative file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid relative file path or not.
            </summary>
            <remarks>
            If this method returns true <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeFilePath" />.
            </remarks>
            <param name="pathString">this string</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid relative file path, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidEnvVarFilePath(System.String)">
            <summary>
            Determine whether this string is a valid file path prefixed with an environment variable or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToEnvVarFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IEnvVarFilePath" />.<br />
            In addition to the the letters and digits, the following characters are accepted in the environment variable name _(){}[]$+-#',;.@!
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid file path prefixed with an environment variable, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidEnvVarFilePath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid file path prefixed with an environment variable or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToEnvVarFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IEnvVarFilePath" />.<br />
            In addition to the the letters and digits, the following characters are accepted in the environment variable name _(){}[]$+-#',;.@!
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid file path prefixed with an environment variable, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidVariableFilePath(System.String)">
            <summary>
            Determine whether this string is a valid file that contains variables, or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToVariableFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IVariableFilePath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <returns>
            <i>true</i> if this string represents a valid file path that contains variables, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:NDepend.Path.PathHelpers.IsValidVariableFilePath(System.String,System.String@)">
            <summary>
            Determine whether this string is a valid file that contains variables, or not.
            </summary>
            <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToVariableFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IVariableFilePath" />.
            </remarks>
            <param name="pathString">This string from which is determined the path validity.</param>
            <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
            <returns>
            <i>true</i> if this string represents a valid file path that contains variables, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="T:NDepend.Path.PathMode">
            <summary>
            Defines a path mode, absolute, relative or prefixed with an environment variable.
            </summary>
            <remarks>
            Since the a PathMode value can be variable, this enumeration can favor a generic way of coding in certain situations, by replacing calls to getters like <see cref="P:NDepend.Path.IPath.IsAbsolutePath" />, <see cref="P:NDepend.Path.IPath.IsRelativePath" /> or <see cref="P:NDepend.Path.IPath.IsEnvVarPath" /> by calls to <see cref="P:NDepend.Path.IPath.PathMode" />.
            </remarks>
        </member>
        <member name="F:NDepend.Path.PathMode.Absolute">
            <summary>
            Represents a absolute path.
            </summary>
        </member>
        <member name="F:NDepend.Path.PathMode.Relative">
            <summary>
            Represents a relative path.
            </summary>
        </member>
        <member name="F:NDepend.Path.PathMode.EnvVar">
            <summary>
            Represents a path prefixed with an environment variable.
            </summary>
        </member>
        <member name="F:NDepend.Path.PathMode.Variable">
            <summary>
            Represents a path that contains variable(s).
            </summary>
        </member>
        <member name="T:NDepend.Path.VariablePathResolvingStatus">
            <summary>
            Defines the result of the <see cref="T:NDepend.Path.IVariablePath" />.<see cref="M:NDepend.Path.IVariablePath.TryResolve(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},NDepend.Path.IAbsolutePath@)" /> method.
            </summary>
        </member>
        <member name="F:NDepend.Path.VariablePathResolvingStatus.Success">
            <summary> 
            All variables have been resolved, and the resulting path is a valid absolute path. 
            </summary>
        </member>
        <member name="F:NDepend.Path.VariablePathResolvingStatus.ErrorUnresolvedVariable">
            <summary> 
            One or several variables cannot be resolved. 
            </summary>
        </member>
        <member name="F:NDepend.Path.VariablePathResolvingStatus.ErrorVariableResolvedButCannotConvertToAbsolutePath">
            <summary> 
            All variables have been resolved but the resulting path is not a valid absolute path. 
            </summary>
        </member>
        <member name="T:NDepend.Trend.DatedValue">
            <summary>
            Represent a dated numeric value of a code metric.
            </summary>
            <remarks>
            Dated value can be persisted with the method <see cref="T:NDepend.Trend.ITrendStore">.</see><see cref="M:NDepend.Trend.ITrendStore.SaveMetricValues(System.DateTime,System.Collections.Generic.IEnumerable{NDepend.Trend.MetricValue},System.String)" />.<br />
            Dated value can be retrieved through the method <see cref="T:NDepend.Trend.ITrendStore" />.<see cref="M:NDepend.Trend.ITrendStore.Load(System.Collections.Generic.IEnumerable{System.UInt32})" />.
            </remarks>
        </member>
        <member name="P:NDepend.Trend.DatedValue.Date">
            <summary>
            Gets the date of the dated value.
            </summary>
        </member>
        <member name="P:NDepend.Trend.DatedValue.Value">
            <summary>
            Gets the numeric value.
            </summary>
        </member>
        <member name="T:NDepend.Trend.DatedValues">
            <summary>
            Represent a set of trend metrics values sharing a same date, and eventuelly a label.
            </summary>
            <remarks>
            DatedValues objects can be obtained from the method <see cref="T:NDepend.Trend.IHistoryData" />.<see cref="P:NDepend.Trend.IHistoryData.DatedValuesDescending" />. <br />
            DatedValues objects are useful to store values extracted from an <see cref="T:NDepend.Trend.IHistoryData" /> object, through the method <see cref="T:NDepend.Trend.ITrendStore" />.<see cref="M:NDepend.Trend.ITrendStore.SaveMetricValues(System.DateTime,System.Collections.Generic.IEnumerable{NDepend.Trend.MetricValue},System.String)" />.<br />
            </remarks>
        </member>
        <member name="P:NDepend.Trend.DatedValues.Date">
            <summary>
            Gets the date of the dated values.
            </summary>
        </member>
        <member name="P:NDepend.Trend.DatedValues.MetricsValues">
            <summary>
            Gets the sequence of metrics' values.
            </summary>
        </member>
        <member name="M:NDepend.Trend.DatedValues.TryGetLabel(System.String@)">
            <summary>
            Gets the eventual label persisted for this date.
            </summary>
            <returns>
            <i>true</i> if a label has been persisted for this date, else returns <i>false</i>.
            </returns>
            <param name="label">The string representing the label. It is non-null and non-empty if this method returns <i>true</i>.</param>
        </member>
        <member name="T:NDepend.Trend.ExtensionMethodsTrend">
            <summary>
            Provides a set of extension methods to handle trend store and data. 
            </summary>
        </member>
        <member name="M:NDepend.Trend.ExtensionMethodsTrend.GetTrendStoreFromDirectory(NDepend.Path.IAbsoluteDirectoryPath)">
            <summary>
            Gets a <see cref="T:NDepend.Trend.ITrendStore" /> object where the storage occurs in the directory <paramref name="directoryPath" />.
            </summary>
            <remarks>
            If the directory doesn't exist, this method tries to create it.
            </remarks>
            <param name="directoryPath">The directory in which the storage occurs.</param>
            <exception cref="T:NDepend.Trend.TrendStoreException"><paramref name="directoryPath" /> doesn't exist and cannot be created.</exception>
        </member>
        <member name="T:NDepend.Trend.IHistoryData">
            <summary>
            Represents trend data retrieved from a <see cref="T:NDepend.Trend.ITrendStore" /> object, through the method <see cref="T:NDepend.Trend.ITrendStore" />.<see cref="M:NDepend.Trend.ITrendStore.Load(System.Collections.Generic.IEnumerable{System.UInt32})" />.
            </summary>
        </member>
        <member name="P:NDepend.Trend.IHistoryData.YearsDescending">
            <summary>
            Gets the descending sequence of years that contains the data.  
            </summary>
        </member>
        <member name="P:NDepend.Trend.IHistoryData.MetricsHistories">
            <summary>
            Gets a dictionary of <see cref="T:NDepend.Trend.IMetricHistory" /> objects, indexed by corresponding metrics name.  
            </summary>
        </member>
        <member name="P:NDepend.Trend.IHistoryData.DatedLabels">
            <summary>
            Get a sorted dictionary of dated label.
            </summary>
        </member>
        <member name="P:NDepend.Trend.IHistoryData.DatedValuesDescending">
            <summary>
            Get trend metrics values through a set of <see cref="T:NDepend.Trend.DatedValues" /> objects.
            </summary>
        </member>
        <member name="T:NDepend.Trend.IMetricHistory">
            <summary>
            Represents trend dated values for the code metric <see cref="P:NDepend.Trend.IMetricHistory.Metric" />.
            </summary>
        </member>
        <member name="P:NDepend.Trend.IMetricHistory.Metric">
            <summary>
            Gets the code metric for which we have historical dated values.
            </summary>
        </member>
        <member name="P:NDepend.Trend.IMetricHistory.DatedValuesDescending">
            <summary>
            Gets list of dated values in descending order, i.e most recent dated value first.
            </summary>
        </member>
        <member name="T:NDepend.Trend.ChartSettings">
            <summary>
            Represent a trend chart settings, to be displayed in the Dashboard panel and eventually, in the report as well.
            </summary>
        </member>
        <member name="F:NDepend.Trend.ChartSettings.CHART_NAME_MAX_CHAR">
            <summary>The maximum number of characters for chart name, which is set to 35</summary>
        </member>
        <member name="M:NDepend.Trend.ChartSettings.#ctor(System.String,System.Boolean,System.Collections.Generic.IReadOnlyList{NDepend.Trend.SerieSettings})">
            <summary>Initializes a new instance of the ChartSettings class.</summary>
            <param name="name">The name of the chart.</param>
            <param name="showInReport">A <i>boolean</i> that indicates if this chart is shown in report.</param>
            <param name="seriesSettings">The series shown on this chart.</param>
            <remarks>If <paramref name="name" /> has more than <see cref="F:NDepend.Trend.ChartSettings.CHART_NAME_MAX_CHAR" /> characters, it is truncated.</remarks>
        </member>
        <member name="P:NDepend.Trend.ChartSettings.Name">
            <summary>
            Gets or sets the name of the chart.
            </summary>
        </member>
        <member name="P:NDepend.Trend.ChartSettings.ShowInReport">
            <summary>
            Gets or sets a <i>boolean</i> that indicates if the chart is shown in report.
            </summary>
        </member>
        <member name="P:NDepend.Trend.ChartSettings.SeriesSettings">
            <summary>
            Gets or sets the series settings shown on this chart.
            </summary>
            <remarks>The order in the list is important since charts will be shown in this order.</remarks>
        </member>
        <member name="T:NDepend.Trend.SerieSettings">
            <summary>Stores serie attribute.</summary>
        </member>
        <member name="F:NDepend.Trend.SerieSettings.MINIMUM_SCALE_EXPONENT">
            <summary>The serie scale exponent is at minimim -9 (included).</summary>
        </member>
        <member name="F:NDepend.Trend.SerieSettings.MAXIMUM_SCALE_EXPONENT">
            <summary>The serie scale exponent is at maximum 9 (included).</summary>
        </member>
        <member name="M:NDepend.Trend.SerieSettings.#ctor(NDepend.Trend.Metric,NDepend.Helpers.NdpColor,NDepend.Trend.SerieChartType,System.SByte)">
            <summary>Initializes a new instance of the SerieSettings class.</summary>
            <param name="metric">The trend <see cref="P:NDepend.Trend.SerieSettings.Metric" /> of this serie.</param>
            <param name="color">The color of the dated value of this serie.</param>
            <param name="chartType">The chart type of this series.</param>
            <param name="scaleExponent">Define the factor by which the serie's values are multiplied. 0 means on scaling</param>
        </member>
        <member name="P:NDepend.Trend.SerieSettings.Metric">
            <summary>Gets the trend <see cref="P:NDepend.Trend.SerieSettings.Metric" /> of this serie.</summary>
        </member>
        <member name="P:NDepend.Trend.SerieSettings.Color">
            <summary>Gets the color of the dated value of this serie.</summary>
        </member>
        <member name="P:NDepend.Trend.SerieSettings.ChartType">
            <summary>Gets the chart type of this series.</summary>
        </member>
        <member name="P:NDepend.Trend.SerieSettings.ScaleExponent">
            <summary>Gets the scale exponent.</summary>
        </member>
        <member name="P:NDepend.Trend.SerieSettings.Scale">
            <summary>Gets the factor by which the serie's values are multiplied. 0 means on scaling.</summary>
        </member>
        <member name="T:NDepend.Trend.ITrendStore">
            <summary>
            Represents a store that persists trend metrics.
            </summary>
            <remarks>
            A <see cref="T:NDepend.Trend.ITrendStore" /> object can be obtained with the extension method <see cref="T:NDepend.Trend.ExtensionMethodsTrend" />.<see cref="M:NDepend.Trend.ExtensionMethodsTrend.GetTrendStoreFromDirectory(NDepend.Path.IAbsoluteDirectoryPath)" /> applied on the directory path returned by <see cref="T:NDepend.Project.IProjectTrend" />.<see cref="P:NDepend.Project.IProjectTrend.TrendStoreDirectory" />.
            </remarks>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.GetYearsContainingValuesDescending">
            <summary>
            Returns years for which trend metrics values are available in this store.
            </summary>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.GetDateOfMostRecentSave">
            <summary>
            Returns the date of the most recently saved data in this store.
            </summary>
            <returns>
            <i>null</i> if no save occured in this store.
            </returns>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while reading trend store.</exception>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.Load(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns the complete history data for <paramref name="years" /> in input.
            </summary>
            <param name="years">The years for which you want to obtain trend metrics values.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="years" /> contains one or several years for which trend metrics values are not available, or contains doublons.<br />
            Use the method <see cref="M:NDepend.Trend.ITrendStore.GetYearsContainingValuesDescending" /> to years for which trend metrics values are available.
            </exception>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while reading trend store.</exception>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.SaveMetricValues(System.DateTime,System.Collections.Generic.IEnumerable{NDepend.Trend.MetricValue},System.String)">
            <summary>
            Save one or several dated metrics values, tagged with a label.
            </summary>
            <remarks>
            If for one or several metrics in <paramref name="metricsValues" />, values defined at <paramref name="date" /> already exist, they are overridden by the new values.<br />
            The date equality is defined if the two dates represent the same dated second, no matter the number of miliseconds.
            </remarks>
            <param name="date">The date of the metric values to save.</param>
            <param name="metricsValues">The metric values to save.</param>
            <param name="label">
            An optional label applied to this particular date.<br />
            Typically, the label represents the version of the product.<br />
            An empty string means that there is no label to store for 
            </param>
            <exception cref="T:System.ArgumentException"><paramref name="metricsValues" /> contains some metrics with the same name.</exception>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while persisting in the trend store.</exception>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.SaveMetricValues(System.DateTime,System.Collections.Generic.IEnumerable{NDepend.Trend.MetricValue})">
            <summary>
            Save one or several dated metrics values.
            </summary>
            <remarks>
            If for one or several metrics in <paramref name="metricsValues" />, values defined at <paramref name="date" /> already exist, they are overridden by the new values.<br />
            The date equality is defined if the two dates represent the same dated second, no matter the number of miliseconds.
            </remarks>
            <param name="date">The date of the metric values to save.</param>
            <param name="metricsValues">The metric values to save.</param>
            <exception cref="T:System.ArgumentException"><paramref name="metricsValues" /> contains some metrics with the same name.</exception>
            <exception cref="T:NDepend.Trend.TrendStoreException">An error occured while persisting in the trend store.</exception>
        </member>
        <member name="M:NDepend.Trend.ITrendStore.RemoveMetricValues(System.DateTime)">
            <summary>
            Remove all metrics values stored at <paramref name="date" />.
            </summary>
            <remarks>
            The date equality is defined by the same dated second, no matter the number of miliseconds.
            </remarks>
            <param name="date">The date of the metric values to remove.</param>
            <exception cref="T:NDepend.Trend.TrendStoreException">There is no metric values stored for <paramref name="date" /> or an error occured while persisting in the trend store.</exception>
        </member>
        <member name="T:NDepend.Trend.Metric">
            <summary>
            Represent a code metric for which trend dated values are stored.
            </summary>
        </member>
        <member name="M:NDepend.Trend.Metric.#ctor(System.String,System.String)">
            <summary>
            Create a code metric object. 
            </summary>
            <param name="name">The name of the code metric.</param>
            <param name="unit">The unit used to quantify metric values.</param>
        </member>
        <member name="P:NDepend.Trend.Metric.Name">
            <summary>
            Gets the name of the code metric.
            </summary>
        </member>
        <member name="P:NDepend.Trend.Metric.Unit">
            <summary>
            Gets the unit used to quantify metric values.
            </summary>
        </member>
        <member name="T:NDepend.Trend.MetricValue">
            <summary>
            Represents a pair of a code metric and a numeric value.
            </summary>
            <remarks>
            This structure is used when storing a set of new metric values through the method <see cref="T:NDepend.Trend.ITrendStore" />.<see cref="M:NDepend.Trend.ITrendStore.SaveMetricValues(System.DateTime,System.Collections.Generic.IEnumerable{NDepend.Trend.MetricValue},System.String)" />.
            </remarks>
        </member>
        <member name="M:NDepend.Trend.MetricValue.#ctor(NDepend.Trend.Metric,System.Single)">
            <summary>
            Create a apair of a code metric and a numeric value.
            </summary>
            <param name="metric">The code metric.</param>
            <param name="value">The numerical value.</param>
        </member>
        <member name="P:NDepend.Trend.MetricValue.Metric">
            <summary>
            Gets the code metric.
            </summary>
        </member>
        <member name="P:NDepend.Trend.MetricValue.MetricName">
            <summary>
            Gets the name of the code metric.
            </summary>
        </member>
        <member name="P:NDepend.Trend.MetricValue.MetricUnit">
            <summary>
            Gets the unit used to quantify metric values.
            </summary>
        </member>
        <member name="P:NDepend.Trend.MetricValue.Value">
            <summary>
            Gets the metric numerical value.
            </summary>
        </member>
        <member name="T:NDepend.Trend.SerieChartType">
            <summary>Specifies a chart type for a <see cref="T:NDepend.Trend.SerieSettings" />.</summary>
        </member>
        <member name="F:NDepend.Trend.SerieChartType.Line">
            <summary>Line chart type</summary>
        </member>
        <member name="F:NDepend.Trend.SerieChartType.Area">
            <summary>Area chart type</summary>
        </member>
        <member name="T:NDepend.Trend.TrendStoreException">
            <summary>
            The exception that is thrown whenever a read or write access to a <see cref="T:NDepend.Trend.ITrendStore" /> object fails.
            </summary>
        </member>
        <member name="M:NDepend.Trend.TrendStoreException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NDepend.Trend.TrendStoreException" /> class with a specified error message.
            </summary>
            <param name="message">A message that describes the error.</param>
        </member>
        <member name="T:NDepend.Trend.TrendMetricsLogLabel">
            <summary>
            Represents the kind of label used to tag trend metrics logs.
            </summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.None">
            <summary>None</summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.VersionMajor">
            <summary>VersionMajor</summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.VersionMajorMinor">
            <summary>VersionMajorMinor</summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.VersionMajorMinorBuild">
            <summary>VersionMajorMinorBuild</summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.VersionMajorMinorBuildRevision">
            <summary>VersionMajorMinorBuildRevision</summary>
        </member>
        <member name="F:NDepend.Trend.TrendMetricsLogLabel.Default">
            <summary>Default</summary>
        </member>
        <member name="T:NDepend.NDependServicesProvider">
            <summary>
            Create an instance of this class once in your program, to obtain NDepend.API services managers objects.
            </summary>
            <remarks>
            If you prefer you can technically create several instances of this class since it is stateless.
            </remarks>
        </member>
        <member name="P:NDepend.NDependServicesProvider.ProjectManager">
            <summary>
            Gets a <see cref="T:NDepend.Project.IProjectManager" /> object.
            </summary>
        </member>
        <member name="P:NDepend.NDependServicesProvider.AnalysisManager">
            <summary>
            Gets a <see cref="T:NDepend.Analysis.IAnalysisManager" /> object.
            </summary>
        </member>
        <member name="P:NDepend.NDependServicesProvider.VisualStudioManager">
            <summary>
            Gets a <see cref="T:NDepend.DotNet.VisualStudio.IVisualStudioManager" /> object.
            </summary>
        </member>
        <member name="P:NDepend.NDependServicesProvider.DotNetManager">
            <summary>
            Gets a <see cref="T:NDepend.DotNet.IDotNetManager" /> object.
            </summary>
        </member>
        <member name="M:NDepend.NDependServicesProvider.#ctor">
            <summary>
            Unique constructor for this class.
            </summary>
        </member>
    </members>
</doc>
